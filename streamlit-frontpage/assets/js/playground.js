function x3(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var wb = { exports: {} }, pt = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _E;
function A3() {
  if (_E) return pt;
  _E = 1;
  var o = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), c = Symbol.for("react.consumer"), d = Symbol.for("react.context"), m = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), b = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), A = Symbol.iterator;
  function w(B) {
    return B === null || typeof B != "object" ? null : (B = A && B[A] || B["@@iterator"], typeof B == "function" ? B : null);
  }
  var E = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, z = Object.assign, U = {};
  function V(B, L, se) {
    this.props = B, this.context = L, this.refs = U, this.updater = se || E;
  }
  V.prototype.isReactComponent = {}, V.prototype.setState = function(B, L) {
    if (typeof B != "object" && typeof B != "function" && B != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, B, L, "setState");
  }, V.prototype.forceUpdate = function(B) {
    this.updater.enqueueForceUpdate(this, B, "forceUpdate");
  };
  function G() {
  }
  G.prototype = V.prototype;
  function ie(B, L, se) {
    this.props = B, this.context = L, this.refs = U, this.updater = se || E;
  }
  var me = ie.prototype = new G();
  me.constructor = ie, z(me, V.prototype), me.isPureReactComponent = !0;
  var pe = Array.isArray, ne = { H: null, A: null, T: null, S: null, V: null }, ye = Object.prototype.hasOwnProperty;
  function Oe(B, L, se, le, Ae, je) {
    return se = je.ref, {
      $$typeof: o,
      type: B,
      key: L,
      ref: se !== void 0 ? se : null,
      props: je
    };
  }
  function we(B, L) {
    return Oe(
      B.type,
      L,
      void 0,
      void 0,
      void 0,
      B.props
    );
  }
  function Re(B) {
    return typeof B == "object" && B !== null && B.$$typeof === o;
  }
  function Te(B) {
    var L = { "=": "=0", ":": "=2" };
    return "$" + B.replace(/[=:]/g, function(se) {
      return L[se];
    });
  }
  var ze = /\/+/g;
  function fe(B, L) {
    return typeof B == "object" && B !== null && B.key != null ? Te("" + B.key) : L.toString(36);
  }
  function Qe() {
  }
  function Ve(B) {
    switch (B.status) {
      case "fulfilled":
        return B.value;
      case "rejected":
        throw B.reason;
      default:
        switch (typeof B.status == "string" ? B.then(Qe, Qe) : (B.status = "pending", B.then(
          function(L) {
            B.status === "pending" && (B.status = "fulfilled", B.value = L);
          },
          function(L) {
            B.status === "pending" && (B.status = "rejected", B.reason = L);
          }
        )), B.status) {
          case "fulfilled":
            return B.value;
          case "rejected":
            throw B.reason;
        }
    }
    throw B;
  }
  function Xe(B, L, se, le, Ae) {
    var je = typeof B;
    (je === "undefined" || je === "boolean") && (B = null);
    var Ne = !1;
    if (B === null) Ne = !0;
    else
      switch (je) {
        case "bigint":
        case "string":
        case "number":
          Ne = !0;
          break;
        case "object":
          switch (B.$$typeof) {
            case o:
            case e:
              Ne = !0;
              break;
            case S:
              return Ne = B._init, Xe(
                Ne(B._payload),
                L,
                se,
                le,
                Ae
              );
          }
      }
    if (Ne)
      return Ae = Ae(B), Ne = le === "" ? "." + fe(B, 0) : le, pe(Ae) ? (se = "", Ne != null && (se = Ne.replace(ze, "$&/") + "/"), Xe(Ae, L, se, "", function(Ut) {
        return Ut;
      })) : Ae != null && (Re(Ae) && (Ae = we(
        Ae,
        se + (Ae.key == null || B && B.key === Ae.key ? "" : ("" + Ae.key).replace(
          ze,
          "$&/"
        ) + "/") + Ne
      )), L.push(Ae)), 1;
    Ne = 0;
    var Ke = le === "" ? "." : le + ":";
    if (pe(B))
      for (var Nt = 0; Nt < B.length; Nt++)
        le = B[Nt], je = Ke + fe(le, Nt), Ne += Xe(
          le,
          L,
          se,
          je,
          Ae
        );
    else if (Nt = w(B), typeof Nt == "function")
      for (B = Nt.call(B), Nt = 0; !(le = B.next()).done; )
        le = le.value, je = Ke + fe(le, Nt++), Ne += Xe(
          le,
          L,
          se,
          je,
          Ae
        );
    else if (je === "object") {
      if (typeof B.then == "function")
        return Xe(
          Ve(B),
          L,
          se,
          le,
          Ae
        );
      throw L = String(B), Error(
        "Objects are not valid as a React child (found: " + (L === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : L) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Ne;
  }
  function F(B, L, se) {
    if (B == null) return B;
    var le = [], Ae = 0;
    return Xe(B, le, "", "", function(je) {
      return L.call(se, je, Ae++);
    }), le;
  }
  function Z(B) {
    if (B._status === -1) {
      var L = B._result;
      L = L(), L.then(
        function(se) {
          (B._status === 0 || B._status === -1) && (B._status = 1, B._result = se);
        },
        function(se) {
          (B._status === 0 || B._status === -1) && (B._status = 2, B._result = se);
        }
      ), B._status === -1 && (B._status = 0, B._result = L);
    }
    if (B._status === 1) return B._result.default;
    throw B._result;
  }
  var ge = typeof reportError == "function" ? reportError : function(B) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var L = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof B == "object" && B !== null && typeof B.message == "string" ? String(B.message) : String(B),
        error: B
      });
      if (!window.dispatchEvent(L)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", B);
      return;
    }
    console.error(B);
  };
  function Se() {
  }
  return pt.Children = {
    map: F,
    forEach: function(B, L, se) {
      F(
        B,
        function() {
          L.apply(this, arguments);
        },
        se
      );
    },
    count: function(B) {
      var L = 0;
      return F(B, function() {
        L++;
      }), L;
    },
    toArray: function(B) {
      return F(B, function(L) {
        return L;
      }) || [];
    },
    only: function(B) {
      if (!Re(B))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return B;
    }
  }, pt.Component = V, pt.Fragment = n, pt.Profiler = s, pt.PureComponent = ie, pt.StrictMode = l, pt.Suspense = y, pt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ne, pt.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(B) {
      return ne.H.useMemoCache(B);
    }
  }, pt.cache = function(B) {
    return function() {
      return B.apply(null, arguments);
    };
  }, pt.cloneElement = function(B, L, se) {
    if (B == null)
      throw Error(
        "The argument must be a React element, but you passed " + B + "."
      );
    var le = z({}, B.props), Ae = B.key, je = void 0;
    if (L != null)
      for (Ne in L.ref !== void 0 && (je = void 0), L.key !== void 0 && (Ae = "" + L.key), L)
        !ye.call(L, Ne) || Ne === "key" || Ne === "__self" || Ne === "__source" || Ne === "ref" && L.ref === void 0 || (le[Ne] = L[Ne]);
    var Ne = arguments.length - 2;
    if (Ne === 1) le.children = se;
    else if (1 < Ne) {
      for (var Ke = Array(Ne), Nt = 0; Nt < Ne; Nt++)
        Ke[Nt] = arguments[Nt + 2];
      le.children = Ke;
    }
    return Oe(B.type, Ae, void 0, void 0, je, le);
  }, pt.createContext = function(B) {
    return B = {
      $$typeof: d,
      _currentValue: B,
      _currentValue2: B,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, B.Provider = B, B.Consumer = {
      $$typeof: c,
      _context: B
    }, B;
  }, pt.createElement = function(B, L, se) {
    var le, Ae = {}, je = null;
    if (L != null)
      for (le in L.key !== void 0 && (je = "" + L.key), L)
        ye.call(L, le) && le !== "key" && le !== "__self" && le !== "__source" && (Ae[le] = L[le]);
    var Ne = arguments.length - 2;
    if (Ne === 1) Ae.children = se;
    else if (1 < Ne) {
      for (var Ke = Array(Ne), Nt = 0; Nt < Ne; Nt++)
        Ke[Nt] = arguments[Nt + 2];
      Ae.children = Ke;
    }
    if (B && B.defaultProps)
      for (le in Ne = B.defaultProps, Ne)
        Ae[le] === void 0 && (Ae[le] = Ne[le]);
    return Oe(B, je, void 0, void 0, null, Ae);
  }, pt.createRef = function() {
    return { current: null };
  }, pt.forwardRef = function(B) {
    return { $$typeof: m, render: B };
  }, pt.isValidElement = Re, pt.lazy = function(B) {
    return {
      $$typeof: S,
      _payload: { _status: -1, _result: B },
      _init: Z
    };
  }, pt.memo = function(B, L) {
    return {
      $$typeof: b,
      type: B,
      compare: L === void 0 ? null : L
    };
  }, pt.startTransition = function(B) {
    var L = ne.T, se = {};
    ne.T = se;
    try {
      var le = B(), Ae = ne.S;
      Ae !== null && Ae(se, le), typeof le == "object" && le !== null && typeof le.then == "function" && le.then(Se, ge);
    } catch (je) {
      ge(je);
    } finally {
      ne.T = L;
    }
  }, pt.unstable_useCacheRefresh = function() {
    return ne.H.useCacheRefresh();
  }, pt.use = function(B) {
    return ne.H.use(B);
  }, pt.useActionState = function(B, L, se) {
    return ne.H.useActionState(B, L, se);
  }, pt.useCallback = function(B, L) {
    return ne.H.useCallback(B, L);
  }, pt.useContext = function(B) {
    return ne.H.useContext(B);
  }, pt.useDebugValue = function() {
  }, pt.useDeferredValue = function(B, L) {
    return ne.H.useDeferredValue(B, L);
  }, pt.useEffect = function(B, L, se) {
    var le = ne.H;
    if (typeof se == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return le.useEffect(B, L);
  }, pt.useId = function() {
    return ne.H.useId();
  }, pt.useImperativeHandle = function(B, L, se) {
    return ne.H.useImperativeHandle(B, L, se);
  }, pt.useInsertionEffect = function(B, L) {
    return ne.H.useInsertionEffect(B, L);
  }, pt.useLayoutEffect = function(B, L) {
    return ne.H.useLayoutEffect(B, L);
  }, pt.useMemo = function(B, L) {
    return ne.H.useMemo(B, L);
  }, pt.useOptimistic = function(B, L) {
    return ne.H.useOptimistic(B, L);
  }, pt.useReducer = function(B, L, se) {
    return ne.H.useReducer(B, L, se);
  }, pt.useRef = function(B) {
    return ne.H.useRef(B);
  }, pt.useState = function(B) {
    return ne.H.useState(B);
  }, pt.useSyncExternalStore = function(B, L, se) {
    return ne.H.useSyncExternalStore(
      B,
      L,
      se
    );
  }, pt.useTransition = function() {
    return ne.H.useTransition();
  }, pt.version = "19.1.0", pt;
}
var Ky = { exports: {} };
Ky.exports;
var HE;
function w3() {
  return HE || (HE = 1, function(o, e) {
    var n = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    n.NODE_ENV !== "production" && function() {
      function l(M, Y) {
        Object.defineProperty(d.prototype, M, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              Y[0],
              Y[1]
            );
          }
        });
      }
      function s(M) {
        return M === null || typeof M != "object" ? null : (M = ho && M[ho] || M["@@iterator"], typeof M == "function" ? M : null);
      }
      function c(M, Y) {
        M = (M = M.constructor) && (M.displayName || M.name) || "ReactClass";
        var xe = M + "." + Y;
        cr[xe] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          Y,
          M
        ), cr[xe] = !0);
      }
      function d(M, Y, xe) {
        this.props = M, this.context = Y, this.refs = af, this.updater = xe || Da;
      }
      function m() {
      }
      function y(M, Y, xe) {
        this.props = M, this.context = Y, this.refs = af, this.updater = xe || Da;
      }
      function b(M) {
        return "" + M;
      }
      function S(M) {
        try {
          b(M);
          var Y = !1;
        } catch {
          Y = !0;
        }
        if (Y) {
          Y = console;
          var xe = Y.error, Ee = typeof Symbol == "function" && Symbol.toStringTag && M[Symbol.toStringTag] || M.constructor.name || "Object";
          return xe.call(
            Y,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            Ee
          ), b(M);
        }
      }
      function A(M) {
        if (M == null) return null;
        if (typeof M == "function")
          return M.$$typeof === ad ? null : M.displayName || M.name || null;
        if (typeof M == "string") return M;
        switch (M) {
          case L:
            return "Fragment";
          case le:
            return "Profiler";
          case se:
            return "StrictMode";
          case Ke:
            return "Suspense";
          case Nt:
            return "SuspenseList";
          case Ti:
            return "Activity";
        }
        if (typeof M == "object")
          switch (typeof M.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), M.$$typeof) {
            case B:
              return "Portal";
            case je:
              return (M.displayName || "Context") + ".Provider";
            case Ae:
              return (M._context.displayName || "Context") + ".Consumer";
            case Ne:
              var Y = M.render;
              return M = M.displayName, M || (M = Y.displayName || Y.name || "", M = M !== "" ? "ForwardRef(" + M + ")" : "ForwardRef"), M;
            case Ut:
              return Y = M.displayName || null, Y !== null ? Y : A(M.type) || "Memo";
            case Rn:
              Y = M._payload, M = M._init;
              try {
                return A(M(Y));
              } catch {
              }
          }
        return null;
      }
      function w(M) {
        if (M === L) return "<>";
        if (typeof M == "object" && M !== null && M.$$typeof === Rn)
          return "<...>";
        try {
          var Y = A(M);
          return Y ? "<" + Y + ">" : "<...>";
        } catch {
          return "<...>";
        }
      }
      function E() {
        var M = lt.A;
        return M === null ? null : M.getOwner();
      }
      function z() {
        return Error("react-stack-top-frame");
      }
      function U(M) {
        if (fr.call(M, "key")) {
          var Y = Object.getOwnPropertyDescriptor(M, "key").get;
          if (Y && Y.isReactWarning) return !1;
        }
        return M.key !== void 0;
      }
      function V(M, Y) {
        function xe() {
          as || (as = !0, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            Y
          ));
        }
        xe.isReactWarning = !0, Object.defineProperty(M, "key", {
          get: xe,
          configurable: !0
        });
      }
      function G() {
        var M = A(this.type);
        return go[M] || (go[M] = !0, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        )), M = this.props.ref, M !== void 0 ? M : null;
      }
      function ie(M, Y, xe, Ee, _e, ht, tt, St) {
        return xe = ht.ref, M = {
          $$typeof: Se,
          type: M,
          key: Y,
          props: ht,
          _owner: _e
        }, (xe !== void 0 ? xe : null) !== null ? Object.defineProperty(M, "ref", {
          enumerable: !1,
          get: G
        }) : Object.defineProperty(M, "ref", { enumerable: !1, value: null }), M._store = {}, Object.defineProperty(M._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(M, "_debugInfo", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: null
        }), Object.defineProperty(M, "_debugStack", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: tt
        }), Object.defineProperty(M, "_debugTask", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: St
        }), Object.freeze && (Object.freeze(M.props), Object.freeze(M)), M;
      }
      function me(M, Y) {
        return Y = ie(
          M.type,
          Y,
          void 0,
          void 0,
          M._owner,
          M.props,
          M._debugStack,
          M._debugTask
        ), M._store && (Y._store.validated = M._store.validated), Y;
      }
      function pe(M) {
        return typeof M == "object" && M !== null && M.$$typeof === Se;
      }
      function ne(M) {
        var Y = { "=": "=0", ":": "=2" };
        return "$" + M.replace(/[=:]/g, function(xe) {
          return Y[xe];
        });
      }
      function ye(M, Y) {
        return typeof M == "object" && M !== null && M.key != null ? (S(M.key), ne("" + M.key)) : Y.toString(36);
      }
      function Oe() {
      }
      function we(M) {
        switch (M.status) {
          case "fulfilled":
            return M.value;
          case "rejected":
            throw M.reason;
          default:
            switch (typeof M.status == "string" ? M.then(Oe, Oe) : (M.status = "pending", M.then(
              function(Y) {
                M.status === "pending" && (M.status = "fulfilled", M.value = Y);
              },
              function(Y) {
                M.status === "pending" && (M.status = "rejected", M.reason = Y);
              }
            )), M.status) {
              case "fulfilled":
                return M.value;
              case "rejected":
                throw M.reason;
            }
        }
        throw M;
      }
      function Re(M, Y, xe, Ee, _e) {
        var ht = typeof M;
        (ht === "undefined" || ht === "boolean") && (M = null);
        var tt = !1;
        if (M === null) tt = !0;
        else
          switch (ht) {
            case "bigint":
            case "string":
            case "number":
              tt = !0;
              break;
            case "object":
              switch (M.$$typeof) {
                case Se:
                case B:
                  tt = !0;
                  break;
                case Rn:
                  return tt = M._init, Re(
                    tt(M._payload),
                    Y,
                    xe,
                    Ee,
                    _e
                  );
              }
          }
        if (tt) {
          tt = M, _e = _e(tt);
          var St = Ee === "" ? "." + ye(tt, 0) : Ee;
          return mo(_e) ? (xe = "", St != null && (xe = St.replace(of, "$&/") + "/"), Re(_e, Y, xe, "", function(Sn) {
            return Sn;
          })) : _e != null && (pe(_e) && (_e.key != null && (tt && tt.key === _e.key || S(_e.key)), xe = me(
            _e,
            xe + (_e.key == null || tt && tt.key === _e.key ? "" : ("" + _e.key).replace(
              of,
              "$&/"
            ) + "/") + St
          ), Ee !== "" && tt != null && pe(tt) && tt.key == null && tt._store && !tt._store.validated && (xe._store.validated = 2), _e = xe), Y.push(_e)), 1;
        }
        if (tt = 0, St = Ee === "" ? "." : Ee + ":", mo(M))
          for (var Je = 0; Je < M.length; Je++)
            Ee = M[Je], ht = St + ye(Ee, Je), tt += Re(
              Ee,
              Y,
              xe,
              ht,
              _e
            );
        else if (Je = s(M), typeof Je == "function")
          for (Je === M.entries && (Fn || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), Fn = !0), M = Je.call(M), Je = 0; !(Ee = M.next()).done; )
            Ee = Ee.value, ht = St + ye(Ee, Je++), tt += Re(
              Ee,
              Y,
              xe,
              ht,
              _e
            );
        else if (ht === "object") {
          if (typeof M.then == "function")
            return Re(
              we(M),
              Y,
              xe,
              Ee,
              _e
            );
          throw Y = String(M), Error(
            "Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return tt;
      }
      function Te(M, Y, xe) {
        if (M == null) return M;
        var Ee = [], _e = 0;
        return Re(M, Ee, "", "", function(ht) {
          return Y.call(xe, ht, _e++);
        }), Ee;
      }
      function ze(M) {
        if (M._status === -1) {
          var Y = M._result;
          Y = Y(), Y.then(
            function(xe) {
              (M._status === 0 || M._status === -1) && (M._status = 1, M._result = xe);
            },
            function(xe) {
              (M._status === 0 || M._status === -1) && (M._status = 2, M._result = xe);
            }
          ), M._status === -1 && (M._status = 0, M._result = Y);
        }
        if (M._status === 1)
          return Y = M._result, Y === void 0 && console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like:
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,
            Y
          ), "default" in Y || console.error(
            `lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like:
  const MyComponent = lazy(() => import('./MyComponent'))`,
            Y
          ), Y.default;
        throw M._result;
      }
      function fe() {
        var M = lt.H;
        return M === null && console.error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        ), M;
      }
      function Qe() {
      }
      function Ve(M) {
        if (yo === null)
          try {
            var Y = ("require" + Math.random()).slice(0, 7);
            yo = (o && o[Y]).call(
              o,
              "timers"
            ).setImmediate;
          } catch {
            yo = function(Ee) {
              sf === !1 && (sf = !0, typeof MessageChannel > "u" && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var _e = new MessageChannel();
              _e.port1.onmessage = Ee, _e.port2.postMessage(void 0);
            };
          }
        return yo(M);
      }
      function Xe(M) {
        return 1 < M.length && typeof AggregateError == "function" ? new AggregateError(M) : M[0];
      }
      function F(M, Y) {
        Y !== Kl - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        ), Kl = Y;
      }
      function Z(M, Y, xe) {
        var Ee = lt.actQueue;
        if (Ee !== null)
          if (Ee.length !== 0)
            try {
              ge(Ee), Ve(function() {
                return Z(M, Y, xe);
              });
              return;
            } catch (_e) {
              lt.thrownErrors.push(_e);
            }
          else lt.actQueue = null;
        0 < lt.thrownErrors.length ? (Ee = Xe(lt.thrownErrors), lt.thrownErrors.length = 0, xe(Ee)) : Y(M);
      }
      function ge(M) {
        if (!Ui) {
          Ui = !0;
          var Y = 0;
          try {
            for (; Y < M.length; Y++) {
              var xe = M[Y];
              do {
                lt.didUsePromise = !1;
                var Ee = xe(!1);
                if (Ee !== null) {
                  if (lt.didUsePromise) {
                    M[Y] = xe, M.splice(0, Y);
                    return;
                  }
                  xe = Ee;
                } else break;
              } while (!0);
            }
            M.length = 0;
          } catch (_e) {
            M.splice(0, Y + 1), lt.thrownErrors.push(_e);
          } finally {
            Ui = !1;
          }
        }
      }
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var Se = Symbol.for("react.transitional.element"), B = Symbol.for("react.portal"), L = Symbol.for("react.fragment"), se = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), Ae = Symbol.for("react.consumer"), je = Symbol.for("react.context"), Ne = Symbol.for("react.forward_ref"), Ke = Symbol.for("react.suspense"), Nt = Symbol.for("react.suspense_list"), Ut = Symbol.for("react.memo"), Rn = Symbol.for("react.lazy"), Ti = Symbol.for("react.activity"), ho = Symbol.iterator, cr = {}, Da = {
        isMounted: function() {
          return !1;
        },
        enqueueForceUpdate: function(M) {
          c(M, "forceUpdate");
        },
        enqueueReplaceState: function(M) {
          c(M, "replaceState");
        },
        enqueueSetState: function(M) {
          c(M, "setState");
        }
      }, ld = Object.assign, af = {};
      Object.freeze(af), d.prototype.isReactComponent = {}, d.prototype.setState = function(M, Y) {
        if (typeof M != "object" && typeof M != "function" && M != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, M, Y, "setState");
      }, d.prototype.forceUpdate = function(M) {
        this.updater.enqueueForceUpdate(this, M, "forceUpdate");
      };
      var _t = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, po;
      for (po in _t)
        _t.hasOwnProperty(po) && l(po, _t[po]);
      m.prototype = d.prototype, _t = y.prototype = new m(), _t.constructor = y, ld(_t, d.prototype), _t.isPureReactComponent = !0;
      var mo = Array.isArray, ad = Symbol.for("react.client.reference"), lt = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1,
        didUsePromise: !1,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, fr = Object.prototype.hasOwnProperty, hr = console.createTask ? console.createTask : function() {
        return null;
      };
      _t = {
        "react-stack-bottom-frame": function(M) {
          return M();
        }
      };
      var as, od, go = {}, ci = _t["react-stack-bottom-frame"].bind(_t, z)(), El = hr(w(z)), Fn = !1, of = /\/+/g, bu = typeof reportError == "function" ? reportError : function(M) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var Y = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof M == "object" && M !== null && typeof M.message == "string" ? String(M.message) : String(M),
            error: M
          });
          if (!window.dispatchEvent(Y)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", M);
          return;
        }
        console.error(M);
      }, sf = !1, yo = null, Kl = 0, Kn = !1, Ui = !1, Cl = typeof queueMicrotask == "function" ? function(M) {
        queueMicrotask(function() {
          return queueMicrotask(M);
        });
      } : Ve;
      _t = Object.freeze({
        __proto__: null,
        c: function(M) {
          return fe().useMemoCache(M);
        }
      }), e.Children = {
        map: Te,
        forEach: function(M, Y, xe) {
          Te(
            M,
            function() {
              Y.apply(this, arguments);
            },
            xe
          );
        },
        count: function(M) {
          var Y = 0;
          return Te(M, function() {
            Y++;
          }), Y;
        },
        toArray: function(M) {
          return Te(M, function(Y) {
            return Y;
          }) || [];
        },
        only: function(M) {
          if (!pe(M))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return M;
        }
      }, e.Component = d, e.Fragment = L, e.Profiler = le, e.PureComponent = y, e.StrictMode = se, e.Suspense = Ke, e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = lt, e.__COMPILER_RUNTIME = _t, e.act = function(M) {
        var Y = lt.actQueue, xe = Kl;
        Kl++;
        var Ee = lt.actQueue = Y !== null ? Y : [], _e = !1;
        try {
          var ht = M();
        } catch (Je) {
          lt.thrownErrors.push(Je);
        }
        if (0 < lt.thrownErrors.length)
          throw F(Y, xe), M = Xe(lt.thrownErrors), lt.thrownErrors.length = 0, M;
        if (ht !== null && typeof ht == "object" && typeof ht.then == "function") {
          var tt = ht;
          return Cl(function() {
            _e || Kn || (Kn = !0, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          }), {
            then: function(Je, Sn) {
              _e = !0, tt.then(
                function(Ma) {
                  if (F(Y, xe), xe === 0) {
                    try {
                      ge(Ee), Ve(function() {
                        return Z(
                          Ma,
                          Je,
                          Sn
                        );
                      });
                    } catch (za) {
                      lt.thrownErrors.push(za);
                    }
                    if (0 < lt.thrownErrors.length) {
                      var Pm = Xe(
                        lt.thrownErrors
                      );
                      lt.thrownErrors.length = 0, Sn(Pm);
                    }
                  } else Je(Ma);
                },
                function(Ma) {
                  F(Y, xe), 0 < lt.thrownErrors.length && (Ma = Xe(
                    lt.thrownErrors
                  ), lt.thrownErrors.length = 0), Sn(Ma);
                }
              );
            }
          };
        }
        var St = ht;
        if (F(Y, xe), xe === 0 && (ge(Ee), Ee.length !== 0 && Cl(function() {
          _e || Kn || (Kn = !0, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), lt.actQueue = null), 0 < lt.thrownErrors.length)
          throw M = Xe(lt.thrownErrors), lt.thrownErrors.length = 0, M;
        return {
          then: function(Je, Sn) {
            _e = !0, xe === 0 ? (lt.actQueue = Ee, Ve(function() {
              return Z(
                St,
                Je,
                Sn
              );
            })) : Je(St);
          }
        };
      }, e.cache = function(M) {
        return function() {
          return M.apply(null, arguments);
        };
      }, e.captureOwnerStack = function() {
        var M = lt.getCurrentStack;
        return M === null ? null : M();
      }, e.cloneElement = function(M, Y, xe) {
        if (M == null)
          throw Error(
            "The argument must be a React element, but you passed " + M + "."
          );
        var Ee = ld({}, M.props), _e = M.key, ht = M._owner;
        if (Y != null) {
          var tt;
          e: {
            if (fr.call(Y, "ref") && (tt = Object.getOwnPropertyDescriptor(
              Y,
              "ref"
            ).get) && tt.isReactWarning) {
              tt = !1;
              break e;
            }
            tt = Y.ref !== void 0;
          }
          tt && (ht = E()), U(Y) && (S(Y.key), _e = "" + Y.key);
          for (St in Y)
            !fr.call(Y, St) || St === "key" || St === "__self" || St === "__source" || St === "ref" && Y.ref === void 0 || (Ee[St] = Y[St]);
        }
        var St = arguments.length - 2;
        if (St === 1) Ee.children = xe;
        else if (1 < St) {
          tt = Array(St);
          for (var Je = 0; Je < St; Je++)
            tt[Je] = arguments[Je + 2];
          Ee.children = tt;
        }
        for (Ee = ie(
          M.type,
          _e,
          void 0,
          void 0,
          ht,
          Ee,
          M._debugStack,
          M._debugTask
        ), _e = 2; _e < arguments.length; _e++)
          ht = arguments[_e], pe(ht) && ht._store && (ht._store.validated = 1);
        return Ee;
      }, e.createContext = function(M) {
        return M = {
          $$typeof: je,
          _currentValue: M,
          _currentValue2: M,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, M.Provider = M, M.Consumer = {
          $$typeof: Ae,
          _context: M
        }, M._currentRenderer = null, M._currentRenderer2 = null, M;
      }, e.createElement = function(M, Y, xe) {
        for (var Ee = 2; Ee < arguments.length; Ee++) {
          var _e = arguments[Ee];
          pe(_e) && _e._store && (_e._store.validated = 1);
        }
        if (Ee = {}, _e = null, Y != null)
          for (Je in od || !("__self" in Y) || "key" in Y || (od = !0, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), U(Y) && (S(Y.key), _e = "" + Y.key), Y)
            fr.call(Y, Je) && Je !== "key" && Je !== "__self" && Je !== "__source" && (Ee[Je] = Y[Je]);
        var ht = arguments.length - 2;
        if (ht === 1) Ee.children = xe;
        else if (1 < ht) {
          for (var tt = Array(ht), St = 0; St < ht; St++)
            tt[St] = arguments[St + 2];
          Object.freeze && Object.freeze(tt), Ee.children = tt;
        }
        if (M && M.defaultProps)
          for (Je in ht = M.defaultProps, ht)
            Ee[Je] === void 0 && (Ee[Je] = ht[Je]);
        _e && V(
          Ee,
          typeof M == "function" ? M.displayName || M.name || "Unknown" : M
        );
        var Je = 1e4 > lt.recentlyCreatedOwnerStacks++;
        return ie(
          M,
          _e,
          void 0,
          void 0,
          E(),
          Ee,
          Je ? Error("react-stack-top-frame") : ci,
          Je ? hr(w(M)) : El
        );
      }, e.createRef = function() {
        var M = { current: null };
        return Object.seal(M), M;
      }, e.forwardRef = function(M) {
        M != null && M.$$typeof === Ut ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : typeof M != "function" ? console.error(
          "forwardRef requires a render function but was given %s.",
          M === null ? "null" : typeof M
        ) : M.length !== 0 && M.length !== 2 && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          M.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        ), M != null && M.defaultProps != null && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var Y = { $$typeof: Ne, render: M }, xe;
        return Object.defineProperty(Y, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return xe;
          },
          set: function(Ee) {
            xe = Ee, M.name || M.displayName || (Object.defineProperty(M, "name", { value: Ee }), M.displayName = Ee);
          }
        }), Y;
      }, e.isValidElement = pe, e.lazy = function(M) {
        return {
          $$typeof: Rn,
          _payload: { _status: -1, _result: M },
          _init: ze
        };
      }, e.memo = function(M, Y) {
        M == null && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          M === null ? "null" : typeof M
        ), Y = {
          $$typeof: Ut,
          type: M,
          compare: Y === void 0 ? null : Y
        };
        var xe;
        return Object.defineProperty(Y, "displayName", {
          enumerable: !1,
          configurable: !0,
          get: function() {
            return xe;
          },
          set: function(Ee) {
            xe = Ee, M.name || M.displayName || (Object.defineProperty(M, "name", { value: Ee }), M.displayName = Ee);
          }
        }), Y;
      }, e.startTransition = function(M) {
        var Y = lt.T, xe = {};
        lt.T = xe, xe._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var Ee = M(), _e = lt.S;
          _e !== null && _e(xe, Ee), typeof Ee == "object" && Ee !== null && typeof Ee.then == "function" && Ee.then(Qe, bu);
        } catch (ht) {
          bu(ht);
        } finally {
          Y === null && xe._updatedFibers && (M = xe._updatedFibers.size, xe._updatedFibers.clear(), 10 < M && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), lt.T = Y;
        }
      }, e.unstable_useCacheRefresh = function() {
        return fe().useCacheRefresh();
      }, e.use = function(M) {
        return fe().use(M);
      }, e.useActionState = function(M, Y, xe) {
        return fe().useActionState(
          M,
          Y,
          xe
        );
      }, e.useCallback = function(M, Y) {
        return fe().useCallback(M, Y);
      }, e.useContext = function(M) {
        var Y = fe();
        return M.$$typeof === Ae && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        ), Y.useContext(M);
      }, e.useDebugValue = function(M, Y) {
        return fe().useDebugValue(M, Y);
      }, e.useDeferredValue = function(M, Y) {
        return fe().useDeferredValue(M, Y);
      }, e.useEffect = function(M, Y, xe) {
        M == null && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var Ee = fe();
        if (typeof xe == "function")
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return Ee.useEffect(M, Y);
      }, e.useId = function() {
        return fe().useId();
      }, e.useImperativeHandle = function(M, Y, xe) {
        return fe().useImperativeHandle(M, Y, xe);
      }, e.useInsertionEffect = function(M, Y) {
        return M == null && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), fe().useInsertionEffect(M, Y);
      }, e.useLayoutEffect = function(M, Y) {
        return M == null && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        ), fe().useLayoutEffect(M, Y);
      }, e.useMemo = function(M, Y) {
        return fe().useMemo(M, Y);
      }, e.useOptimistic = function(M, Y) {
        return fe().useOptimistic(M, Y);
      }, e.useReducer = function(M, Y, xe) {
        return fe().useReducer(M, Y, xe);
      }, e.useRef = function(M) {
        return fe().useRef(M);
      }, e.useState = function(M) {
        return fe().useState(M);
      }, e.useSyncExternalStore = function(M, Y, xe) {
        return fe().useSyncExternalStore(
          M,
          Y,
          xe
        );
      }, e.useTransition = function() {
        return fe().useTransition();
      }, e.version = "19.1.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(Ky, Ky.exports)), Ky.exports;
}
var LE;
function Xm() {
  if (LE) return wb.exports;
  LE = 1;
  var o = {};
  return o.NODE_ENV === "production" ? wb.exports = A3() : wb.exports = w3(), wb.exports;
}
var Zn = Xm();
const E3 = /* @__PURE__ */ x3(Zn);
var Eb = { exports: {} }, Vy = {}, Cb = { exports: {} }, ST = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VE;
function C3() {
  return VE || (VE = 1, function(o) {
    function e(F, Z) {
      var ge = F.length;
      F.push(Z);
      e: for (; 0 < ge; ) {
        var Se = ge - 1 >>> 1, B = F[Se];
        if (0 < s(B, Z))
          F[Se] = Z, F[ge] = B, ge = Se;
        else break e;
      }
    }
    function n(F) {
      return F.length === 0 ? null : F[0];
    }
    function l(F) {
      if (F.length === 0) return null;
      var Z = F[0], ge = F.pop();
      if (ge !== Z) {
        F[0] = ge;
        e: for (var Se = 0, B = F.length, L = B >>> 1; Se < L; ) {
          var se = 2 * (Se + 1) - 1, le = F[se], Ae = se + 1, je = F[Ae];
          if (0 > s(le, ge))
            Ae < B && 0 > s(je, le) ? (F[Se] = je, F[Ae] = ge, Se = Ae) : (F[Se] = le, F[se] = ge, Se = se);
          else if (Ae < B && 0 > s(je, ge))
            F[Se] = je, F[Ae] = ge, Se = Ae;
          else break e;
        }
      }
      return Z;
    }
    function s(F, Z) {
      var ge = F.sortIndex - Z.sortIndex;
      return ge !== 0 ? ge : F.id - Z.id;
    }
    if (o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var c = performance;
      o.unstable_now = function() {
        return c.now();
      };
    } else {
      var d = Date, m = d.now();
      o.unstable_now = function() {
        return d.now() - m;
      };
    }
    var y = [], b = [], S = 1, A = null, w = 3, E = !1, z = !1, U = !1, V = !1, G = typeof setTimeout == "function" ? setTimeout : null, ie = typeof clearTimeout == "function" ? clearTimeout : null, me = typeof setImmediate < "u" ? setImmediate : null;
    function pe(F) {
      for (var Z = n(b); Z !== null; ) {
        if (Z.callback === null) l(b);
        else if (Z.startTime <= F)
          l(b), Z.sortIndex = Z.expirationTime, e(y, Z);
        else break;
        Z = n(b);
      }
    }
    function ne(F) {
      if (U = !1, pe(F), !z)
        if (n(y) !== null)
          z = !0, ye || (ye = !0, fe());
        else {
          var Z = n(b);
          Z !== null && Xe(ne, Z.startTime - F);
        }
    }
    var ye = !1, Oe = -1, we = 5, Re = -1;
    function Te() {
      return V ? !0 : !(o.unstable_now() - Re < we);
    }
    function ze() {
      if (V = !1, ye) {
        var F = o.unstable_now();
        Re = F;
        var Z = !0;
        try {
          e: {
            z = !1, U && (U = !1, ie(Oe), Oe = -1), E = !0;
            var ge = w;
            try {
              t: {
                for (pe(F), A = n(y); A !== null && !(A.expirationTime > F && Te()); ) {
                  var Se = A.callback;
                  if (typeof Se == "function") {
                    A.callback = null, w = A.priorityLevel;
                    var B = Se(
                      A.expirationTime <= F
                    );
                    if (F = o.unstable_now(), typeof B == "function") {
                      A.callback = B, pe(F), Z = !0;
                      break t;
                    }
                    A === n(y) && l(y), pe(F);
                  } else l(y);
                  A = n(y);
                }
                if (A !== null) Z = !0;
                else {
                  var L = n(b);
                  L !== null && Xe(
                    ne,
                    L.startTime - F
                  ), Z = !1;
                }
              }
              break e;
            } finally {
              A = null, w = ge, E = !1;
            }
            Z = void 0;
          }
        } finally {
          Z ? fe() : ye = !1;
        }
      }
    }
    var fe;
    if (typeof me == "function")
      fe = function() {
        me(ze);
      };
    else if (typeof MessageChannel < "u") {
      var Qe = new MessageChannel(), Ve = Qe.port2;
      Qe.port1.onmessage = ze, fe = function() {
        Ve.postMessage(null);
      };
    } else
      fe = function() {
        G(ze, 0);
      };
    function Xe(F, Z) {
      Oe = G(function() {
        F(o.unstable_now());
      }, Z);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(F) {
      F.callback = null;
    }, o.unstable_forceFrameRate = function(F) {
      0 > F || 125 < F ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : we = 0 < F ? Math.floor(1e3 / F) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return w;
    }, o.unstable_next = function(F) {
      switch (w) {
        case 1:
        case 2:
        case 3:
          var Z = 3;
          break;
        default:
          Z = w;
      }
      var ge = w;
      w = Z;
      try {
        return F();
      } finally {
        w = ge;
      }
    }, o.unstable_requestPaint = function() {
      V = !0;
    }, o.unstable_runWithPriority = function(F, Z) {
      switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          F = 3;
      }
      var ge = w;
      w = F;
      try {
        return Z();
      } finally {
        w = ge;
      }
    }, o.unstable_scheduleCallback = function(F, Z, ge) {
      var Se = o.unstable_now();
      switch (typeof ge == "object" && ge !== null ? (ge = ge.delay, ge = typeof ge == "number" && 0 < ge ? Se + ge : Se) : ge = Se, F) {
        case 1:
          var B = -1;
          break;
        case 2:
          B = 250;
          break;
        case 5:
          B = 1073741823;
          break;
        case 4:
          B = 1e4;
          break;
        default:
          B = 5e3;
      }
      return B = ge + B, F = {
        id: S++,
        callback: Z,
        priorityLevel: F,
        startTime: ge,
        expirationTime: B,
        sortIndex: -1
      }, ge > Se ? (F.sortIndex = ge, e(b, F), n(y) === null && F === n(b) && (U ? (ie(Oe), Oe = -1) : U = !0, Xe(ne, ge - Se))) : (F.sortIndex = B, e(y, F), z || E || (z = !0, ye || (ye = !0, fe()))), F;
    }, o.unstable_shouldYield = Te, o.unstable_wrapCallback = function(F) {
      var Z = w;
      return function() {
        var ge = w;
        w = Z;
        try {
          return F.apply(this, arguments);
        } finally {
          w = ge;
        }
      };
    };
  }(ST)), ST;
}
var TT = {}, XE;
function R3() {
  return XE || (XE = 1, function(o) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      function n() {
        if (ye = !1, Te) {
          var Z = o.unstable_now();
          Qe = Z;
          var ge = !0;
          try {
            e: {
              pe = !1, ne && (ne = !1, we(ze), ze = -1), me = !0;
              var Se = ie;
              try {
                t: {
                  for (m(Z), G = s(z); G !== null && !(G.expirationTime > Z && b()); ) {
                    var B = G.callback;
                    if (typeof B == "function") {
                      G.callback = null, ie = G.priorityLevel;
                      var L = B(
                        G.expirationTime <= Z
                      );
                      if (Z = o.unstable_now(), typeof L == "function") {
                        G.callback = L, m(Z), ge = !0;
                        break t;
                      }
                      G === s(z) && c(z), m(Z);
                    } else c(z);
                    G = s(z);
                  }
                  if (G !== null) ge = !0;
                  else {
                    var se = s(U);
                    se !== null && S(
                      y,
                      se.startTime - Z
                    ), ge = !1;
                  }
                }
                break e;
              } finally {
                G = null, ie = Se, me = !1;
              }
              ge = void 0;
            }
          } finally {
            ge ? Ve() : Te = !1;
          }
        }
      }
      function l(Z, ge) {
        var Se = Z.length;
        Z.push(ge);
        e: for (; 0 < Se; ) {
          var B = Se - 1 >>> 1, L = Z[B];
          if (0 < d(L, ge))
            Z[B] = ge, Z[Se] = L, Se = B;
          else break e;
        }
      }
      function s(Z) {
        return Z.length === 0 ? null : Z[0];
      }
      function c(Z) {
        if (Z.length === 0) return null;
        var ge = Z[0], Se = Z.pop();
        if (Se !== ge) {
          Z[0] = Se;
          e: for (var B = 0, L = Z.length, se = L >>> 1; B < se; ) {
            var le = 2 * (B + 1) - 1, Ae = Z[le], je = le + 1, Ne = Z[je];
            if (0 > d(Ae, Se))
              je < L && 0 > d(Ne, Ae) ? (Z[B] = Ne, Z[je] = Se, B = je) : (Z[B] = Ae, Z[le] = Se, B = le);
            else if (je < L && 0 > d(Ne, Se))
              Z[B] = Ne, Z[je] = Se, B = je;
            else break e;
          }
        }
        return ge;
      }
      function d(Z, ge) {
        var Se = Z.sortIndex - ge.sortIndex;
        return Se !== 0 ? Se : Z.id - ge.id;
      }
      function m(Z) {
        for (var ge = s(U); ge !== null; ) {
          if (ge.callback === null) c(U);
          else if (ge.startTime <= Z)
            c(U), ge.sortIndex = ge.expirationTime, l(z, ge);
          else break;
          ge = s(U);
        }
      }
      function y(Z) {
        if (ne = !1, m(Z), !pe)
          if (s(z) !== null)
            pe = !0, Te || (Te = !0, Ve());
          else {
            var ge = s(U);
            ge !== null && S(
              y,
              ge.startTime - Z
            );
          }
      }
      function b() {
        return ye ? !0 : !(o.unstable_now() - Qe < fe);
      }
      function S(Z, ge) {
        ze = Oe(function() {
          Z(o.unstable_now());
        }, ge);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var A = performance;
        o.unstable_now = function() {
          return A.now();
        };
      } else {
        var w = Date, E = w.now();
        o.unstable_now = function() {
          return w.now() - E;
        };
      }
      var z = [], U = [], V = 1, G = null, ie = 3, me = !1, pe = !1, ne = !1, ye = !1, Oe = typeof setTimeout == "function" ? setTimeout : null, we = typeof clearTimeout == "function" ? clearTimeout : null, Re = typeof setImmediate < "u" ? setImmediate : null, Te = !1, ze = -1, fe = 5, Qe = -1;
      if (typeof Re == "function")
        var Ve = function() {
          Re(n);
        };
      else if (typeof MessageChannel < "u") {
        var Xe = new MessageChannel(), F = Xe.port2;
        Xe.port1.onmessage = n, Ve = function() {
          F.postMessage(null);
        };
      } else
        Ve = function() {
          Oe(n, 0);
        };
      o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(Z) {
        Z.callback = null;
      }, o.unstable_forceFrameRate = function(Z) {
        0 > Z || 125 < Z ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : fe = 0 < Z ? Math.floor(1e3 / Z) : 5;
      }, o.unstable_getCurrentPriorityLevel = function() {
        return ie;
      }, o.unstable_next = function(Z) {
        switch (ie) {
          case 1:
          case 2:
          case 3:
            var ge = 3;
            break;
          default:
            ge = ie;
        }
        var Se = ie;
        ie = ge;
        try {
          return Z();
        } finally {
          ie = Se;
        }
      }, o.unstable_requestPaint = function() {
        ye = !0;
      }, o.unstable_runWithPriority = function(Z, ge) {
        switch (Z) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            Z = 3;
        }
        var Se = ie;
        ie = Z;
        try {
          return ge();
        } finally {
          ie = Se;
        }
      }, o.unstable_scheduleCallback = function(Z, ge, Se) {
        var B = o.unstable_now();
        switch (typeof Se == "object" && Se !== null ? (Se = Se.delay, Se = typeof Se == "number" && 0 < Se ? B + Se : B) : Se = B, Z) {
          case 1:
            var L = -1;
            break;
          case 2:
            L = 250;
            break;
          case 5:
            L = 1073741823;
            break;
          case 4:
            L = 1e4;
            break;
          default:
            L = 5e3;
        }
        return L = Se + L, Z = {
          id: V++,
          callback: ge,
          priorityLevel: Z,
          startTime: Se,
          expirationTime: L,
          sortIndex: -1
        }, Se > B ? (Z.sortIndex = Se, l(U, Z), s(z) === null && Z === s(U) && (ne ? (we(ze), ze = -1) : ne = !0, S(y, Se - B))) : (Z.sortIndex = L, l(z, Z), pe || me || (pe = !0, Te || (Te = !0, Ve()))), Z;
      }, o.unstable_shouldYield = b, o.unstable_wrapCallback = function(Z) {
        var ge = ie;
        return function() {
          var Se = ie;
          ie = ge;
          try {
            return Z.apply(this, arguments);
          } finally {
            ie = Se;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(TT)), TT;
}
var jE;
function ak() {
  if (jE) return Cb.exports;
  jE = 1;
  var o = {};
  return o.NODE_ENV === "production" ? Cb.exports = C3() : Cb.exports = R3(), Cb.exports;
}
var Rb = { exports: {} }, nl = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GE;
function k3() {
  if (GE) return nl;
  GE = 1;
  var o = Xm();
  function e(y) {
    var b = "https://react.dev/errors/" + y;
    if (1 < arguments.length) {
      b += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var S = 2; S < arguments.length; S++)
        b += "&args[]=" + encodeURIComponent(arguments[S]);
    }
    return "Minified React error #" + y + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var l = {
    d: {
      f: n,
      r: function() {
        throw Error(e(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, s = Symbol.for("react.portal");
  function c(y, b, S) {
    var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: s,
      key: A == null ? null : "" + A,
      children: y,
      containerInfo: b,
      implementation: S
    };
  }
  var d = o.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function m(y, b) {
    if (y === "font") return "";
    if (typeof b == "string")
      return b === "use-credentials" ? b : "";
  }
  return nl.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = l, nl.createPortal = function(y, b) {
    var S = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!b || b.nodeType !== 1 && b.nodeType !== 9 && b.nodeType !== 11)
      throw Error(e(299));
    return c(y, b, null, S);
  }, nl.flushSync = function(y) {
    var b = d.T, S = l.p;
    try {
      if (d.T = null, l.p = 2, y) return y();
    } finally {
      d.T = b, l.p = S, l.d.f();
    }
  }, nl.preconnect = function(y, b) {
    typeof y == "string" && (b ? (b = b.crossOrigin, b = typeof b == "string" ? b === "use-credentials" ? b : "" : void 0) : b = null, l.d.C(y, b));
  }, nl.prefetchDNS = function(y) {
    typeof y == "string" && l.d.D(y);
  }, nl.preinit = function(y, b) {
    if (typeof y == "string" && b && typeof b.as == "string") {
      var S = b.as, A = m(S, b.crossOrigin), w = typeof b.integrity == "string" ? b.integrity : void 0, E = typeof b.fetchPriority == "string" ? b.fetchPriority : void 0;
      S === "style" ? l.d.S(
        y,
        typeof b.precedence == "string" ? b.precedence : void 0,
        {
          crossOrigin: A,
          integrity: w,
          fetchPriority: E
        }
      ) : S === "script" && l.d.X(y, {
        crossOrigin: A,
        integrity: w,
        fetchPriority: E,
        nonce: typeof b.nonce == "string" ? b.nonce : void 0
      });
    }
  }, nl.preinitModule = function(y, b) {
    if (typeof y == "string")
      if (typeof b == "object" && b !== null) {
        if (b.as == null || b.as === "script") {
          var S = m(
            b.as,
            b.crossOrigin
          );
          l.d.M(y, {
            crossOrigin: S,
            integrity: typeof b.integrity == "string" ? b.integrity : void 0,
            nonce: typeof b.nonce == "string" ? b.nonce : void 0
          });
        }
      } else b == null && l.d.M(y);
  }, nl.preload = function(y, b) {
    if (typeof y == "string" && typeof b == "object" && b !== null && typeof b.as == "string") {
      var S = b.as, A = m(S, b.crossOrigin);
      l.d.L(y, S, {
        crossOrigin: A,
        integrity: typeof b.integrity == "string" ? b.integrity : void 0,
        nonce: typeof b.nonce == "string" ? b.nonce : void 0,
        type: typeof b.type == "string" ? b.type : void 0,
        fetchPriority: typeof b.fetchPriority == "string" ? b.fetchPriority : void 0,
        referrerPolicy: typeof b.referrerPolicy == "string" ? b.referrerPolicy : void 0,
        imageSrcSet: typeof b.imageSrcSet == "string" ? b.imageSrcSet : void 0,
        imageSizes: typeof b.imageSizes == "string" ? b.imageSizes : void 0,
        media: typeof b.media == "string" ? b.media : void 0
      });
    }
  }, nl.preloadModule = function(y, b) {
    if (typeof y == "string")
      if (b) {
        var S = m(b.as, b.crossOrigin);
        l.d.m(y, {
          as: typeof b.as == "string" && b.as !== "script" ? b.as : void 0,
          crossOrigin: S,
          integrity: typeof b.integrity == "string" ? b.integrity : void 0
        });
      } else l.d.m(y);
  }, nl.requestFormReset = function(y) {
    l.d.r(y);
  }, nl.unstable_batchedUpdates = function(y, b) {
    return y(b);
  }, nl.useFormState = function(y, b, S) {
    return d.H.useFormState(y, b, S);
  }, nl.useFormStatus = function() {
    return d.H.useHostTransitionStatus();
  }, nl.version = "19.1.0", nl;
}
var il = {}, YE;
function D3() {
  if (YE) return il;
  YE = 1;
  var o = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return o.NODE_ENV !== "production" && function() {
    function e() {
    }
    function n(w) {
      return "" + w;
    }
    function l(w, E, z) {
      var U = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        n(U);
        var V = !1;
      } catch {
        V = !0;
      }
      return V && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        typeof Symbol == "function" && Symbol.toStringTag && U[Symbol.toStringTag] || U.constructor.name || "Object"
      ), n(U)), {
        $$typeof: S,
        key: U == null ? null : "" + U,
        children: w,
        containerInfo: E,
        implementation: z
      };
    }
    function s(w, E) {
      if (w === "font") return "";
      if (typeof E == "string")
        return E === "use-credentials" ? E : "";
    }
    function c(w) {
      return w === null ? "`null`" : w === void 0 ? "`undefined`" : w === "" ? "an empty string" : 'something with type "' + typeof w + '"';
    }
    function d(w) {
      return w === null ? "`null`" : w === void 0 ? "`undefined`" : w === "" ? "an empty string" : typeof w == "string" ? JSON.stringify(w) : typeof w == "number" ? "`" + w + "`" : 'something with type "' + typeof w + '"';
    }
    function m() {
      var w = A.H;
      return w === null && console.error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      ), w;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var y = Xm(), b = {
      d: {
        f: e,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: e,
        C: e,
        L: e,
        m: e,
        X: e,
        S: e,
        M: e
      },
      p: 0,
      findDOMNode: null
    }, S = Symbol.for("react.portal"), A = y.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    ), il.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = b, il.createPortal = function(w, E) {
      var z = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!E || E.nodeType !== 1 && E.nodeType !== 9 && E.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return l(w, E, null, z);
    }, il.flushSync = function(w) {
      var E = A.T, z = b.p;
      try {
        if (A.T = null, b.p = 2, w)
          return w();
      } finally {
        A.T = E, b.p = z, b.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    }, il.preconnect = function(w, E) {
      typeof w == "string" && w ? E != null && typeof E != "object" ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        d(E)
      ) : E != null && typeof E.crossOrigin != "string" && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        c(E.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        c(w)
      ), typeof w == "string" && (E ? (E = E.crossOrigin, E = typeof E == "string" ? E === "use-credentials" ? E : "" : void 0) : E = null, b.d.C(w, E));
    }, il.prefetchDNS = function(w) {
      if (typeof w != "string" || !w)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          c(w)
        );
      else if (1 < arguments.length) {
        var E = arguments[1];
        typeof E == "object" && E.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          d(E)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          d(E)
        );
      }
      typeof w == "string" && b.d.D(w);
    }, il.preinit = function(w, E) {
      if (typeof w == "string" && w ? E == null || typeof E != "object" ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        d(E)
      ) : E.as !== "style" && E.as !== "script" && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        d(E.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        c(w)
      ), typeof w == "string" && E && typeof E.as == "string") {
        var z = E.as, U = s(z, E.crossOrigin), V = typeof E.integrity == "string" ? E.integrity : void 0, G = typeof E.fetchPriority == "string" ? E.fetchPriority : void 0;
        z === "style" ? b.d.S(
          w,
          typeof E.precedence == "string" ? E.precedence : void 0,
          {
            crossOrigin: U,
            integrity: V,
            fetchPriority: G
          }
        ) : z === "script" && b.d.X(w, {
          crossOrigin: U,
          integrity: V,
          fetchPriority: G,
          nonce: typeof E.nonce == "string" ? E.nonce : void 0
        });
      }
    }, il.preinitModule = function(w, E) {
      var z = "";
      if (typeof w == "string" && w || (z += " The `href` argument encountered was " + c(w) + "."), E !== void 0 && typeof E != "object" ? z += " The `options` argument encountered was " + c(E) + "." : E && "as" in E && E.as !== "script" && (z += " The `as` option encountered was " + d(E.as) + "."), z)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          z
        );
      else
        switch (z = E && typeof E.as == "string" ? E.as : "script", z) {
          case "script":
            break;
          default:
            z = d(z), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              z,
              w
            );
        }
      typeof w == "string" && (typeof E == "object" && E !== null ? (E.as == null || E.as === "script") && (z = s(
        E.as,
        E.crossOrigin
      ), b.d.M(w, {
        crossOrigin: z,
        integrity: typeof E.integrity == "string" ? E.integrity : void 0,
        nonce: typeof E.nonce == "string" ? E.nonce : void 0
      })) : E == null && b.d.M(w));
    }, il.preload = function(w, E) {
      var z = "";
      if (typeof w == "string" && w || (z += " The `href` argument encountered was " + c(w) + "."), E == null || typeof E != "object" ? z += " The `options` argument encountered was " + c(E) + "." : typeof E.as == "string" && E.as || (z += " The `as` option encountered was " + c(E.as) + "."), z && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        z
      ), typeof w == "string" && typeof E == "object" && E !== null && typeof E.as == "string") {
        z = E.as;
        var U = s(
          z,
          E.crossOrigin
        );
        b.d.L(w, z, {
          crossOrigin: U,
          integrity: typeof E.integrity == "string" ? E.integrity : void 0,
          nonce: typeof E.nonce == "string" ? E.nonce : void 0,
          type: typeof E.type == "string" ? E.type : void 0,
          fetchPriority: typeof E.fetchPriority == "string" ? E.fetchPriority : void 0,
          referrerPolicy: typeof E.referrerPolicy == "string" ? E.referrerPolicy : void 0,
          imageSrcSet: typeof E.imageSrcSet == "string" ? E.imageSrcSet : void 0,
          imageSizes: typeof E.imageSizes == "string" ? E.imageSizes : void 0,
          media: typeof E.media == "string" ? E.media : void 0
        });
      }
    }, il.preloadModule = function(w, E) {
      var z = "";
      typeof w == "string" && w || (z += " The `href` argument encountered was " + c(w) + "."), E !== void 0 && typeof E != "object" ? z += " The `options` argument encountered was " + c(E) + "." : E && "as" in E && typeof E.as != "string" && (z += " The `as` option encountered was " + c(E.as) + "."), z && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        z
      ), typeof w == "string" && (E ? (z = s(
        E.as,
        E.crossOrigin
      ), b.d.m(w, {
        as: typeof E.as == "string" && E.as !== "script" ? E.as : void 0,
        crossOrigin: z,
        integrity: typeof E.integrity == "string" ? E.integrity : void 0
      })) : b.d.m(w));
    }, il.requestFormReset = function(w) {
      b.d.r(w);
    }, il.unstable_batchedUpdates = function(w, E) {
      return w(E);
    }, il.useFormState = function(w, E, z) {
      return m().useFormState(w, E, z);
    }, il.useFormStatus = function() {
      return m().useHostTransitionStatus();
    }, il.version = "19.1.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }(), il;
}
var $E;
function ok() {
  if ($E) return Rb.exports;
  $E = 1;
  var o = {};
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (o.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (n) {
        console.error(n);
      }
    }
  }
  return o.NODE_ENV === "production" ? (e(), Rb.exports = k3()) : Rb.exports = D3(), Rb.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZE;
function M3() {
  if (ZE) return Vy;
  ZE = 1;
  var o = ak(), e = Xm(), n = ok();
  function l(a) {
    var u = "https://react.dev/errors/" + a;
    if (1 < arguments.length) {
      u += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var f = 2; f < arguments.length; f++)
        u += "&args[]=" + encodeURIComponent(arguments[f]);
    }
    return "Minified React error #" + a + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function s(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function c(a) {
    var u = a, f = a;
    if (a.alternate) for (; u.return; ) u = u.return;
    else {
      a = u;
      do
        u = a, (u.flags & 4098) !== 0 && (f = u.return), a = u.return;
      while (a);
    }
    return u.tag === 3 ? f : null;
  }
  function d(a) {
    if (a.tag === 13) {
      var u = a.memoizedState;
      if (u === null && (a = a.alternate, a !== null && (u = a.memoizedState)), u !== null) return u.dehydrated;
    }
    return null;
  }
  function m(a) {
    if (c(a) !== a)
      throw Error(l(188));
  }
  function y(a) {
    var u = a.alternate;
    if (!u) {
      if (u = c(a), u === null) throw Error(l(188));
      return u !== a ? null : a;
    }
    for (var f = a, p = u; ; ) {
      var v = f.return;
      if (v === null) break;
      var T = v.alternate;
      if (T === null) {
        if (p = v.return, p !== null) {
          f = p;
          continue;
        }
        break;
      }
      if (v.child === T.child) {
        for (T = v.child; T; ) {
          if (T === f) return m(v), a;
          if (T === p) return m(v), u;
          T = T.sibling;
        }
        throw Error(l(188));
      }
      if (f.return !== p.return) f = v, p = T;
      else {
        for (var k = !1, D = v.child; D; ) {
          if (D === f) {
            k = !0, f = v, p = T;
            break;
          }
          if (D === p) {
            k = !0, p = v, f = T;
            break;
          }
          D = D.sibling;
        }
        if (!k) {
          for (D = T.child; D; ) {
            if (D === f) {
              k = !0, f = T, p = v;
              break;
            }
            if (D === p) {
              k = !0, p = T, f = v;
              break;
            }
            D = D.sibling;
          }
          if (!k) throw Error(l(189));
        }
      }
      if (f.alternate !== p) throw Error(l(190));
    }
    if (f.tag !== 3) throw Error(l(188));
    return f.stateNode.current === f ? a : u;
  }
  function b(a) {
    var u = a.tag;
    if (u === 5 || u === 26 || u === 27 || u === 6) return a;
    for (a = a.child; a !== null; ) {
      if (u = b(a), u !== null) return u;
      a = a.sibling;
    }
    return null;
  }
  var S = Object.assign, A = Symbol.for("react.element"), w = Symbol.for("react.transitional.element"), E = Symbol.for("react.portal"), z = Symbol.for("react.fragment"), U = Symbol.for("react.strict_mode"), V = Symbol.for("react.profiler"), G = Symbol.for("react.provider"), ie = Symbol.for("react.consumer"), me = Symbol.for("react.context"), pe = Symbol.for("react.forward_ref"), ne = Symbol.for("react.suspense"), ye = Symbol.for("react.suspense_list"), Oe = Symbol.for("react.memo"), we = Symbol.for("react.lazy"), Re = Symbol.for("react.activity"), Te = Symbol.for("react.memo_cache_sentinel"), ze = Symbol.iterator;
  function fe(a) {
    return a === null || typeof a != "object" ? null : (a = ze && a[ze] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var Qe = Symbol.for("react.client.reference");
  function Ve(a) {
    if (a == null) return null;
    if (typeof a == "function")
      return a.$$typeof === Qe ? null : a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case z:
        return "Fragment";
      case V:
        return "Profiler";
      case U:
        return "StrictMode";
      case ne:
        return "Suspense";
      case ye:
        return "SuspenseList";
      case Re:
        return "Activity";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case E:
          return "Portal";
        case me:
          return (a.displayName || "Context") + ".Provider";
        case ie:
          return (a._context.displayName || "Context") + ".Consumer";
        case pe:
          var u = a.render;
          return a = a.displayName, a || (a = u.displayName || u.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case Oe:
          return u = a.displayName || null, u !== null ? u : Ve(a.type) || "Memo";
        case we:
          u = a._payload, a = a._init;
          try {
            return Ve(a(u));
          } catch {
          }
      }
    return null;
  }
  var Xe = Array.isArray, F = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Z = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ge = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Se = [], B = -1;
  function L(a) {
    return { current: a };
  }
  function se(a) {
    0 > B || (a.current = Se[B], Se[B] = null, B--);
  }
  function le(a, u) {
    B++, Se[B] = a.current, a.current = u;
  }
  var Ae = L(null), je = L(null), Ne = L(null), Ke = L(null);
  function Nt(a, u) {
    switch (le(Ne, u), le(je, a), le(Ae, null), u.nodeType) {
      case 9:
      case 11:
        a = (a = u.documentElement) && (a = a.namespaceURI) ? Va(a) : 0;
        break;
      default:
        if (a = u.tagName, u = u.namespaceURI)
          u = Va(u), a = Go(u, a);
        else
          switch (a) {
            case "svg":
              a = 1;
              break;
            case "math":
              a = 2;
              break;
            default:
              a = 0;
          }
    }
    se(Ae), le(Ae, a);
  }
  function Ut() {
    se(Ae), se(je), se(Ne);
  }
  function Rn(a) {
    a.memoizedState !== null && le(Ke, a);
    var u = Ae.current, f = Go(u, a.type);
    u !== f && (le(je, a), le(Ae, f));
  }
  function Ti(a) {
    je.current === a && (se(Ae), se(je)), Ke.current === a && (se(Ke), li._currentValue = ge);
  }
  var ho = Object.prototype.hasOwnProperty, cr = o.unstable_scheduleCallback, Da = o.unstable_cancelCallback, ld = o.unstable_shouldYield, af = o.unstable_requestPaint, _t = o.unstable_now, po = o.unstable_getCurrentPriorityLevel, mo = o.unstable_ImmediatePriority, ad = o.unstable_UserBlockingPriority, lt = o.unstable_NormalPriority, fr = o.unstable_LowPriority, hr = o.unstable_IdlePriority, as = o.log, od = o.unstable_setDisableYieldValue, go = null, ci = null;
  function El(a) {
    if (typeof as == "function" && od(a), ci && typeof ci.setStrictMode == "function")
      try {
        ci.setStrictMode(go, a);
      } catch {
      }
  }
  var Fn = Math.clz32 ? Math.clz32 : sf, of = Math.log, bu = Math.LN2;
  function sf(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (of(a) / bu | 0) | 0;
  }
  var yo = 256, Kl = 4194304;
  function Kn(a) {
    var u = a & 42;
    if (u !== 0) return u;
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return a & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return a;
    }
  }
  function Ui(a, u, f) {
    var p = a.pendingLanes;
    if (p === 0) return 0;
    var v = 0, T = a.suspendedLanes, k = a.pingedLanes;
    a = a.warmLanes;
    var D = p & 134217727;
    return D !== 0 ? (p = D & ~T, p !== 0 ? v = Kn(p) : (k &= D, k !== 0 ? v = Kn(k) : f || (f = D & ~a, f !== 0 && (v = Kn(f))))) : (D = p & ~T, D !== 0 ? v = Kn(D) : k !== 0 ? v = Kn(k) : f || (f = p & ~a, f !== 0 && (v = Kn(f)))), v === 0 ? 0 : u !== 0 && u !== v && (u & T) === 0 && (T = v & -v, f = u & -u, T >= f || T === 32 && (f & 4194048) !== 0) ? u : v;
  }
  function Cl(a, u) {
    return (a.pendingLanes & ~(a.suspendedLanes & ~a.pingedLanes) & u) === 0;
  }
  function M(a, u) {
    switch (a) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return u + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Y() {
    var a = yo;
    return yo <<= 1, (yo & 4194048) === 0 && (yo = 256), a;
  }
  function xe() {
    var a = Kl;
    return Kl <<= 1, (Kl & 62914560) === 0 && (Kl = 4194304), a;
  }
  function Ee(a) {
    for (var u = [], f = 0; 31 > f; f++) u.push(a);
    return u;
  }
  function _e(a, u) {
    a.pendingLanes |= u, u !== 268435456 && (a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0);
  }
  function ht(a, u, f, p, v, T) {
    var k = a.pendingLanes;
    a.pendingLanes = f, a.suspendedLanes = 0, a.pingedLanes = 0, a.warmLanes = 0, a.expiredLanes &= f, a.entangledLanes &= f, a.errorRecoveryDisabledLanes &= f, a.shellSuspendCounter = 0;
    var D = a.entanglements, q = a.expirationTimes, P = a.hiddenUpdates;
    for (f = k & ~f; 0 < f; ) {
      var ce = 31 - Fn(f), de = 1 << ce;
      D[ce] = 0, q[ce] = -1;
      var K = P[ce];
      if (K !== null)
        for (P[ce] = null, ce = 0; ce < K.length; ce++) {
          var te = K[ce];
          te !== null && (te.lane &= -536870913);
        }
      f &= ~de;
    }
    p !== 0 && tt(a, p, 0), T !== 0 && v === 0 && a.tag !== 0 && (a.suspendedLanes |= T & ~(k & ~u));
  }
  function tt(a, u, f) {
    a.pendingLanes |= u, a.suspendedLanes &= ~u;
    var p = 31 - Fn(u);
    a.entangledLanes |= u, a.entanglements[p] = a.entanglements[p] | 1073741824 | f & 4194090;
  }
  function St(a, u) {
    var f = a.entangledLanes |= u;
    for (a = a.entanglements; f; ) {
      var p = 31 - Fn(f), v = 1 << p;
      v & u | a[p] & u && (a[p] |= u), f &= ~v;
    }
  }
  function Je(a) {
    switch (a) {
      case 2:
        a = 1;
        break;
      case 8:
        a = 4;
        break;
      case 32:
        a = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        a = 128;
        break;
      case 268435456:
        a = 134217728;
        break;
      default:
        a = 0;
    }
    return a;
  }
  function Sn(a) {
    return a &= -a, 2 < a ? 8 < a ? (a & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Ma() {
    var a = Z.p;
    return a !== 0 ? a : (a = window.event, a === void 0 ? 32 : Vv(a.type));
  }
  function Pm(a, u) {
    var f = Z.p;
    try {
      return Z.p = a, u();
    } finally {
      Z.p = f;
    }
  }
  var za = Math.random().toString(36).slice(2), $t = "__reactFiber$" + za, fi = "__reactProps$" + za, dr = "__reactContainer$" + za, Wm = "__reactEvents$" + za, BO = "__reactListeners$" + za, qO = "__reactHandles$" + za, rf = "__reactResources$" + za, uf = "__reactMarker$" + za;
  function Ge(a) {
    delete a[$t], delete a[fi], delete a[Wm], delete a[BO], delete a[qO];
  }
  function os(a) {
    var u = a[$t];
    if (u) return u;
    for (var f = a.parentNode; f; ) {
      if (u = f[dr] || f[$t]) {
        if (f = u.alternate, u.child !== null || f !== null && f.child !== null)
          for (a = Fr(a); a !== null; ) {
            if (f = a[$t]) return f;
            a = Fr(a);
          }
        return u;
      }
      a = f, f = a.parentNode;
    }
    return null;
  }
  function Jn(a) {
    if (a = a[$t] || a[dr]) {
      var u = a.tag;
      if (u === 5 || u === 6 || u === 13 || u === 26 || u === 27 || u === 3)
        return a;
    }
    return null;
  }
  function Su(a) {
    var u = a.tag;
    if (u === 5 || u === 26 || u === 27 || u === 6) return a.stateNode;
    throw Error(l(33));
  }
  function Tu(a) {
    var u = a[rf];
    return u || (u = a[rf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), u;
  }
  function On(a) {
    a[uf] = !0;
  }
  var Fm = /* @__PURE__ */ new Set(), cf = {};
  function qn(a, u) {
    pr(a, u), pr(a + "Capture", u);
  }
  function pr(a, u) {
    for (cf[a] = u, a = 0; a < u.length; a++)
      Fm.add(u[a]);
  }
  var Km = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Jm = {}, sd = {};
  function _O(a) {
    return ho.call(sd, a) ? !0 : ho.call(Jm, a) ? !1 : Km.test(a) ? sd[a] = !0 : (Jm[a] = !0, !1);
  }
  function ff(a, u, f) {
    if (_O(u))
      if (f === null) a.removeAttribute(u);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
            a.removeAttribute(u);
            return;
          case "boolean":
            var p = u.toLowerCase().slice(0, 5);
            if (p !== "data-" && p !== "aria-") {
              a.removeAttribute(u);
              return;
            }
        }
        a.setAttribute(u, "" + f);
      }
  }
  function Oo(a, u, f) {
    if (f === null) a.removeAttribute(u);
    else {
      switch (typeof f) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(u);
          return;
      }
      a.setAttribute(u, "" + f);
    }
  }
  function Qa(a, u, f, p) {
    if (p === null) a.removeAttribute(f);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          a.removeAttribute(f);
          return;
      }
      a.setAttributeNS(u, f, "" + p);
    }
  }
  var rd, Im;
  function mr(a) {
    if (rd === void 0)
      try {
        throw Error();
      } catch (f) {
        var u = f.stack.trim().match(/\n( *(at )?)/);
        rd = u && u[1] || "", Im = -1 < f.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < f.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + rd + a + Im;
  }
  var ud = !1;
  function xi(a, u) {
    if (!a || ud) return "";
    ud = !0;
    var f = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var p = {
        DetermineComponentFrameRoot: function() {
          try {
            if (u) {
              var de = function() {
                throw Error();
              };
              if (Object.defineProperty(de.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(de, []);
                } catch (te) {
                  var K = te;
                }
                Reflect.construct(a, [], de);
              } else {
                try {
                  de.call();
                } catch (te) {
                  K = te;
                }
                a.call(de.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (te) {
                K = te;
              }
              (de = a()) && typeof de.catch == "function" && de.catch(function() {
              });
            }
          } catch (te) {
            if (te && K && typeof te.stack == "string")
              return [te.stack, K.stack];
          }
          return [null, null];
        }
      };
      p.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var v = Object.getOwnPropertyDescriptor(
        p.DetermineComponentFrameRoot,
        "name"
      );
      v && v.configurable && Object.defineProperty(
        p.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var T = p.DetermineComponentFrameRoot(), k = T[0], D = T[1];
      if (k && D) {
        var q = k.split(`
`), P = D.split(`
`);
        for (v = p = 0; p < q.length && !q[p].includes("DetermineComponentFrameRoot"); )
          p++;
        for (; v < P.length && !P[v].includes(
          "DetermineComponentFrameRoot"
        ); )
          v++;
        if (p === q.length || v === P.length)
          for (p = q.length - 1, v = P.length - 1; 1 <= p && 0 <= v && q[p] !== P[v]; )
            v--;
        for (; 1 <= p && 0 <= v; p--, v--)
          if (q[p] !== P[v]) {
            if (p !== 1 || v !== 1)
              do
                if (p--, v--, 0 > v || q[p] !== P[v]) {
                  var ce = `
` + q[p].replace(" at new ", " at ");
                  return a.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", a.displayName)), ce;
                }
              while (1 <= p && 0 <= v);
            break;
          }
      }
    } finally {
      ud = !1, Error.prepareStackTrace = f;
    }
    return (f = a ? a.displayName || a.name : "") ? mr(f) : "";
  }
  function xu(a) {
    switch (a.tag) {
      case 26:
      case 27:
      case 5:
        return mr(a.type);
      case 16:
        return mr("Lazy");
      case 13:
        return mr("Suspense");
      case 19:
        return mr("SuspenseList");
      case 0:
      case 15:
        return xi(a.type, !1);
      case 11:
        return xi(a.type.render, !1);
      case 1:
        return xi(a.type, !0);
      case 31:
        return mr("Activity");
      default:
        return "";
    }
  }
  function ss(a) {
    try {
      var u = "";
      do
        u += xu(a), a = a.return;
      while (a);
      return u;
    } catch (f) {
      return `
Error generating stack: ` + f.message + `
` + f.stack;
    }
  }
  function rl(a) {
    switch (typeof a) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Au(a) {
    var u = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (u === "checkbox" || u === "radio");
  }
  function cd(a) {
    var u = Au(a) ? "checked" : "value", f = Object.getOwnPropertyDescriptor(
      a.constructor.prototype,
      u
    ), p = "" + a[u];
    if (!a.hasOwnProperty(u) && typeof f < "u" && typeof f.get == "function" && typeof f.set == "function") {
      var v = f.get, T = f.set;
      return Object.defineProperty(a, u, {
        configurable: !0,
        get: function() {
          return v.call(this);
        },
        set: function(k) {
          p = "" + k, T.call(this, k);
        }
      }), Object.defineProperty(a, u, {
        enumerable: f.enumerable
      }), {
        getValue: function() {
          return p;
        },
        setValue: function(k) {
          p = "" + k;
        },
        stopTracking: function() {
          a._valueTracker = null, delete a[u];
        }
      };
    }
  }
  function wu(a) {
    a._valueTracker || (a._valueTracker = cd(a));
  }
  function Eu(a) {
    if (!a) return !1;
    var u = a._valueTracker;
    if (!u) return !0;
    var f = u.getValue(), p = "";
    return a && (p = Au(a) ? a.checked ? "true" : "false" : a.value), a = p, a !== f ? (u.setValue(a), !0) : !1;
  }
  function vo(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u") return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  var eg = /[\n"\\]/g;
  function Rl(a) {
    return a.replace(
      eg,
      function(u) {
        return "\\" + u.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function tg(a, u, f, p, v, T, k, D) {
    a.name = "", k != null && typeof k != "function" && typeof k != "symbol" && typeof k != "boolean" ? a.type = k : a.removeAttribute("type"), u != null ? k === "number" ? (u === 0 && a.value === "" || a.value != u) && (a.value = "" + rl(u)) : a.value !== "" + rl(u) && (a.value = "" + rl(u)) : k !== "submit" && k !== "reset" || a.removeAttribute("value"), u != null ? hf(a, k, rl(u)) : f != null ? hf(a, k, rl(f)) : p != null && a.removeAttribute("value"), v == null && T != null && (a.defaultChecked = !!T), v != null && (a.checked = v && typeof v != "function" && typeof v != "symbol"), D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? a.name = "" + rl(D) : a.removeAttribute("name");
  }
  function ng(a, u, f, p, v, T, k, D) {
    if (T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (a.type = T), u != null || f != null) {
      if (!(T !== "submit" && T !== "reset" || u != null))
        return;
      f = f != null ? "" + rl(f) : "", u = u != null ? "" + rl(u) : f, D || u === a.value || (a.value = u), a.defaultValue = u;
    }
    p = p ?? v, p = typeof p != "function" && typeof p != "symbol" && !!p, a.checked = D ? a.checked : !!p, a.defaultChecked = !!p, k != null && typeof k != "function" && typeof k != "symbol" && typeof k != "boolean" && (a.name = k);
  }
  function hf(a, u, f) {
    u === "number" && vo(a.ownerDocument) === a || a.defaultValue === "" + f || (a.defaultValue = "" + f);
  }
  function rs(a, u, f, p) {
    if (a = a.options, u) {
      u = {};
      for (var v = 0; v < f.length; v++)
        u["$" + f[v]] = !0;
      for (f = 0; f < a.length; f++)
        v = u.hasOwnProperty("$" + a[f].value), a[f].selected !== v && (a[f].selected = v), v && p && (a[f].defaultSelected = !0);
    } else {
      for (f = "" + rl(f), u = null, v = 0; v < a.length; v++) {
        if (a[v].value === f) {
          a[v].selected = !0, p && (a[v].defaultSelected = !0);
          return;
        }
        u !== null || a[v].disabled || (u = a[v]);
      }
      u !== null && (u.selected = !0);
    }
  }
  function ig(a, u, f) {
    if (u != null && (u = "" + rl(u), u !== a.value && (a.value = u), f == null)) {
      a.defaultValue !== u && (a.defaultValue = u);
      return;
    }
    a.defaultValue = f != null ? "" + rl(f) : "";
  }
  function lg(a, u, f, p) {
    if (u == null) {
      if (p != null) {
        if (f != null) throw Error(l(92));
        if (Xe(p)) {
          if (1 < p.length) throw Error(l(93));
          p = p[0];
        }
        f = p;
      }
      f == null && (f = ""), u = f;
    }
    f = rl(u), a.defaultValue = f, p = a.textContent, p === f && p !== "" && p !== null && (a.value = p);
  }
  function gr(a, u) {
    if (u) {
      var f = a.firstChild;
      if (f && f === a.lastChild && f.nodeType === 3) {
        f.nodeValue = u;
        return;
      }
    }
    a.textContent = u;
  }
  var tS = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function ag(a, u, f) {
    var p = u.indexOf("--") === 0;
    f == null || typeof f == "boolean" || f === "" ? p ? a.setProperty(u, "") : u === "float" ? a.cssFloat = "" : a[u] = "" : p ? a.setProperty(u, f) : typeof f != "number" || f === 0 || tS.has(u) ? u === "float" ? a.cssFloat = f : a[u] = ("" + f).trim() : a[u] = f + "px";
  }
  function fd(a, u, f) {
    if (u != null && typeof u != "object")
      throw Error(l(62));
    if (a = a.style, f != null) {
      for (var p in f)
        !f.hasOwnProperty(p) || u != null && u.hasOwnProperty(p) || (p.indexOf("--") === 0 ? a.setProperty(p, "") : p === "float" ? a.cssFloat = "" : a[p] = "");
      for (var v in u)
        p = u[v], u.hasOwnProperty(v) && f[v] !== p && ag(a, v, p);
    } else
      for (var T in u)
        u.hasOwnProperty(T) && ag(a, T, u[T]);
  }
  function Cu(a) {
    if (a.indexOf("-") === -1) return !1;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var df = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), nS = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function pf(a) {
    return nS.test("" + a) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : a;
  }
  var hd = null;
  function yr(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var Or = null, Ru = null;
  function HO(a) {
    var u = Jn(a);
    if (u && (a = u.stateNode)) {
      var f = a[fi] || null;
      e: switch (a = u.stateNode, u.type) {
        case "input":
          if (tg(
            a,
            f.value,
            f.defaultValue,
            f.defaultValue,
            f.checked,
            f.defaultChecked,
            f.type,
            f.name
          ), u = f.name, f.type === "radio" && u != null) {
            for (f = a; f.parentNode; ) f = f.parentNode;
            for (f = f.querySelectorAll(
              'input[name="' + Rl(
                "" + u
              ) + '"][type="radio"]'
            ), u = 0; u < f.length; u++) {
              var p = f[u];
              if (p !== a && p.form === a.form) {
                var v = p[fi] || null;
                if (!v) throw Error(l(90));
                tg(
                  p,
                  v.value,
                  v.defaultValue,
                  v.defaultValue,
                  v.checked,
                  v.defaultChecked,
                  v.type,
                  v.name
                );
              }
            }
            for (u = 0; u < f.length; u++)
              p = f[u], p.form === a.form && Eu(p);
          }
          break e;
        case "textarea":
          ig(a, f.value, f.defaultValue);
          break e;
        case "select":
          u = f.value, u != null && rs(a, !!f.multiple, u, !1);
      }
    }
  }
  var og = !1;
  function LO(a, u, f) {
    if (og) return a(u, f);
    og = !0;
    try {
      var p = a(u);
      return p;
    } finally {
      if (og = !1, (Or !== null || Ru !== null) && (ah(), Or && (u = Or, a = Ru, Ru = Or = null, HO(u), a)))
        for (u = 0; u < a.length; u++) HO(a[u]);
    }
  }
  function bo(a, u) {
    var f = a.stateNode;
    if (f === null) return null;
    var p = f[fi] || null;
    if (p === null) return null;
    f = p[u];
    e: switch (u) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (p = !p.disabled) || (a = a.type, p = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !p;
        break e;
      default:
        a = !1;
    }
    if (a) return null;
    if (f && typeof f != "function")
      throw Error(
        l(231, u, typeof f)
      );
    return f;
  }
  var Jl = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), dd = !1;
  if (Jl)
    try {
      var ku = {};
      Object.defineProperty(ku, "passive", {
        get: function() {
          dd = !0;
        }
      }), window.addEventListener("test", ku, ku), window.removeEventListener("test", ku, ku);
    } catch {
      dd = !1;
    }
  var kl = null, pd = null, vr = null;
  function mf() {
    if (vr) return vr;
    var a, u = pd, f = u.length, p, v = "value" in kl ? kl.value : kl.textContent, T = v.length;
    for (a = 0; a < f && u[a] === v[a]; a++) ;
    var k = f - a;
    for (p = 1; p <= k && u[f - p] === v[T - p]; p++) ;
    return vr = v.slice(a, 1 < p ? 1 - p : void 0);
  }
  function gf(a) {
    var u = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && u === 13 && (a = 13)) : a = u, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function In() {
    return !0;
  }
  function VO() {
    return !1;
  }
  function hi(a) {
    function u(f, p, v, T, k) {
      this._reactName = f, this._targetInst = v, this.type = p, this.nativeEvent = T, this.target = k, this.currentTarget = null;
      for (var D in a)
        a.hasOwnProperty(D) && (f = a[D], this[D] = f ? f(T) : T[D]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? In : VO, this.isPropagationStopped = VO, this;
    }
    return S(u.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var f = this.nativeEvent;
        f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1), this.isDefaultPrevented = In);
      },
      stopPropagation: function() {
        var f = this.nativeEvent;
        f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0), this.isPropagationStopped = In);
      },
      persist: function() {
      },
      isPersistent: In
    }), u;
  }
  var us = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, yf = hi(us), Of = S({}, us, { view: 0, detail: 0 }), iS = hi(Of), md, sg, Du, gd = S({}, Of, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: yd,
    button: 0,
    buttons: 0,
    relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function(a) {
      return "movementX" in a ? a.movementX : (a !== Du && (Du && a.type === "mousemove" ? (md = a.screenX - Du.screenX, sg = a.screenY - Du.screenY) : sg = md = 0, Du = a), md);
    },
    movementY: function(a) {
      return "movementY" in a ? a.movementY : sg;
    }
  }), vf = hi(gd), XO = S({}, gd, { dataTransfer: 0 }), jO = hi(XO), GO = S({}, Of, { relatedTarget: 0 }), rg = hi(GO), lS = S({}, us, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), aS = hi(lS), oS = S({}, us, {
    clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }), sS = hi(oS), bf = S({}, us, { data: 0 }), ug = hi(bf), YO = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, $O = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ZO = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function cg(a) {
    var u = this.nativeEvent;
    return u.getModifierState ? u.getModifierState(a) : (a = ZO[a]) ? !!u[a] : !1;
  }
  function yd() {
    return cg;
  }
  var br = S({}, Of, {
    key: function(a) {
      if (a.key) {
        var u = YO[a.key] || a.key;
        if (u !== "Unidentified") return u;
      }
      return a.type === "keypress" ? (a = gf(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? $O[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: yd,
    charCode: function(a) {
      return a.type === "keypress" ? gf(a) : 0;
    },
    keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    },
    which: function(a) {
      return a.type === "keypress" ? gf(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }
  }), Sr = hi(br), Il = S({}, gd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Bi = hi(Il), Od = S({}, Of, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: yd
  }), vd = hi(Od), fg = S({}, us, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), qi = hi(fg), PO = S({}, gd, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), bd = hi(PO), Tr = S({}, us, {
    newState: 0,
    oldState: 0
  }), hg = hi(Tr), WO = [9, 13, 27, 32], Sd = Jl && "CompositionEvent" in window, xr = null;
  Jl && "documentMode" in document && (xr = document.documentMode);
  var rS = Jl && "TextEvent" in window && !xr, Td = Jl && (!Sd || xr && 8 < xr && 11 >= xr), Na = " ", dg = !1;
  function xd(a, u) {
    switch (a) {
      case "keyup":
        return WO.indexOf(u.keyCode) !== -1;
      case "keydown":
        return u.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Sf(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var Dl = !1;
  function pg(a, u) {
    switch (a) {
      case "compositionend":
        return Sf(u);
      case "keypress":
        return u.which !== 32 ? null : (dg = !0, Na);
      case "textInput":
        return a = u.data, a === Na && dg ? null : a;
      default:
        return null;
    }
  }
  function mg(a, u) {
    if (Dl)
      return a === "compositionend" || !Sd && xd(a, u) ? (a = mf(), vr = pd = kl = null, Dl = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(u.ctrlKey || u.altKey || u.metaKey) || u.ctrlKey && u.altKey) {
          if (u.char && 1 < u.char.length)
            return u.char;
          if (u.which) return String.fromCharCode(u.which);
        }
        return null;
      case "compositionend":
        return Td && u.locale !== "ko" ? null : u.data;
      default:
        return null;
    }
  }
  var Ar = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function gg(a) {
    var u = a && a.nodeName && a.nodeName.toLowerCase();
    return u === "input" ? !!Ar[a.type] : u === "textarea";
  }
  function Ad(a, u, f, p) {
    Or ? Ru ? Ru.push(p) : Ru = [p] : Or = p, u = qs(u, "onChange"), 0 < u.length && (f = new yf(
      "onChange",
      "change",
      null,
      f,
      p
    ), a.push({ event: f, listeners: u }));
  }
  var wr = null, ea = null;
  function Er(a) {
    jo(a, 0);
  }
  function Mu(a) {
    var u = Su(a);
    if (Eu(u)) return a;
  }
  function cs(a, u) {
    if (a === "change") return u;
  }
  var yg = !1;
  if (Jl) {
    var wd;
    if (Jl) {
      var Cr = "oninput" in document;
      if (!Cr) {
        var zu = document.createElement("div");
        zu.setAttribute("oninput", "return;"), Cr = typeof zu.oninput == "function";
      }
      wd = Cr;
    } else wd = !1;
    yg = wd && (!document.documentMode || 9 < document.documentMode);
  }
  function Og() {
    wr && (wr.detachEvent("onpropertychange", Qu), ea = wr = null);
  }
  function Qu(a) {
    if (a.propertyName === "value" && Mu(ea)) {
      var u = [];
      Ad(
        u,
        ea,
        a,
        yr(a)
      ), LO(Er, u);
    }
  }
  function FO(a, u, f) {
    a === "focusin" ? (Og(), wr = u, ea = f, wr.attachEvent("onpropertychange", Qu)) : a === "focusout" && Og();
  }
  function Ed(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Mu(ea);
  }
  function fs(a, u) {
    if (a === "click") return Mu(u);
  }
  function So(a, u) {
    if (a === "input" || a === "change")
      return Mu(u);
  }
  function vg(a, u) {
    return a === u && (a !== 0 || 1 / a === 1 / u) || a !== a && u !== u;
  }
  var Ai = typeof Object.is == "function" ? Object.is : vg;
  function To(a, u) {
    if (Ai(a, u)) return !0;
    if (typeof a != "object" || a === null || typeof u != "object" || u === null)
      return !1;
    var f = Object.keys(a), p = Object.keys(u);
    if (f.length !== p.length) return !1;
    for (p = 0; p < f.length; p++) {
      var v = f[p];
      if (!ho.call(u, v) || !Ai(a[v], u[v]))
        return !1;
    }
    return !0;
  }
  function Tf(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function hs(a, u) {
    var f = Tf(a);
    a = 0;
    for (var p; f; ) {
      if (f.nodeType === 3) {
        if (p = a + f.textContent.length, a <= u && p >= u)
          return { node: f, offset: u - a };
        a = p;
      }
      e: {
        for (; f; ) {
          if (f.nextSibling) {
            f = f.nextSibling;
            break e;
          }
          f = f.parentNode;
        }
        f = void 0;
      }
      f = Tf(f);
    }
  }
  function Wt(a, u) {
    return a && u ? a === u ? !0 : a && a.nodeType === 3 ? !1 : u && u.nodeType === 3 ? Wt(a, u.parentNode) : "contains" in a ? a.contains(u) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(u) & 16) : !1 : !1;
  }
  function xf(a) {
    a = a != null && a.ownerDocument != null && a.ownerDocument.defaultView != null ? a.ownerDocument.defaultView : window;
    for (var u = vo(a.document); u instanceof a.HTMLIFrameElement; ) {
      try {
        var f = typeof u.contentWindow.location.href == "string";
      } catch {
        f = !1;
      }
      if (f) a = u.contentWindow;
      else break;
      u = vo(a.document);
    }
    return u;
  }
  function Cd(a) {
    var u = a && a.nodeName && a.nodeName.toLowerCase();
    return u && (u === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || u === "textarea" || a.contentEditable === "true");
  }
  var bg = Jl && "documentMode" in document && 11 >= document.documentMode, Ml = null, Rr = null, ul = null, Nu = !1;
  function Uu(a, u, f) {
    var p = f.window === f ? f.document : f.nodeType === 9 ? f : f.ownerDocument;
    Nu || Ml == null || Ml !== vo(p) || (p = Ml, "selectionStart" in p && Cd(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = {
      anchorNode: p.anchorNode,
      anchorOffset: p.anchorOffset,
      focusNode: p.focusNode,
      focusOffset: p.focusOffset
    }), ul && To(ul, p) || (ul = p, p = qs(Rr, "onSelect"), 0 < p.length && (u = new yf(
      "onSelect",
      "select",
      null,
      u,
      f
    ), a.push({ event: u, listeners: p }), u.target = Ml)));
  }
  function xo(a, u) {
    var f = {};
    return f[a.toLowerCase()] = u.toLowerCase(), f["Webkit" + a] = "webkit" + u, f["Moz" + a] = "moz" + u, f;
  }
  var ds = {
    animationend: xo("Animation", "AnimationEnd"),
    animationiteration: xo("Animation", "AnimationIteration"),
    animationstart: xo("Animation", "AnimationStart"),
    transitionrun: xo("Transition", "TransitionRun"),
    transitionstart: xo("Transition", "TransitionStart"),
    transitioncancel: xo("Transition", "TransitionCancel"),
    transitionend: xo("Transition", "TransitionEnd")
  }, Rd = {}, ta = {};
  Jl && (ta = document.createElement("div").style, "AnimationEvent" in window || (delete ds.animationend.animation, delete ds.animationiteration.animation, delete ds.animationstart.animation), "TransitionEvent" in window || delete ds.transitionend.transition);
  function di(a) {
    if (Rd[a]) return Rd[a];
    if (!ds[a]) return a;
    var u = ds[a], f;
    for (f in u)
      if (u.hasOwnProperty(f) && f in ta)
        return Rd[a] = u[f];
    return a;
  }
  var Af = di("animationend"), KO = di("animationiteration"), Sg = di("animationstart"), uS = di("transitionrun"), Tg = di("transitionstart"), kd = di("transitioncancel"), xg = di("transitionend"), Ag = /* @__PURE__ */ new Map(), Dd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Dd.push("scrollEnd");
  function _i(a, u) {
    Ag.set(a, u), qn(u, [a]);
  }
  var wg = /* @__PURE__ */ new WeakMap();
  function cl(a, u) {
    if (typeof a == "object" && a !== null) {
      var f = wg.get(a);
      return f !== void 0 ? f : (u = {
        value: a,
        source: u,
        stack: ss(u)
      }, wg.set(a, u), u);
    }
    return {
      value: a,
      source: u,
      stack: ss(u)
    };
  }
  var fl = [], ps = 0, wf = 0;
  function na() {
    for (var a = ps, u = wf = ps = 0; u < a; ) {
      var f = fl[u];
      fl[u++] = null;
      var p = fl[u];
      fl[u++] = null;
      var v = fl[u];
      fl[u++] = null;
      var T = fl[u];
      if (fl[u++] = null, p !== null && v !== null) {
        var k = p.pending;
        k === null ? v.next = v : (v.next = k.next, k.next = v), p.pending = v;
      }
      T !== 0 && Bu(f, v, T);
    }
  }
  function ia(a, u, f, p) {
    fl[ps++] = a, fl[ps++] = u, fl[ps++] = f, fl[ps++] = p, wf |= p, a.lanes |= p, a = a.alternate, a !== null && (a.lanes |= p);
  }
  function kr(a, u, f, p) {
    return ia(a, u, f, p), ms(a);
  }
  function Ao(a, u) {
    return ia(a, null, null, u), ms(a);
  }
  function Bu(a, u, f) {
    a.lanes |= f;
    var p = a.alternate;
    p !== null && (p.lanes |= f);
    for (var v = !1, T = a.return; T !== null; )
      T.childLanes |= f, p = T.alternate, p !== null && (p.childLanes |= f), T.tag === 22 && (a = T.stateNode, a === null || a._visibility & 1 || (v = !0)), a = T, T = T.return;
    return a.tag === 3 ? (T = a.stateNode, v && u !== null && (v = 31 - Fn(f), a = T.hiddenUpdates, p = a[v], p === null ? a[v] = [u] : p.push(u), u.lane = f | 536870912), T) : null;
  }
  function ms(a) {
    if (50 < mc)
      throw mc = 0, yp = null, Error(l(185));
    for (var u = a.return; u !== null; )
      a = u, u = a.return;
    return a.tag === 3 ? a.stateNode : null;
  }
  var Dr = {};
  function cS(a, u, f, p) {
    this.tag = a, this.key = f, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Hi(a, u, f, p) {
    return new cS(a, u, f, p);
  }
  function Md(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function la(a, u) {
    var f = a.alternate;
    return f === null ? (f = Hi(
      a.tag,
      u,
      a.key,
      a.mode
    ), f.elementType = a.elementType, f.type = a.type, f.stateNode = a.stateNode, f.alternate = a, a.alternate = f) : (f.pendingProps = u, f.type = a.type, f.flags = 0, f.subtreeFlags = 0, f.deletions = null), f.flags = a.flags & 65011712, f.childLanes = a.childLanes, f.lanes = a.lanes, f.child = a.child, f.memoizedProps = a.memoizedProps, f.memoizedState = a.memoizedState, f.updateQueue = a.updateQueue, u = a.dependencies, f.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }, f.sibling = a.sibling, f.index = a.index, f.ref = a.ref, f.refCleanup = a.refCleanup, f;
  }
  function zd(a, u) {
    a.flags &= 65011714;
    var f = a.alternate;
    return f === null ? (a.childLanes = 0, a.lanes = u, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = f.childLanes, a.lanes = f.lanes, a.child = f.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = f.memoizedProps, a.memoizedState = f.memoizedState, a.updateQueue = f.updateQueue, a.type = f.type, u = f.dependencies, a.dependencies = u === null ? null : {
      lanes: u.lanes,
      firstContext: u.firstContext
    }), a;
  }
  function rt(a, u, f, p, v, T) {
    var k = 0;
    if (p = a, typeof a == "function") Md(a) && (k = 1);
    else if (typeof a == "string")
      k = Nv(
        a,
        f,
        Ae.current
      ) ? 26 : a === "html" || a === "head" || a === "body" ? 27 : 5;
    else
      e: switch (a) {
        case Re:
          return a = Hi(31, f, u, v), a.elementType = Re, a.lanes = T, a;
        case z:
          return be(f.children, v, T, u);
        case U:
          k = 8, v |= 24;
          break;
        case V:
          return a = Hi(12, f, u, v | 2), a.elementType = V, a.lanes = T, a;
        case ne:
          return a = Hi(13, f, u, v), a.elementType = ne, a.lanes = T, a;
        case ye:
          return a = Hi(19, f, u, v), a.elementType = ye, a.lanes = T, a;
        default:
          if (typeof a == "object" && a !== null)
            switch (a.$$typeof) {
              case G:
              case me:
                k = 10;
                break e;
              case ie:
                k = 9;
                break e;
              case pe:
                k = 11;
                break e;
              case Oe:
                k = 14;
                break e;
              case we:
                k = 16, p = null;
                break e;
            }
          k = 29, f = Error(
            l(130, a === null ? "null" : typeof a, "")
          ), p = null;
      }
    return u = Hi(k, f, u, v), u.elementType = a, u.type = p, u.lanes = T, u;
  }
  function be(a, u, f, p) {
    return a = Hi(7, a, p, u), a.lanes = f, a;
  }
  function gs(a, u, f) {
    return a = Hi(6, a, null, u), a.lanes = f, a;
  }
  function qu(a, u, f) {
    return u = Hi(
      4,
      a.children !== null ? a.children : [],
      a.key,
      u
    ), u.lanes = f, u.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    }, u;
  }
  var Zt = [], ys = 0, _u = null, Ef = 0, Li = [], zl = 0, wo = null, aa = 1, oa = "";
  function Tn(a, u) {
    Zt[ys++] = Ef, Zt[ys++] = _u, _u = a, Ef = u;
  }
  function Bt(a, u, f) {
    Li[zl++] = aa, Li[zl++] = oa, Li[zl++] = wo, wo = a;
    var p = aa;
    a = oa;
    var v = 32 - Fn(p) - 1;
    p &= ~(1 << v), f += 1;
    var T = 32 - Fn(u) + v;
    if (30 < T) {
      var k = v - v % 5;
      T = (p & (1 << k) - 1).toString(32), p >>= k, v -= k, aa = 1 << 32 - Fn(u) + v | f << v | p, oa = T + a;
    } else
      aa = 1 << T | f << v | p, oa = a;
  }
  function Cf(a) {
    a.return !== null && (Tn(a, 1), Bt(a, 1, 0));
  }
  function Mr(a) {
    for (; a === _u; )
      _u = Zt[--ys], Zt[ys] = null, Ef = Zt[--ys], Zt[ys] = null;
    for (; a === wo; )
      wo = Li[--zl], Li[zl] = null, oa = Li[--zl], Li[zl] = null, aa = Li[--zl], Li[zl] = null;
  }
  var hn = null, Lt = null, ut = !1, Eo = null, wi = !1, Rf = Error(l(519));
  function sa(a) {
    var u = Error(l(418, ""));
    throw Vu(cl(u, a)), Rf;
  }
  function Qd(a) {
    var u = a.stateNode, f = a.type, p = a.memoizedProps;
    switch (u[$t] = a, u[fi] = p, f) {
      case "dialog":
        at("cancel", u), at("close", u);
        break;
      case "iframe":
      case "object":
      case "embed":
        at("load", u);
        break;
      case "video":
      case "audio":
        for (f = 0; f < Ie.length; f++)
          at(Ie[f], u);
        break;
      case "source":
        at("error", u);
        break;
      case "img":
      case "image":
      case "link":
        at("error", u), at("load", u);
        break;
      case "details":
        at("toggle", u);
        break;
      case "input":
        at("invalid", u), ng(
          u,
          p.value,
          p.defaultValue,
          p.checked,
          p.defaultChecked,
          p.type,
          p.name,
          !0
        ), wu(u);
        break;
      case "select":
        at("invalid", u);
        break;
      case "textarea":
        at("invalid", u), lg(u, p.value, p.defaultValue, p.children), wu(u);
    }
    f = p.children, typeof f != "string" && typeof f != "number" && typeof f != "bigint" || u.textContent === "" + f || p.suppressHydrationWarning === !0 || Mv(u.textContent, f) ? (p.popover != null && (at("beforetoggle", u), at("toggle", u)), p.onScroll != null && at("scroll", u), p.onScrollEnd != null && at("scrollend", u), p.onClick != null && (u.onclick = dh), u = !0) : u = !1, u || sa(a);
  }
  function kf(a) {
    for (hn = a.return; hn; )
      switch (hn.tag) {
        case 5:
        case 13:
          wi = !1;
          return;
        case 27:
        case 3:
          wi = !0;
          return;
        default:
          hn = hn.return;
      }
  }
  function Hu(a) {
    if (a !== hn) return !1;
    if (!ut) return kf(a), ut = !0, !1;
    var u = a.tag, f;
    if ((f = u !== 3 && u !== 27) && ((f = u === 5) && (f = a.type, f = !(f !== "form" && f !== "button") || Wr(a.type, a.memoizedProps)), f = !f), f && Lt && sa(a), kf(a), u === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(l(317));
      e: {
        for (a = a.nextSibling, u = 0; a; ) {
          if (a.nodeType === 8)
            if (f = a.data, f === "/$") {
              if (u === 0) {
                Lt = ba(a.nextSibling);
                break e;
              }
              u--;
            } else
              f !== "$" && f !== "$!" && f !== "$?" || u++;
          a = a.nextSibling;
        }
        Lt = null;
      }
    } else
      u === 27 ? (u = Lt, ni(a.type) ? (a = Y0, Y0 = null, Lt = a) : Lt = u) : Lt = hn ? ba(a.stateNode.nextSibling) : null;
    return !0;
  }
  function Lu() {
    Lt = hn = null, ut = !1;
  }
  function Eg() {
    var a = Eo;
    return a !== null && (Ci === null ? Ci = a : Ci.push.apply(
      Ci,
      a
    ), Eo = null), a;
  }
  function Vu(a) {
    Eo === null ? Eo = [a] : Eo.push(a);
  }
  var Nd = L(null), Co = null, ra = null;
  function Ua(a, u, f) {
    le(Nd, u._currentValue), u._currentValue = f;
  }
  function Ba(a) {
    a._currentValue = Nd.current, se(Nd);
  }
  function Ud(a, u, f) {
    for (; a !== null; ) {
      var p = a.alternate;
      if ((a.childLanes & u) !== u ? (a.childLanes |= u, p !== null && (p.childLanes |= u)) : p !== null && (p.childLanes & u) !== u && (p.childLanes |= u), a === f) break;
      a = a.return;
    }
  }
  function Bd(a, u, f, p) {
    var v = a.child;
    for (v !== null && (v.return = a); v !== null; ) {
      var T = v.dependencies;
      if (T !== null) {
        var k = v.child;
        T = T.firstContext;
        e: for (; T !== null; ) {
          var D = T;
          T = v;
          for (var q = 0; q < u.length; q++)
            if (D.context === u[q]) {
              T.lanes |= f, D = T.alternate, D !== null && (D.lanes |= f), Ud(
                T.return,
                f,
                a
              ), p || (k = null);
              break e;
            }
          T = D.next;
        }
      } else if (v.tag === 18) {
        if (k = v.return, k === null) throw Error(l(341));
        k.lanes |= f, T = k.alternate, T !== null && (T.lanes |= f), Ud(k, f, a), k = null;
      } else k = v.child;
      if (k !== null) k.return = v;
      else
        for (k = v; k !== null; ) {
          if (k === a) {
            k = null;
            break;
          }
          if (v = k.sibling, v !== null) {
            v.return = k.return, k = v;
            break;
          }
          k = k.return;
        }
      v = k;
    }
  }
  function Df(a, u, f, p) {
    a = null;
    for (var v = u, T = !1; v !== null; ) {
      if (!T) {
        if ((v.flags & 524288) !== 0) T = !0;
        else if ((v.flags & 262144) !== 0) break;
      }
      if (v.tag === 10) {
        var k = v.alternate;
        if (k === null) throw Error(l(387));
        if (k = k.memoizedProps, k !== null) {
          var D = v.type;
          Ai(v.pendingProps.value, k.value) || (a !== null ? a.push(D) : a = [D]);
        }
      } else if (v === Ke.current) {
        if (k = v.alternate, k === null) throw Error(l(387));
        k.memoizedState.memoizedState !== v.memoizedState.memoizedState && (a !== null ? a.push(li) : a = [li]);
      }
      v = v.return;
    }
    a !== null && Bd(
      u,
      a,
      f,
      p
    ), u.flags |= 262144;
  }
  function Mf(a) {
    for (a = a.firstContext; a !== null; ) {
      if (!Ai(
        a.context._currentValue,
        a.memoizedValue
      ))
        return !0;
      a = a.next;
    }
    return !1;
  }
  function Os(a) {
    Co = a, ra = null, a = a.dependencies, a !== null && (a.firstContext = null);
  }
  function ei(a) {
    return Cg(Co, a);
  }
  function Xu(a, u) {
    return Co === null && Os(a), Cg(a, u);
  }
  function Cg(a, u) {
    var f = u._currentValue;
    if (u = { context: u, memoizedValue: f, next: null }, ra === null) {
      if (a === null) throw Error(l(308));
      ra = u, a.dependencies = { lanes: 0, firstContext: u }, a.flags |= 524288;
    } else ra = ra.next = u;
    return f;
  }
  var JO = typeof AbortController < "u" ? AbortController : function() {
    var a = [], u = this.signal = {
      aborted: !1,
      addEventListener: function(f, p) {
        a.push(p);
      }
    };
    this.abort = function() {
      u.aborted = !0, a.forEach(function(f) {
        return f();
      });
    };
  }, ju = o.unstable_scheduleCallback, qd = o.unstable_NormalPriority, xn = {
    $$typeof: me,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Rg() {
    return {
      controller: new JO(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function vs(a) {
    a.refCount--, a.refCount === 0 && ju(qd, function() {
      a.controller.abort();
    });
  }
  var qa = null, Gu = 0, bs = 0, Ql = null;
  function Vi(a, u) {
    if (qa === null) {
      var f = qa = [];
      Gu = 0, bs = Cp(), Ql = {
        status: "pending",
        value: void 0,
        then: function(p) {
          f.push(p);
        }
      };
    }
    return Gu++, u.then(zf, zf), u;
  }
  function zf() {
    if (--Gu === 0 && qa !== null) {
      Ql !== null && (Ql.status = "fulfilled");
      var a = qa;
      qa = null, bs = 0, Ql = null;
      for (var u = 0; u < a.length; u++) (0, a[u])();
    }
  }
  function kg(a, u) {
    var f = [], p = {
      status: "pending",
      value: null,
      reason: null,
      then: function(v) {
        f.push(v);
      }
    };
    return a.then(
      function() {
        p.status = "fulfilled", p.value = u;
        for (var v = 0; v < f.length; v++) (0, f[v])(u);
      },
      function(v) {
        for (p.status = "rejected", p.reason = v, v = 0; v < f.length; v++)
          (0, f[v])(void 0);
      }
    ), p;
  }
  var Dg = F.S;
  F.S = function(a, u) {
    typeof u == "object" && u !== null && typeof u.then == "function" && Vi(a, u), Dg !== null && Dg(a, u);
  };
  var Ro = L(null);
  function Yu() {
    var a = Ro.current;
    return a !== null ? a : Xt.pooledCache;
  }
  function $u(a, u) {
    u === null ? le(Ro, Ro.current) : le(Ro, u.pool);
  }
  function Qf() {
    var a = Yu();
    return a === null ? null : { parent: xn._currentValue, pool: a };
  }
  var zr = Error(l(460)), Nf = Error(l(474)), Zu = Error(l(542)), _d = { then: function() {
  } };
  function Mg(a) {
    return a = a.status, a === "fulfilled" || a === "rejected";
  }
  function Pu() {
  }
  function zg(a, u, f) {
    switch (f = a[f], f === void 0 ? a.push(u) : f !== u && (u.then(Pu, Pu), u = f), u.status) {
      case "fulfilled":
        return u.value;
      case "rejected":
        throw a = u.reason, Qg(a), a;
      default:
        if (typeof u.status == "string") u.then(Pu, Pu);
        else {
          if (a = Xt, a !== null && 100 < a.shellSuspendCounter)
            throw Error(l(482));
          a = u, a.status = "pending", a.then(
            function(p) {
              if (u.status === "pending") {
                var v = u;
                v.status = "fulfilled", v.value = p;
              }
            },
            function(p) {
              if (u.status === "pending") {
                var v = u;
                v.status = "rejected", v.reason = p;
              }
            }
          );
        }
        switch (u.status) {
          case "fulfilled":
            return u.value;
          case "rejected":
            throw a = u.reason, Qg(a), a;
        }
        throw Wu = u, zr;
    }
  }
  var Wu = null;
  function Hd() {
    if (Wu === null) throw Error(l(459));
    var a = Wu;
    return Wu = null, a;
  }
  function Qg(a) {
    if (a === zr || a === Zu)
      throw Error(l(483));
  }
  var ko = !1;
  function Uf(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Ld(a, u) {
    a = a.updateQueue, u.updateQueue === a && (u.updateQueue = {
      baseState: a.baseState,
      firstBaseUpdate: a.firstBaseUpdate,
      lastBaseUpdate: a.lastBaseUpdate,
      shared: a.shared,
      callbacks: null
    });
  }
  function Do(a) {
    return { lane: a, tag: 0, payload: null, callback: null, next: null };
  }
  function Xi(a, u, f) {
    var p = a.updateQueue;
    if (p === null) return null;
    if (p = p.shared, (qt & 2) !== 0) {
      var v = p.pending;
      return v === null ? u.next = u : (u.next = v.next, v.next = u), p.pending = u, u = ms(a), Bu(a, null, f), u;
    }
    return ia(a, p, u, f), ms(a);
  }
  function Qr(a, u, f) {
    if (u = u.updateQueue, u !== null && (u = u.shared, (f & 4194048) !== 0)) {
      var p = u.lanes;
      p &= a.pendingLanes, f |= p, u.lanes = f, St(a, f);
    }
  }
  function Bf(a, u) {
    var f = a.updateQueue, p = a.alternate;
    if (p !== null && (p = p.updateQueue, f === p)) {
      var v = null, T = null;
      if (f = f.firstBaseUpdate, f !== null) {
        do {
          var k = {
            lane: f.lane,
            tag: f.tag,
            payload: f.payload,
            callback: null,
            next: null
          };
          T === null ? v = T = k : T = T.next = k, f = f.next;
        } while (f !== null);
        T === null ? v = T = u : T = T.next = u;
      } else v = T = u;
      f = {
        baseState: p.baseState,
        firstBaseUpdate: v,
        lastBaseUpdate: T,
        shared: p.shared,
        callbacks: p.callbacks
      }, a.updateQueue = f;
      return;
    }
    a = f.lastBaseUpdate, a === null ? f.firstBaseUpdate = u : a.next = u, f.lastBaseUpdate = u;
  }
  var Ng = !1;
  function qf() {
    if (Ng) {
      var a = Ql;
      if (a !== null) throw a;
    }
  }
  function Fu(a, u, f, p) {
    Ng = !1;
    var v = a.updateQueue;
    ko = !1;
    var T = v.firstBaseUpdate, k = v.lastBaseUpdate, D = v.shared.pending;
    if (D !== null) {
      v.shared.pending = null;
      var q = D, P = q.next;
      q.next = null, k === null ? T = P : k.next = P, k = q;
      var ce = a.alternate;
      ce !== null && (ce = ce.updateQueue, D = ce.lastBaseUpdate, D !== k && (D === null ? ce.firstBaseUpdate = P : D.next = P, ce.lastBaseUpdate = q));
    }
    if (T !== null) {
      var de = v.baseState;
      k = 0, ce = P = q = null, D = T;
      do {
        var K = D.lane & -536870913, te = K !== D.lane;
        if (te ? (xt & K) === K : (p & K) === K) {
          K !== 0 && K === bs && (Ng = !0), ce !== null && (ce = ce.next = {
            lane: 0,
            tag: D.tag,
            payload: D.payload,
            callback: null,
            next: null
          });
          e: {
            var Pe = a, $e = D;
            K = u;
            var zt = f;
            switch ($e.tag) {
              case 1:
                if (Pe = $e.payload, typeof Pe == "function") {
                  de = Pe.call(zt, de, K);
                  break e;
                }
                de = Pe;
                break e;
              case 3:
                Pe.flags = Pe.flags & -65537 | 128;
              case 0:
                if (Pe = $e.payload, K = typeof Pe == "function" ? Pe.call(zt, de, K) : Pe, K == null) break e;
                de = S({}, de, K);
                break e;
              case 2:
                ko = !0;
            }
          }
          K = D.callback, K !== null && (a.flags |= 64, te && (a.flags |= 8192), te = v.callbacks, te === null ? v.callbacks = [K] : te.push(K));
        } else
          te = {
            lane: K,
            tag: D.tag,
            payload: D.payload,
            callback: D.callback,
            next: null
          }, ce === null ? (P = ce = te, q = de) : ce = ce.next = te, k |= K;
        if (D = D.next, D === null) {
          if (D = v.shared.pending, D === null)
            break;
          te = D, D = te.next, te.next = null, v.lastBaseUpdate = te, v.shared.pending = null;
        }
      } while (!0);
      ce === null && (q = de), v.baseState = q, v.firstBaseUpdate = P, v.lastBaseUpdate = ce, T === null && (v.shared.lanes = 0), Ds |= k, a.lanes = k, a.memoizedState = de;
    }
  }
  function Ku(a, u) {
    if (typeof a != "function")
      throw Error(l(191, a));
    a.call(u);
  }
  function Vd(a, u) {
    var f = a.callbacks;
    if (f !== null)
      for (a.callbacks = null, a = 0; a < f.length; a++)
        Ku(f[a], u);
  }
  var Mo = L(null), _f = L(0);
  function Ug(a, u) {
    a = Lo, le(_f, a), le(Mo, u), Lo = a | u.baseLanes;
  }
  function kn() {
    le(_f, Lo), le(Mo, Mo.current);
  }
  function Ju() {
    Lo = _f.current, se(Mo), se(_f);
  }
  var ua = 0, nt = null, Dt = null, rn = null, Nr = !1, Ur = !1, ji = !1, Hf = 0, Nl = 0, Gi = null, Xd = 0;
  function un() {
    throw Error(l(321));
  }
  function Lf(a, u) {
    if (u === null) return !1;
    for (var f = 0; f < u.length && f < a.length; f++)
      if (!Ai(a[f], u[f])) return !1;
    return !0;
  }
  function jd(a, u, f, p, v, T) {
    return ua = T, nt = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, F.H = a === null || a.memoizedState === null ? ov : e0, ji = !1, T = f(p, v), ji = !1, Ur && (T = Ss(
      u,
      f,
      p,
      v
    )), Bg(a), T;
  }
  function Bg(a) {
    F.H = Ff;
    var u = Dt !== null && Dt.next !== null;
    if (ua = 0, rn = Dt = nt = null, Nr = !1, Nl = 0, Gi = null, u) throw Error(l(300));
    a === null || mt || (a = a.dependencies, a !== null && Mf(a) && (mt = !0));
  }
  function Ss(a, u, f, p) {
    nt = a;
    var v = 0;
    do {
      if (Ur && (Gi = null), Nl = 0, Ur = !1, 25 <= v) throw Error(l(301));
      if (v += 1, rn = Dt = null, a.updateQueue != null) {
        var T = a.updateQueue;
        T.lastEffect = null, T.events = null, T.stores = null, T.memoCache != null && (T.memoCache.index = 0);
      }
      F.H = sv, T = u(f, p);
    } while (Ur);
    return T;
  }
  function IO() {
    var a = F.H, u = a.useState()[0];
    return u = typeof u.then == "function" ? Br(u) : u, a = a.useState()[0], (Dt !== null ? Dt.memoizedState : null) !== a && (nt.flags |= 1024), u;
  }
  function Gd() {
    var a = Hf !== 0;
    return Hf = 0, a;
  }
  function Yd(a, u, f) {
    u.updateQueue = a.updateQueue, u.flags &= -2053, a.lanes &= ~f;
  }
  function Iu(a) {
    if (Nr) {
      for (a = a.memoizedState; a !== null; ) {
        var u = a.queue;
        u !== null && (u.pending = null), a = a.next;
      }
      Nr = !1;
    }
    ua = 0, rn = Dt = nt = null, Ur = !1, Nl = Hf = 0, Gi = null;
  }
  function Ei() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return rn === null ? nt.memoizedState = rn = a : rn = rn.next = a, rn;
  }
  function dn() {
    if (Dt === null) {
      var a = nt.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = Dt.next;
    var u = rn === null ? nt.memoizedState : rn.next;
    if (u !== null)
      rn = u, Dt = a;
    else {
      if (a === null)
        throw nt.alternate === null ? Error(l(467)) : Error(l(310));
      Dt = a, a = {
        memoizedState: Dt.memoizedState,
        baseState: Dt.baseState,
        baseQueue: Dt.baseQueue,
        queue: Dt.queue,
        next: null
      }, rn === null ? nt.memoizedState = rn = a : rn = rn.next = a;
    }
    return rn;
  }
  function Vf() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Br(a) {
    var u = Nl;
    return Nl += 1, Gi === null && (Gi = []), a = zg(Gi, a, u), u = nt, (rn === null ? u.memoizedState : rn.next) === null && (u = u.alternate, F.H = u === null || u.memoizedState === null ? ov : e0), a;
  }
  function $d(a) {
    if (a !== null && typeof a == "object") {
      if (typeof a.then == "function") return Br(a);
      if (a.$$typeof === me) return ei(a);
    }
    throw Error(l(438, String(a)));
  }
  function Dn(a) {
    var u = null, f = nt.updateQueue;
    if (f !== null && (u = f.memoCache), u == null) {
      var p = nt.alternate;
      p !== null && (p = p.updateQueue, p !== null && (p = p.memoCache, p != null && (u = {
        data: p.data.map(function(v) {
          return v.slice();
        }),
        index: 0
      })));
    }
    if (u == null && (u = { data: [], index: 0 }), f === null && (f = Vf(), nt.updateQueue = f), f.memoCache = u, f = u.data[u.index], f === void 0)
      for (f = u.data[u.index] = Array(a), p = 0; p < a; p++)
        f[p] = Te;
    return u.index++, f;
  }
  function _a(a, u) {
    return typeof u == "function" ? u(a) : u;
  }
  function Xf(a) {
    var u = dn();
    return Zd(u, Dt, a);
  }
  function Zd(a, u, f) {
    var p = a.queue;
    if (p === null) throw Error(l(311));
    p.lastRenderedReducer = f;
    var v = a.baseQueue, T = p.pending;
    if (T !== null) {
      if (v !== null) {
        var k = v.next;
        v.next = T.next, T.next = k;
      }
      u.baseQueue = v = T, p.pending = null;
    }
    if (T = a.baseState, v === null) a.memoizedState = T;
    else {
      u = v.next;
      var D = k = null, q = null, P = u, ce = !1;
      do {
        var de = P.lane & -536870913;
        if (de !== P.lane ? (xt & de) === de : (ua & de) === de) {
          var K = P.revertLane;
          if (K === 0)
            q !== null && (q = q.next = {
              lane: 0,
              revertLane: 0,
              action: P.action,
              hasEagerState: P.hasEagerState,
              eagerState: P.eagerState,
              next: null
            }), de === bs && (ce = !0);
          else if ((ua & K) === K) {
            P = P.next, K === bs && (ce = !0);
            continue;
          } else
            de = {
              lane: 0,
              revertLane: P.revertLane,
              action: P.action,
              hasEagerState: P.hasEagerState,
              eagerState: P.eagerState,
              next: null
            }, q === null ? (D = q = de, k = T) : q = q.next = de, nt.lanes |= K, Ds |= K;
          de = P.action, ji && f(T, de), T = P.hasEagerState ? P.eagerState : f(T, de);
        } else
          K = {
            lane: de,
            revertLane: P.revertLane,
            action: P.action,
            hasEagerState: P.hasEagerState,
            eagerState: P.eagerState,
            next: null
          }, q === null ? (D = q = K, k = T) : q = q.next = K, nt.lanes |= de, Ds |= de;
        P = P.next;
      } while (P !== null && P !== u);
      if (q === null ? k = T : q.next = D, !Ai(T, a.memoizedState) && (mt = !0, ce && (f = Ql, f !== null)))
        throw f;
      a.memoizedState = T, a.baseState = k, a.baseQueue = q, p.lastRenderedState = T;
    }
    return v === null && (p.lanes = 0), [a.memoizedState, p.dispatch];
  }
  function Pd(a) {
    var u = dn(), f = u.queue;
    if (f === null) throw Error(l(311));
    f.lastRenderedReducer = a;
    var p = f.dispatch, v = f.pending, T = u.memoizedState;
    if (v !== null) {
      f.pending = null;
      var k = v = v.next;
      do
        T = a(T, k.action), k = k.next;
      while (k !== v);
      Ai(T, u.memoizedState) || (mt = !0), u.memoizedState = T, u.baseQueue === null && (u.baseState = T), f.lastRenderedState = T;
    }
    return [T, p];
  }
  function qg(a, u, f) {
    var p = nt, v = dn(), T = ut;
    if (T) {
      if (f === void 0) throw Error(l(407));
      f = f();
    } else f = u();
    var k = !Ai(
      (Dt || v).memoizedState,
      f
    );
    k && (v.memoizedState = f, mt = !0), v = v.queue;
    var D = _g.bind(null, p, v, a);
    if (zo(2048, 8, D, [a]), v.getSnapshot !== u || k || rn !== null && rn.memoizedState.tag & 1) {
      if (p.flags |= 2048, Ts(
        9,
        Ul(),
        Wd.bind(
          null,
          p,
          v,
          f,
          u
        ),
        null
      ), Xt === null) throw Error(l(349));
      T || (ua & 124) !== 0 || jf(p, u, f);
    }
    return f;
  }
  function jf(a, u, f) {
    a.flags |= 16384, a = { getSnapshot: u, value: f }, u = nt.updateQueue, u === null ? (u = Vf(), nt.updateQueue = u, u.stores = [a]) : (f = u.stores, f === null ? u.stores = [a] : f.push(a));
  }
  function Wd(a, u, f, p) {
    u.value = f, u.getSnapshot = p, Hg(u) && Lg(a);
  }
  function _g(a, u, f) {
    return f(function() {
      Hg(u) && Lg(a);
    });
  }
  function Hg(a) {
    var u = a.getSnapshot;
    a = a.value;
    try {
      var f = u();
      return !Ai(a, f);
    } catch {
      return !0;
    }
  }
  function Lg(a) {
    var u = Ao(a, 2);
    u !== null && Ji(u, a, 2);
  }
  function Gf(a) {
    var u = Ei();
    if (typeof a == "function") {
      var f = a;
      if (a = f(), ji) {
        El(!0);
        try {
          f();
        } finally {
          El(!1);
        }
      }
    }
    return u.memoizedState = u.baseState = a, u.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: _a,
      lastRenderedState: a
    }, u;
  }
  function Fd(a, u, f, p) {
    return a.baseState = f, Zd(
      a,
      Dt,
      typeof p == "function" ? p : _a
    );
  }
  function Vg(a, u, f, p, v) {
    if (nc(a)) throw Error(l(485));
    if (a = u.action, a !== null) {
      var T = {
        payload: v,
        action: a,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(k) {
          T.listeners.push(k);
        }
      };
      F.T !== null ? f(!0) : T.isTransition = !1, p(T), f = u.pending, f === null ? (T.next = u.pending = T, Xg(u, T)) : (T.next = f.next, u.pending = f.next = T);
    }
  }
  function Xg(a, u) {
    var f = u.action, p = u.payload, v = a.state;
    if (u.isTransition) {
      var T = F.T, k = {};
      F.T = k;
      try {
        var D = f(v, p), q = F.S;
        q !== null && q(k, D), Kd(a, u, D);
      } catch (P) {
        $f(a, u, P);
      } finally {
        F.T = T;
      }
    } else
      try {
        T = f(v, p), Kd(a, u, T);
      } catch (P) {
        $f(a, u, P);
      }
  }
  function Kd(a, u, f) {
    f !== null && typeof f == "object" && typeof f.then == "function" ? f.then(
      function(p) {
        Yf(a, u, p);
      },
      function(p) {
        return $f(a, u, p);
      }
    ) : Yf(a, u, f);
  }
  function Yf(a, u, f) {
    u.status = "fulfilled", u.value = f, jg(u), a.state = f, u = a.pending, u !== null && (f = u.next, f === u ? a.pending = null : (f = f.next, u.next = f, Xg(a, f)));
  }
  function $f(a, u, f) {
    var p = a.pending;
    if (a.pending = null, p !== null) {
      p = p.next;
      do
        u.status = "rejected", u.reason = f, jg(u), u = u.next;
      while (u !== p);
    }
    a.action = null;
  }
  function jg(a) {
    a = a.listeners;
    for (var u = 0; u < a.length; u++) (0, a[u])();
  }
  function Gg(a, u) {
    return u;
  }
  function Jd(a, u) {
    if (ut) {
      var f = Xt.formState;
      if (f !== null) {
        e: {
          var p = nt;
          if (ut) {
            if (Lt) {
              t: {
                for (var v = Lt, T = wi; v.nodeType !== 8; ) {
                  if (!T) {
                    v = null;
                    break t;
                  }
                  if (v = ba(
                    v.nextSibling
                  ), v === null) {
                    v = null;
                    break t;
                  }
                }
                T = v.data, v = T === "F!" || T === "F" ? v : null;
              }
              if (v) {
                Lt = ba(
                  v.nextSibling
                ), p = v.data === "F!";
                break e;
              }
            }
            sa(p);
          }
          p = !1;
        }
        p && (u = f[0]);
      }
    }
    return f = Ei(), f.memoizedState = f.baseState = u, p = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Gg,
      lastRenderedState: u
    }, f.queue = p, f = tp.bind(
      null,
      nt,
      p
    ), p.dispatch = f, p = Gf(!1), T = Pf.bind(
      null,
      nt,
      !1,
      p.queue
    ), p = Ei(), v = {
      state: u,
      dispatch: null,
      action: a,
      pending: null
    }, p.queue = v, f = Vg.bind(
      null,
      nt,
      v,
      T,
      f
    ), v.dispatch = f, p.memoizedState = a, [u, f, !1];
  }
  function Yg(a) {
    var u = dn();
    return Ha(u, Dt, a);
  }
  function Ha(a, u, f) {
    if (u = Zd(
      a,
      u,
      Gg
    )[0], a = Xf(_a)[0], typeof u == "object" && u !== null && typeof u.then == "function")
      try {
        var p = Br(u);
      } catch (k) {
        throw k === zr ? Zu : k;
      }
    else p = u;
    u = dn();
    var v = u.queue, T = v.dispatch;
    return f !== u.memoizedState && (nt.flags |= 2048, Ts(
      9,
      Ul(),
      $g.bind(null, v, f),
      null
    )), [p, T, a];
  }
  function $g(a, u) {
    a.action = u;
  }
  function ev(a) {
    var u = dn(), f = Dt;
    if (f !== null)
      return Ha(u, f, a);
    dn(), u = u.memoizedState, f = dn();
    var p = f.queue.dispatch;
    return f.memoizedState = a, [u, p, !1];
  }
  function Ts(a, u, f, p) {
    return a = { tag: a, create: f, deps: p, inst: u, next: null }, u = nt.updateQueue, u === null && (u = Vf(), nt.updateQueue = u), f = u.lastEffect, f === null ? u.lastEffect = a.next = a : (p = f.next, f.next = a, a.next = p, u.lastEffect = a), a;
  }
  function Ul() {
    return { destroy: void 0, resource: void 0 };
  }
  function Zg() {
    return dn().memoizedState;
  }
  function qr(a, u, f, p) {
    var v = Ei();
    p = p === void 0 ? null : p, nt.flags |= a, v.memoizedState = Ts(
      1 | u,
      Ul(),
      f,
      p
    );
  }
  function zo(a, u, f, p) {
    var v = dn();
    p = p === void 0 ? null : p;
    var T = v.memoizedState.inst;
    Dt !== null && p !== null && Lf(p, Dt.memoizedState.deps) ? v.memoizedState = Ts(u, T, f, p) : (nt.flags |= a, v.memoizedState = Ts(
      1 | u,
      T,
      f,
      p
    ));
  }
  function Ft(a, u) {
    qr(8390656, 8, a, u);
  }
  function tv(a, u) {
    zo(2048, 8, a, u);
  }
  function nv(a, u) {
    return zo(4, 2, a, u);
  }
  function Pg(a, u) {
    return zo(4, 4, a, u);
  }
  function ca(a, u) {
    if (typeof u == "function") {
      a = a();
      var f = u(a);
      return function() {
        typeof f == "function" ? f() : u(null);
      };
    }
    if (u != null)
      return a = a(), u.current = a, function() {
        u.current = null;
      };
  }
  function Wg(a, u, f) {
    f = f != null ? f.concat([a]) : null, zo(4, 4, ca.bind(null, u, a), f);
  }
  function Zf() {
  }
  function ec(a, u) {
    var f = dn();
    u = u === void 0 ? null : u;
    var p = f.memoizedState;
    return u !== null && Lf(u, p[1]) ? p[0] : (f.memoizedState = [a, u], a);
  }
  function _r(a, u) {
    var f = dn();
    u = u === void 0 ? null : u;
    var p = f.memoizedState;
    if (u !== null && Lf(u, p[1]))
      return p[0];
    if (p = a(), ji) {
      El(!0);
      try {
        a();
      } finally {
        El(!1);
      }
    }
    return f.memoizedState = [p, u], p;
  }
  function Id(a, u, f) {
    return f === void 0 || (ua & 1073741824) !== 0 ? a.memoizedState = u : (a.memoizedState = f, a = vv(), nt.lanes |= a, Ds |= a, f);
  }
  function ep(a, u, f, p) {
    return Ai(f, u) ? f : Mo.current !== null ? (a = Id(a, f, p), Ai(a, u) || (mt = !0), a) : (ua & 42) === 0 ? (mt = !0, a.memoizedState = f) : (a = vv(), nt.lanes |= a, Ds |= a, u);
  }
  function Fg(a, u, f, p, v) {
    var T = Z.p;
    Z.p = T !== 0 && 8 > T ? T : 8;
    var k = F.T, D = {};
    F.T = D, Pf(a, !1, u, f);
    try {
      var q = v(), P = F.S;
      if (P !== null && P(D, q), q !== null && typeof q == "object" && typeof q.then == "function") {
        var ce = kg(
          q,
          p
        );
        tc(
          a,
          u,
          ce,
          gl(a)
        );
      } else
        tc(
          a,
          u,
          p,
          gl(a)
        );
    } catch (de) {
      tc(
        a,
        u,
        { then: function() {
        }, status: "rejected", reason: de },
        gl()
      );
    } finally {
      Z.p = T, F.T = k;
    }
  }
  function fS() {
  }
  function Kg(a, u, f, p) {
    if (a.tag !== 5) throw Error(l(476));
    var v = Jg(a).queue;
    Fg(
      a,
      v,
      u,
      ge,
      f === null ? fS : function() {
        return iv(a), f(p);
      }
    );
  }
  function Jg(a) {
    var u = a.memoizedState;
    if (u !== null) return u;
    u = {
      memoizedState: ge,
      baseState: ge,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: _a,
        lastRenderedState: ge
      },
      next: null
    };
    var f = {};
    return u.next = {
      memoizedState: f,
      baseState: f,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: _a,
        lastRenderedState: f
      },
      next: null
    }, a.memoizedState = u, a = a.alternate, a !== null && (a.memoizedState = u), u;
  }
  function iv(a) {
    var u = Jg(a).next.queue;
    tc(a, u, {}, gl());
  }
  function Hr() {
    return ei(li);
  }
  function fa() {
    return dn().memoizedState;
  }
  function Ig() {
    return dn().memoizedState;
  }
  function hS(a) {
    for (var u = a.return; u !== null; ) {
      switch (u.tag) {
        case 24:
        case 3:
          var f = gl();
          a = Do(f);
          var p = Xi(u, a, f);
          p !== null && (Ji(p, u, f), Qr(p, u, f)), u = { cache: Rg() }, a.payload = u;
          return;
      }
      u = u.return;
    }
  }
  function lv(a, u, f) {
    var p = gl();
    f = {
      lane: p,
      revertLane: 0,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, nc(a) ? Wf(u, f) : (f = kr(a, u, f, p), f !== null && (Ji(f, a, p), av(f, u, p)));
  }
  function tp(a, u, f) {
    var p = gl();
    tc(a, u, f, p);
  }
  function tc(a, u, f, p) {
    var v = {
      lane: p,
      revertLane: 0,
      action: f,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (nc(a)) Wf(u, v);
    else {
      var T = a.alternate;
      if (a.lanes === 0 && (T === null || T.lanes === 0) && (T = u.lastRenderedReducer, T !== null))
        try {
          var k = u.lastRenderedState, D = T(k, f);
          if (v.hasEagerState = !0, v.eagerState = D, Ai(D, k))
            return ia(a, u, v, 0), Xt === null && na(), !1;
        } catch {
        } finally {
        }
      if (f = kr(a, u, v, p), f !== null)
        return Ji(f, a, p), av(f, u, p), !0;
    }
    return !1;
  }
  function Pf(a, u, f, p) {
    if (p = {
      lane: 2,
      revertLane: Cp(),
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, nc(a)) {
      if (u) throw Error(l(479));
    } else
      u = kr(
        a,
        f,
        p,
        2
      ), u !== null && Ji(u, a, 2);
  }
  function nc(a) {
    var u = a.alternate;
    return a === nt || u !== null && u === nt;
  }
  function Wf(a, u) {
    Ur = Nr = !0;
    var f = a.pending;
    f === null ? u.next = u : (u.next = f.next, f.next = u), a.pending = u;
  }
  function av(a, u, f) {
    if ((f & 4194048) !== 0) {
      var p = u.lanes;
      p &= a.pendingLanes, f |= p, u.lanes = f, St(a, f);
    }
  }
  var Ff = {
    readContext: ei,
    use: $d,
    useCallback: un,
    useContext: un,
    useEffect: un,
    useImperativeHandle: un,
    useLayoutEffect: un,
    useInsertionEffect: un,
    useMemo: un,
    useReducer: un,
    useRef: un,
    useState: un,
    useDebugValue: un,
    useDeferredValue: un,
    useTransition: un,
    useSyncExternalStore: un,
    useId: un,
    useHostTransitionStatus: un,
    useFormState: un,
    useActionState: un,
    useOptimistic: un,
    useMemoCache: un,
    useCacheRefresh: un
  }, ov = {
    readContext: ei,
    use: $d,
    useCallback: function(a, u) {
      return Ei().memoizedState = [
        a,
        u === void 0 ? null : u
      ], a;
    },
    useContext: ei,
    useEffect: Ft,
    useImperativeHandle: function(a, u, f) {
      f = f != null ? f.concat([a]) : null, qr(
        4194308,
        4,
        ca.bind(null, u, a),
        f
      );
    },
    useLayoutEffect: function(a, u) {
      return qr(4194308, 4, a, u);
    },
    useInsertionEffect: function(a, u) {
      qr(4, 2, a, u);
    },
    useMemo: function(a, u) {
      var f = Ei();
      u = u === void 0 ? null : u;
      var p = a();
      if (ji) {
        El(!0);
        try {
          a();
        } finally {
          El(!1);
        }
      }
      return f.memoizedState = [p, u], p;
    },
    useReducer: function(a, u, f) {
      var p = Ei();
      if (f !== void 0) {
        var v = f(u);
        if (ji) {
          El(!0);
          try {
            f(u);
          } finally {
            El(!1);
          }
        }
      } else v = u;
      return p.memoizedState = p.baseState = v, a = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: v
      }, p.queue = a, a = a.dispatch = lv.bind(
        null,
        nt,
        a
      ), [p.memoizedState, a];
    },
    useRef: function(a) {
      var u = Ei();
      return a = { current: a }, u.memoizedState = a;
    },
    useState: function(a) {
      a = Gf(a);
      var u = a.queue, f = tp.bind(null, nt, u);
      return u.dispatch = f, [a.memoizedState, f];
    },
    useDebugValue: Zf,
    useDeferredValue: function(a, u) {
      var f = Ei();
      return Id(f, a, u);
    },
    useTransition: function() {
      var a = Gf(!1);
      return a = Fg.bind(
        null,
        nt,
        a.queue,
        !0,
        !1
      ), Ei().memoizedState = a, [!1, a];
    },
    useSyncExternalStore: function(a, u, f) {
      var p = nt, v = Ei();
      if (ut) {
        if (f === void 0)
          throw Error(l(407));
        f = f();
      } else {
        if (f = u(), Xt === null)
          throw Error(l(349));
        (xt & 124) !== 0 || jf(p, u, f);
      }
      v.memoizedState = f;
      var T = { value: f, getSnapshot: u };
      return v.queue = T, Ft(_g.bind(null, p, T, a), [
        a
      ]), p.flags |= 2048, Ts(
        9,
        Ul(),
        Wd.bind(
          null,
          p,
          T,
          f,
          u
        ),
        null
      ), f;
    },
    useId: function() {
      var a = Ei(), u = Xt.identifierPrefix;
      if (ut) {
        var f = oa, p = aa;
        f = (p & ~(1 << 32 - Fn(p) - 1)).toString(32) + f, u = "" + u + "R" + f, f = Hf++, 0 < f && (u += "H" + f.toString(32)), u += "";
      } else
        f = Xd++, u = "" + u + "r" + f.toString(32) + "";
      return a.memoizedState = u;
    },
    useHostTransitionStatus: Hr,
    useFormState: Jd,
    useActionState: Jd,
    useOptimistic: function(a) {
      var u = Ei();
      u.memoizedState = u.baseState = a;
      var f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return u.queue = f, u = Pf.bind(
        null,
        nt,
        !0,
        f
      ), f.dispatch = u, [a, u];
    },
    useMemoCache: Dn,
    useCacheRefresh: function() {
      return Ei().memoizedState = hS.bind(
        null,
        nt
      );
    }
  }, e0 = {
    readContext: ei,
    use: $d,
    useCallback: ec,
    useContext: ei,
    useEffect: tv,
    useImperativeHandle: Wg,
    useInsertionEffect: nv,
    useLayoutEffect: Pg,
    useMemo: _r,
    useReducer: Xf,
    useRef: Zg,
    useState: function() {
      return Xf(_a);
    },
    useDebugValue: Zf,
    useDeferredValue: function(a, u) {
      var f = dn();
      return ep(
        f,
        Dt.memoizedState,
        a,
        u
      );
    },
    useTransition: function() {
      var a = Xf(_a)[0], u = dn().memoizedState;
      return [
        typeof a == "boolean" ? a : Br(a),
        u
      ];
    },
    useSyncExternalStore: qg,
    useId: fa,
    useHostTransitionStatus: Hr,
    useFormState: Yg,
    useActionState: Yg,
    useOptimistic: function(a, u) {
      var f = dn();
      return Fd(f, Dt, a, u);
    },
    useMemoCache: Dn,
    useCacheRefresh: Ig
  }, sv = {
    readContext: ei,
    use: $d,
    useCallback: ec,
    useContext: ei,
    useEffect: tv,
    useImperativeHandle: Wg,
    useInsertionEffect: nv,
    useLayoutEffect: Pg,
    useMemo: _r,
    useReducer: Pd,
    useRef: Zg,
    useState: function() {
      return Pd(_a);
    },
    useDebugValue: Zf,
    useDeferredValue: function(a, u) {
      var f = dn();
      return Dt === null ? Id(f, a, u) : ep(
        f,
        Dt.memoizedState,
        a,
        u
      );
    },
    useTransition: function() {
      var a = Pd(_a)[0], u = dn().memoizedState;
      return [
        typeof a == "boolean" ? a : Br(a),
        u
      ];
    },
    useSyncExternalStore: qg,
    useId: fa,
    useHostTransitionStatus: Hr,
    useFormState: ev,
    useActionState: ev,
    useOptimistic: function(a, u) {
      var f = dn();
      return Dt !== null ? Fd(f, Dt, a, u) : (f.baseState = a, [a, f.queue.dispatch]);
    },
    useMemoCache: Dn,
    useCacheRefresh: Ig
  }, Yi = null, ic = 0;
  function Kf(a) {
    var u = ic;
    return ic += 1, Yi === null && (Yi = []), zg(Yi, a, u);
  }
  function Jf(a, u) {
    u = u.props.ref, a.ref = u !== void 0 ? u : null;
  }
  function lc(a, u) {
    throw u.$$typeof === A ? Error(l(525)) : (a = Object.prototype.toString.call(u), Error(
      l(
        31,
        a === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : a
      )
    ));
  }
  function $i(a) {
    var u = a._init;
    return u(a._payload);
  }
  function t0(a) {
    function u($, j) {
      if (a) {
        var W = $.deletions;
        W === null ? ($.deletions = [j], $.flags |= 16) : W.push(j);
      }
    }
    function f($, j) {
      if (!a) return null;
      for (; j !== null; )
        u($, j), j = j.sibling;
      return null;
    }
    function p($) {
      for (var j = /* @__PURE__ */ new Map(); $ !== null; )
        $.key !== null ? j.set($.key, $) : j.set($.index, $), $ = $.sibling;
      return j;
    }
    function v($, j) {
      return $ = la($, j), $.index = 0, $.sibling = null, $;
    }
    function T($, j, W) {
      return $.index = W, a ? (W = $.alternate, W !== null ? (W = W.index, W < j ? ($.flags |= 67108866, j) : W) : ($.flags |= 67108866, j)) : ($.flags |= 1048576, j);
    }
    function k($) {
      return a && $.alternate === null && ($.flags |= 67108866), $;
    }
    function D($, j, W, he) {
      return j === null || j.tag !== 6 ? (j = gs(W, $.mode, he), j.return = $, j) : (j = v(j, W), j.return = $, j);
    }
    function q($, j, W, he) {
      var Ue = W.type;
      return Ue === z ? ce(
        $,
        j,
        W.props.children,
        he,
        W.key
      ) : j !== null && (j.elementType === Ue || typeof Ue == "object" && Ue !== null && Ue.$$typeof === we && $i(Ue) === j.type) ? (j = v(j, W.props), Jf(j, W), j.return = $, j) : (j = rt(
        W.type,
        W.key,
        W.props,
        null,
        $.mode,
        he
      ), Jf(j, W), j.return = $, j);
    }
    function P($, j, W, he) {
      return j === null || j.tag !== 4 || j.stateNode.containerInfo !== W.containerInfo || j.stateNode.implementation !== W.implementation ? (j = qu(W, $.mode, he), j.return = $, j) : (j = v(j, W.children || []), j.return = $, j);
    }
    function ce($, j, W, he, Ue) {
      return j === null || j.tag !== 7 ? (j = be(
        W,
        $.mode,
        he,
        Ue
      ), j.return = $, j) : (j = v(j, W), j.return = $, j);
    }
    function de($, j, W) {
      if (typeof j == "string" && j !== "" || typeof j == "number" || typeof j == "bigint")
        return j = gs(
          "" + j,
          $.mode,
          W
        ), j.return = $, j;
      if (typeof j == "object" && j !== null) {
        switch (j.$$typeof) {
          case w:
            return W = rt(
              j.type,
              j.key,
              j.props,
              null,
              $.mode,
              W
            ), Jf(W, j), W.return = $, W;
          case E:
            return j = qu(
              j,
              $.mode,
              W
            ), j.return = $, j;
          case we:
            var he = j._init;
            return j = he(j._payload), de($, j, W);
        }
        if (Xe(j) || fe(j))
          return j = be(
            j,
            $.mode,
            W,
            null
          ), j.return = $, j;
        if (typeof j.then == "function")
          return de($, Kf(j), W);
        if (j.$$typeof === me)
          return de(
            $,
            Xu($, j),
            W
          );
        lc($, j);
      }
      return null;
    }
    function K($, j, W, he) {
      var Ue = j !== null ? j.key : null;
      if (typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint")
        return Ue !== null ? null : D($, j, "" + W, he);
      if (typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case w:
            return W.key === Ue ? q($, j, W, he) : null;
          case E:
            return W.key === Ue ? P($, j, W, he) : null;
          case we:
            return Ue = W._init, W = Ue(W._payload), K($, j, W, he);
        }
        if (Xe(W) || fe(W))
          return Ue !== null ? null : ce($, j, W, he, null);
        if (typeof W.then == "function")
          return K(
            $,
            j,
            Kf(W),
            he
          );
        if (W.$$typeof === me)
          return K(
            $,
            j,
            Xu($, W),
            he
          );
        lc($, W);
      }
      return null;
    }
    function te($, j, W, he, Ue) {
      if (typeof he == "string" && he !== "" || typeof he == "number" || typeof he == "bigint")
        return $ = $.get(W) || null, D(j, $, "" + he, Ue);
      if (typeof he == "object" && he !== null) {
        switch (he.$$typeof) {
          case w:
            return $ = $.get(
              he.key === null ? W : he.key
            ) || null, q(j, $, he, Ue);
          case E:
            return $ = $.get(
              he.key === null ? W : he.key
            ) || null, P(j, $, he, Ue);
          case we:
            var ct = he._init;
            return he = ct(he._payload), te(
              $,
              j,
              W,
              he,
              Ue
            );
        }
        if (Xe(he) || fe(he))
          return $ = $.get(W) || null, ce(j, $, he, Ue, null);
        if (typeof he.then == "function")
          return te(
            $,
            j,
            W,
            Kf(he),
            Ue
          );
        if (he.$$typeof === me)
          return te(
            $,
            j,
            W,
            Xu(j, he),
            Ue
          );
        lc(j, he);
      }
      return null;
    }
    function Pe($, j, W, he) {
      for (var Ue = null, ct = null, Ye = j, We = j = 0, jn = null; Ye !== null && We < W.length; We++) {
        Ye.index > We ? (jn = Ye, Ye = null) : jn = Ye.sibling;
        var Ct = K(
          $,
          Ye,
          W[We],
          he
        );
        if (Ct === null) {
          Ye === null && (Ye = jn);
          break;
        }
        a && Ye && Ct.alternate === null && u($, Ye), j = T(Ct, j, We), ct === null ? Ue = Ct : ct.sibling = Ct, ct = Ct, Ye = jn;
      }
      if (We === W.length)
        return f($, Ye), ut && Tn($, We), Ue;
      if (Ye === null) {
        for (; We < W.length; We++)
          Ye = de($, W[We], he), Ye !== null && (j = T(
            Ye,
            j,
            We
          ), ct === null ? Ue = Ye : ct.sibling = Ye, ct = Ye);
        return ut && Tn($, We), Ue;
      }
      for (Ye = p(Ye); We < W.length; We++)
        jn = te(
          Ye,
          $,
          We,
          W[We],
          he
        ), jn !== null && (a && jn.alternate !== null && Ye.delete(
          jn.key === null ? We : jn.key
        ), j = T(
          jn,
          j,
          We
        ), ct === null ? Ue = jn : ct.sibling = jn, ct = jn);
      return a && Ye.forEach(function(Pa) {
        return u($, Pa);
      }), ut && Tn($, We), Ue;
    }
    function $e($, j, W, he) {
      if (W == null) throw Error(l(151));
      for (var Ue = null, ct = null, Ye = j, We = j = 0, jn = null, Ct = W.next(); Ye !== null && !Ct.done; We++, Ct = W.next()) {
        Ye.index > We ? (jn = Ye, Ye = null) : jn = Ye.sibling;
        var Pa = K($, Ye, Ct.value, he);
        if (Pa === null) {
          Ye === null && (Ye = jn);
          break;
        }
        a && Ye && Pa.alternate === null && u($, Ye), j = T(Pa, j, We), ct === null ? Ue = Pa : ct.sibling = Pa, ct = Pa, Ye = jn;
      }
      if (Ct.done)
        return f($, Ye), ut && Tn($, We), Ue;
      if (Ye === null) {
        for (; !Ct.done; We++, Ct = W.next())
          Ct = de($, Ct.value, he), Ct !== null && (j = T(Ct, j, We), ct === null ? Ue = Ct : ct.sibling = Ct, ct = Ct);
        return ut && Tn($, We), Ue;
      }
      for (Ye = p(Ye); !Ct.done; We++, Ct = W.next())
        Ct = te(Ye, $, We, Ct.value, he), Ct !== null && (a && Ct.alternate !== null && Ye.delete(Ct.key === null ? We : Ct.key), j = T(Ct, j, We), ct === null ? Ue = Ct : ct.sibling = Ct, ct = Ct);
      return a && Ye.forEach(function(TS) {
        return u($, TS);
      }), ut && Tn($, We), Ue;
    }
    function zt($, j, W, he) {
      if (typeof W == "object" && W !== null && W.type === z && W.key === null && (W = W.props.children), typeof W == "object" && W !== null) {
        switch (W.$$typeof) {
          case w:
            e: {
              for (var Ue = W.key; j !== null; ) {
                if (j.key === Ue) {
                  if (Ue = W.type, Ue === z) {
                    if (j.tag === 7) {
                      f(
                        $,
                        j.sibling
                      ), he = v(
                        j,
                        W.props.children
                      ), he.return = $, $ = he;
                      break e;
                    }
                  } else if (j.elementType === Ue || typeof Ue == "object" && Ue !== null && Ue.$$typeof === we && $i(Ue) === j.type) {
                    f(
                      $,
                      j.sibling
                    ), he = v(j, W.props), Jf(he, W), he.return = $, $ = he;
                    break e;
                  }
                  f($, j);
                  break;
                } else u($, j);
                j = j.sibling;
              }
              W.type === z ? (he = be(
                W.props.children,
                $.mode,
                he,
                W.key
              ), he.return = $, $ = he) : (he = rt(
                W.type,
                W.key,
                W.props,
                null,
                $.mode,
                he
              ), Jf(he, W), he.return = $, $ = he);
            }
            return k($);
          case E:
            e: {
              for (Ue = W.key; j !== null; ) {
                if (j.key === Ue)
                  if (j.tag === 4 && j.stateNode.containerInfo === W.containerInfo && j.stateNode.implementation === W.implementation) {
                    f(
                      $,
                      j.sibling
                    ), he = v(j, W.children || []), he.return = $, $ = he;
                    break e;
                  } else {
                    f($, j);
                    break;
                  }
                else u($, j);
                j = j.sibling;
              }
              he = qu(W, $.mode, he), he.return = $, $ = he;
            }
            return k($);
          case we:
            return Ue = W._init, W = Ue(W._payload), zt(
              $,
              j,
              W,
              he
            );
        }
        if (Xe(W))
          return Pe(
            $,
            j,
            W,
            he
          );
        if (fe(W)) {
          if (Ue = fe(W), typeof Ue != "function") throw Error(l(150));
          return W = Ue.call(W), $e(
            $,
            j,
            W,
            he
          );
        }
        if (typeof W.then == "function")
          return zt(
            $,
            j,
            Kf(W),
            he
          );
        if (W.$$typeof === me)
          return zt(
            $,
            j,
            Xu($, W),
            he
          );
        lc($, W);
      }
      return typeof W == "string" && W !== "" || typeof W == "number" || typeof W == "bigint" ? (W = "" + W, j !== null && j.tag === 6 ? (f($, j.sibling), he = v(j, W), he.return = $, $ = he) : (f($, j), he = gs(W, $.mode, he), he.return = $, $ = he), k($)) : f($, j);
    }
    return function($, j, W, he) {
      try {
        ic = 0;
        var Ue = zt(
          $,
          j,
          W,
          he
        );
        return Yi = null, Ue;
      } catch (Ye) {
        if (Ye === zr || Ye === Zu) throw Ye;
        var ct = Hi(29, Ye, null, $.mode);
        return ct.lanes = he, ct.return = $, ct;
      } finally {
      }
    };
  }
  var _n = t0(!0), n0 = t0(!1), An = L(null), ha = null;
  function Zi(a) {
    var u = a.alternate;
    le(vn, vn.current & 1), le(An, a), ha === null && (u === null || Mo.current !== null || u.memoizedState !== null) && (ha = a);
  }
  function i0(a) {
    if (a.tag === 22) {
      if (le(vn, vn.current), le(An, a), ha === null) {
        var u = a.alternate;
        u !== null && u.memoizedState !== null && (ha = a);
      }
    } else pi();
  }
  function pi() {
    le(vn, vn.current), le(An, An.current);
  }
  function da(a) {
    se(An), ha === a && (ha = null), se(vn);
  }
  var vn = L(0);
  function hl(a) {
    for (var u = a; u !== null; ) {
      if (u.tag === 13) {
        var f = u.memoizedState;
        if (f !== null && (f = f.dehydrated, f === null || f.data === "$?" || j0(f)))
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if ((u.flags & 128) !== 0) return u;
      } else if (u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === a) break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === a) return null;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
    return null;
  }
  function np(a, u, f, p) {
    u = a.memoizedState, f = f(p, u), f = f == null ? u : S({}, u, f), a.memoizedState = f, a.lanes === 0 && (a.updateQueue.baseState = f);
  }
  var xs = {
    enqueueSetState: function(a, u, f) {
      a = a._reactInternals;
      var p = gl(), v = Do(p);
      v.payload = u, f != null && (v.callback = f), u = Xi(a, v, p), u !== null && (Ji(u, a, p), Qr(u, a, p));
    },
    enqueueReplaceState: function(a, u, f) {
      a = a._reactInternals;
      var p = gl(), v = Do(p);
      v.tag = 1, v.payload = u, f != null && (v.callback = f), u = Xi(a, v, p), u !== null && (Ji(u, a, p), Qr(u, a, p));
    },
    enqueueForceUpdate: function(a, u) {
      a = a._reactInternals;
      var f = gl(), p = Do(f);
      p.tag = 2, u != null && (p.callback = u), u = Xi(a, p, f), u !== null && (Ji(u, a, f), Qr(u, a, f));
    }
  };
  function l0(a, u, f, p, v, T, k) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(p, T, k) : u.prototype && u.prototype.isPureReactComponent ? !To(f, p) || !To(v, T) : !0;
  }
  function ac(a, u, f, p) {
    a = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(f, p), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(f, p), u.state !== a && xs.enqueueReplaceState(u, u.state, null);
  }
  function Bl(a, u) {
    var f = u;
    if ("ref" in u) {
      f = {};
      for (var p in u)
        p !== "ref" && (f[p] = u[p]);
    }
    if (a = a.defaultProps) {
      f === u && (f = S({}, f));
      for (var v in a)
        f[v] === void 0 && (f[v] = a[v]);
    }
    return f;
  }
  var If = typeof reportError == "function" ? reportError : function(a) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var u = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof a == "object" && a !== null && typeof a.message == "string" ? String(a.message) : String(a),
        error: a
      });
      if (!window.dispatchEvent(u)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", a);
      return;
    }
    console.error(a);
  };
  function a0(a) {
    If(a);
  }
  function oc(a) {
    console.error(a);
  }
  function o0(a) {
    If(a);
  }
  function Lr(a, u) {
    try {
      var f = a.onUncaughtError;
      f(u.value, { componentStack: u.stack });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function s0(a, u, f) {
    try {
      var p = a.onCaughtError;
      p(f.value, {
        componentStack: f.stack,
        errorBoundary: u.tag === 1 ? u.stateNode : null
      });
    } catch (v) {
      setTimeout(function() {
        throw v;
      });
    }
  }
  function ip(a, u, f) {
    return f = Do(f), f.tag = 3, f.payload = { element: null }, f.callback = function() {
      Lr(a, u);
    }, f;
  }
  function rv(a) {
    return a = Do(a), a.tag = 3, a;
  }
  function r0(a, u, f, p) {
    var v = f.type.getDerivedStateFromError;
    if (typeof v == "function") {
      var T = p.value;
      a.payload = function() {
        return v(T);
      }, a.callback = function() {
        s0(u, f, p);
      };
    }
    var k = f.stateNode;
    k !== null && typeof k.componentDidCatch == "function" && (a.callback = function() {
      s0(u, f, p), typeof v != "function" && (La === null ? La = /* @__PURE__ */ new Set([this]) : La.add(this));
      var D = p.stack;
      this.componentDidCatch(p.value, {
        componentStack: D !== null ? D : ""
      });
    });
  }
  function dl(a, u, f, p, v) {
    if (f.flags |= 32768, p !== null && typeof p == "object" && typeof p.then == "function") {
      if (u = f.alternate, u !== null && Df(
        u,
        f,
        v,
        !0
      ), f = An.current, f !== null) {
        switch (f.tag) {
          case 13:
            return ha === null ? Ns() : f.alternate === null && mn === 0 && (mn = 3), f.flags &= -257, f.flags |= 65536, f.lanes = v, p === _d ? f.flags |= 16384 : (u = f.updateQueue, u === null ? f.updateQueue = /* @__PURE__ */ new Set([p]) : u.add(p), sh(a, p, v)), !1;
          case 22:
            return f.flags |= 65536, p === _d ? f.flags |= 16384 : (u = f.updateQueue, u === null ? (u = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([p])
            }, f.updateQueue = u) : (f = u.retryQueue, f === null ? u.retryQueue = /* @__PURE__ */ new Set([p]) : f.add(p)), sh(a, p, v)), !1;
        }
        throw Error(l(435, f.tag));
      }
      return sh(a, p, v), Ns(), !1;
    }
    if (ut)
      return u = An.current, u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256), u.flags |= 65536, u.lanes = v, p !== Rf && (a = Error(l(422), { cause: p }), Vu(cl(a, f)))) : (p !== Rf && (u = Error(l(423), {
        cause: p
      }), Vu(
        cl(u, f)
      )), a = a.current.alternate, a.flags |= 65536, v &= -v, a.lanes |= v, p = cl(p, f), v = ip(
        a.stateNode,
        p,
        v
      ), Bf(a, v), mn !== 4 && (mn = 2)), !1;
    var T = Error(l(520), { cause: p });
    if (T = cl(T, f), lh === null ? lh = [T] : lh.push(T), mn !== 4 && (mn = 2), u === null) return !0;
    p = cl(p, f), f = u;
    do {
      switch (f.tag) {
        case 3:
          return f.flags |= 65536, a = v & -v, f.lanes |= a, a = ip(f.stateNode, p, a), Bf(f, a), !1;
        case 1:
          if (u = f.type, T = f.stateNode, (f.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (La === null || !La.has(T))))
            return f.flags |= 65536, v &= -v, f.lanes |= v, v = rv(v), r0(
              v,
              a,
              f,
              p
            ), Bf(f, v), !1;
      }
      f = f.return;
    } while (f !== null);
    return !1;
  }
  var u0 = Error(l(461)), mt = !1;
  function Hn(a, u, f, p) {
    u.child = a === null ? n0(u, null, f, p) : _n(
      u,
      a.child,
      f,
      p
    );
  }
  function c0(a, u, f, p, v) {
    f = f.render;
    var T = u.ref;
    if ("ref" in p) {
      var k = {};
      for (var D in p)
        D !== "ref" && (k[D] = p[D]);
    } else k = p;
    return Os(u), p = jd(
      a,
      u,
      f,
      k,
      T,
      v
    ), D = Gd(), a !== null && !mt ? (Yd(a, u, v), pa(a, u, v)) : (ut && D && Cf(u), u.flags |= 1, Hn(a, u, p, v), u.child);
  }
  function uv(a, u, f, p, v) {
    if (a === null) {
      var T = f.type;
      return typeof T == "function" && !Md(T) && T.defaultProps === void 0 && f.compare === null ? (u.tag = 15, u.type = T, Qo(
        a,
        u,
        T,
        p,
        v
      )) : (a = rt(
        f.type,
        null,
        p,
        u,
        u.mode,
        v
      ), a.ref = u.ref, a.return = u, u.child = a);
    }
    if (T = a.child, !up(a, v)) {
      var k = T.memoizedProps;
      if (f = f.compare, f = f !== null ? f : To, f(k, p) && a.ref === u.ref)
        return pa(a, u, v);
    }
    return u.flags |= 1, a = la(T, p), a.ref = u.ref, a.return = u, u.child = a;
  }
  function Qo(a, u, f, p, v) {
    if (a !== null) {
      var T = a.memoizedProps;
      if (To(T, p) && a.ref === u.ref)
        if (mt = !1, u.pendingProps = p = T, up(a, v))
          (a.flags & 131072) !== 0 && (mt = !0);
        else
          return u.lanes = a.lanes, pa(a, u, v);
    }
    return ap(
      a,
      u,
      f,
      p,
      v
    );
  }
  function Vr(a, u, f) {
    var p = u.pendingProps, v = p.children, T = a !== null ? a.memoizedState : null;
    if (p.mode === "hidden") {
      if ((u.flags & 128) !== 0) {
        if (p = T !== null ? T.baseLanes | f : f, a !== null) {
          for (v = u.child = a.child, T = 0; v !== null; )
            T = T | v.lanes | v.childLanes, v = v.sibling;
          u.childLanes = T & ~p;
        } else u.childLanes = 0, u.child = null;
        return lp(
          a,
          u,
          p,
          f
        );
      }
      if ((f & 536870912) !== 0)
        u.memoizedState = { baseLanes: 0, cachePool: null }, a !== null && $u(
          u,
          T !== null ? T.cachePool : null
        ), T !== null ? Ug(u, T) : kn(), i0(u);
      else
        return u.lanes = u.childLanes = 536870912, lp(
          a,
          u,
          T !== null ? T.baseLanes | f : f,
          f
        );
    } else
      T !== null ? ($u(u, T.cachePool), Ug(u, T), pi(), u.memoizedState = null) : (a !== null && $u(u, null), kn(), pi());
    return Hn(a, u, v, f), u.child;
  }
  function lp(a, u, f, p) {
    var v = Yu();
    return v = v === null ? null : { parent: xn._currentValue, pool: v }, u.memoizedState = {
      baseLanes: f,
      cachePool: v
    }, a !== null && $u(u, null), kn(), i0(u), a !== null && Df(a, u, p, !0), null;
  }
  function No(a, u) {
    var f = u.ref;
    if (f === null)
      a !== null && a.ref !== null && (u.flags |= 4194816);
    else {
      if (typeof f != "function" && typeof f != "object")
        throw Error(l(284));
      (a === null || a.ref !== f) && (u.flags |= 4194816);
    }
  }
  function ap(a, u, f, p, v) {
    return Os(u), f = jd(
      a,
      u,
      f,
      p,
      void 0,
      v
    ), p = Gd(), a !== null && !mt ? (Yd(a, u, v), pa(a, u, v)) : (ut && p && Cf(u), u.flags |= 1, Hn(a, u, f, v), u.child);
  }
  function f0(a, u, f, p, v, T) {
    return Os(u), u.updateQueue = null, f = Ss(
      u,
      p,
      f,
      v
    ), Bg(a), p = Gd(), a !== null && !mt ? (Yd(a, u, T), pa(a, u, T)) : (ut && p && Cf(u), u.flags |= 1, Hn(a, u, f, T), u.child);
  }
  function h0(a, u, f, p, v) {
    if (Os(u), u.stateNode === null) {
      var T = Dr, k = f.contextType;
      typeof k == "object" && k !== null && (T = ei(k)), T = new f(p, T), u.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null, T.updater = xs, u.stateNode = T, T._reactInternals = u, T = u.stateNode, T.props = p, T.state = u.memoizedState, T.refs = {}, Uf(u), k = f.contextType, T.context = typeof k == "object" && k !== null ? ei(k) : Dr, T.state = u.memoizedState, k = f.getDerivedStateFromProps, typeof k == "function" && (np(
        u,
        f,
        k,
        p
      ), T.state = u.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof T.getSnapshotBeforeUpdate == "function" || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (k = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), k !== T.state && xs.enqueueReplaceState(T, T.state, null), Fu(u, p, T, v), qf(), T.state = u.memoizedState), typeof T.componentDidMount == "function" && (u.flags |= 4194308), p = !0;
    } else if (a === null) {
      T = u.stateNode;
      var D = u.memoizedProps, q = Bl(f, D);
      T.props = q;
      var P = T.context, ce = f.contextType;
      k = Dr, typeof ce == "object" && ce !== null && (k = ei(ce));
      var de = f.getDerivedStateFromProps;
      ce = typeof de == "function" || typeof T.getSnapshotBeforeUpdate == "function", D = u.pendingProps !== D, ce || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (D || P !== k) && ac(
        u,
        T,
        p,
        k
      ), ko = !1;
      var K = u.memoizedState;
      T.state = K, Fu(u, p, T, v), qf(), P = u.memoizedState, D || K !== P || ko ? (typeof de == "function" && (np(
        u,
        f,
        de,
        p
      ), P = u.memoizedState), (q = ko || l0(
        u,
        f,
        q,
        p,
        K,
        P,
        k
      )) ? (ce || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof T.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = p, u.memoizedState = P), T.props = p, T.state = P, T.context = k, p = q) : (typeof T.componentDidMount == "function" && (u.flags |= 4194308), p = !1);
    } else {
      T = u.stateNode, Ld(a, u), k = u.memoizedProps, ce = Bl(f, k), T.props = ce, de = u.pendingProps, K = T.context, P = f.contextType, q = Dr, typeof P == "object" && P !== null && (q = ei(P)), D = f.getDerivedStateFromProps, (P = typeof D == "function" || typeof T.getSnapshotBeforeUpdate == "function") || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (k !== de || K !== q) && ac(
        u,
        T,
        p,
        q
      ), ko = !1, K = u.memoizedState, T.state = K, Fu(u, p, T, v), qf();
      var te = u.memoizedState;
      k !== de || K !== te || ko || a !== null && a.dependencies !== null && Mf(a.dependencies) ? (typeof D == "function" && (np(
        u,
        f,
        D,
        p
      ), te = u.memoizedState), (ce = ko || l0(
        u,
        f,
        ce,
        p,
        K,
        te,
        q
      ) || a !== null && a.dependencies !== null && Mf(a.dependencies)) ? (P || typeof T.UNSAFE_componentWillUpdate != "function" && typeof T.componentWillUpdate != "function" || (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(p, te, q), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(
        p,
        te,
        q
      )), typeof T.componentDidUpdate == "function" && (u.flags |= 4), typeof T.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof T.componentDidUpdate != "function" || k === a.memoizedProps && K === a.memoizedState || (u.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || k === a.memoizedProps && K === a.memoizedState || (u.flags |= 1024), u.memoizedProps = p, u.memoizedState = te), T.props = p, T.state = te, T.context = q, p = ce) : (typeof T.componentDidUpdate != "function" || k === a.memoizedProps && K === a.memoizedState || (u.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || k === a.memoizedProps && K === a.memoizedState || (u.flags |= 1024), p = !1);
    }
    return T = p, No(a, u), p = (u.flags & 128) !== 0, T || p ? (T = u.stateNode, f = p && typeof f.getDerivedStateFromError != "function" ? null : T.render(), u.flags |= 1, a !== null && p ? (u.child = _n(
      u,
      a.child,
      null,
      v
    ), u.child = _n(
      u,
      null,
      f,
      v
    )) : Hn(a, u, f, v), u.memoizedState = T.state, a = u.child) : a = pa(
      a,
      u,
      v
    ), a;
  }
  function op(a, u, f, p) {
    return Lu(), u.flags |= 256, Hn(a, u, f, p), u.child;
  }
  var eh = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function sp(a) {
    return { baseLanes: a, cachePool: Qf() };
  }
  function d0(a, u, f) {
    return a = a !== null ? a.childLanes & ~f : 0, u && (a |= Mn), a;
  }
  function cv(a, u, f) {
    var p = u.pendingProps, v = !1, T = (u.flags & 128) !== 0, k;
    if ((k = T) || (k = a !== null && a.memoizedState === null ? !1 : (vn.current & 2) !== 0), k && (v = !0, u.flags &= -129), k = (u.flags & 32) !== 0, u.flags &= -33, a === null) {
      if (ut) {
        if (v ? Zi(u) : pi(), ut) {
          var D = Lt, q;
          if (q = D) {
            e: {
              for (q = D, D = wi; q.nodeType !== 8; ) {
                if (!D) {
                  D = null;
                  break e;
                }
                if (q = ba(
                  q.nextSibling
                ), q === null) {
                  D = null;
                  break e;
                }
              }
              D = q;
            }
            D !== null ? (u.memoizedState = {
              dehydrated: D,
              treeContext: wo !== null ? { id: aa, overflow: oa } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, q = Hi(
              18,
              null,
              null,
              0
            ), q.stateNode = D, q.return = u, u.child = q, hn = u, Lt = null, q = !0) : q = !1;
          }
          q || sa(u);
        }
        if (D = u.memoizedState, D !== null && (D = D.dehydrated, D !== null))
          return j0(D) ? u.lanes = 32 : u.lanes = 536870912, null;
        da(u);
      }
      return D = p.children, p = p.fallback, v ? (pi(), v = u.mode, D = th(
        { mode: "hidden", children: D },
        v
      ), p = be(
        p,
        v,
        f,
        null
      ), D.return = u, p.return = u, D.sibling = p, u.child = D, v = u.child, v.memoizedState = sp(f), v.childLanes = d0(
        a,
        k,
        f
      ), u.memoizedState = eh, p) : (Zi(u), rp(u, D));
    }
    if (q = a.memoizedState, q !== null && (D = q.dehydrated, D !== null)) {
      if (T)
        u.flags & 256 ? (Zi(u), u.flags &= -257, u = p0(
          a,
          u,
          f
        )) : u.memoizedState !== null ? (pi(), u.child = a.child, u.flags |= 128, u = null) : (pi(), v = p.fallback, D = u.mode, p = th(
          { mode: "visible", children: p.children },
          D
        ), v = be(
          v,
          D,
          f,
          null
        ), v.flags |= 2, p.return = u, v.return = u, p.sibling = v, u.child = p, _n(
          u,
          a.child,
          null,
          f
        ), p = u.child, p.memoizedState = sp(f), p.childLanes = d0(
          a,
          k,
          f
        ), u.memoizedState = eh, u = v);
      else if (Zi(u), j0(D)) {
        if (k = D.nextSibling && D.nextSibling.dataset, k) var P = k.dgst;
        k = P, p = Error(l(419)), p.stack = "", p.digest = k, Vu({ value: p, source: null, stack: null }), u = p0(
          a,
          u,
          f
        );
      } else if (mt || Df(a, u, f, !1), k = (f & a.childLanes) !== 0, mt || k) {
        if (k = Xt, k !== null && (p = f & -f, p = (p & 42) !== 0 ? 1 : Je(p), p = (p & (k.suspendedLanes | f)) !== 0 ? 0 : p, p !== 0 && p !== q.retryLane))
          throw q.retryLane = p, Ao(a, p), Ji(k, a, p), u0;
        D.data === "$?" || Ns(), u = p0(
          a,
          u,
          f
        );
      } else
        D.data === "$?" ? (u.flags |= 192, u.child = a.child, u = null) : (a = q.treeContext, Lt = ba(
          D.nextSibling
        ), hn = u, ut = !0, Eo = null, wi = !1, a !== null && (Li[zl++] = aa, Li[zl++] = oa, Li[zl++] = wo, aa = a.id, oa = a.overflow, wo = u), u = rp(
          u,
          p.children
        ), u.flags |= 4096);
      return u;
    }
    return v ? (pi(), v = p.fallback, D = u.mode, q = a.child, P = q.sibling, p = la(q, {
      mode: "hidden",
      children: p.children
    }), p.subtreeFlags = q.subtreeFlags & 65011712, P !== null ? v = la(P, v) : (v = be(
      v,
      D,
      f,
      null
    ), v.flags |= 2), v.return = u, p.return = u, p.sibling = v, u.child = p, p = v, v = u.child, D = a.child.memoizedState, D === null ? D = sp(f) : (q = D.cachePool, q !== null ? (P = xn._currentValue, q = q.parent !== P ? { parent: P, pool: P } : q) : q = Qf(), D = {
      baseLanes: D.baseLanes | f,
      cachePool: q
    }), v.memoizedState = D, v.childLanes = d0(
      a,
      k,
      f
    ), u.memoizedState = eh, p) : (Zi(u), f = a.child, a = f.sibling, f = la(f, {
      mode: "visible",
      children: p.children
    }), f.return = u, f.sibling = null, a !== null && (k = u.deletions, k === null ? (u.deletions = [a], u.flags |= 16) : k.push(a)), u.child = f, u.memoizedState = null, f);
  }
  function rp(a, u) {
    return u = th(
      { mode: "visible", children: u },
      a.mode
    ), u.return = a, a.child = u;
  }
  function th(a, u) {
    return a = Hi(22, a, null, u), a.lanes = 0, a.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, a;
  }
  function p0(a, u, f) {
    return _n(u, a.child, null, f), a = rp(
      u,
      u.pendingProps.children
    ), a.flags |= 2, u.memoizedState = null, a;
  }
  function Xr(a, u, f) {
    a.lanes |= u;
    var p = a.alternate;
    p !== null && (p.lanes |= u), Ud(a.return, u, f);
  }
  function sc(a, u, f, p, v) {
    var T = a.memoizedState;
    T === null ? a.memoizedState = {
      isBackwards: u,
      rendering: null,
      renderingStartTime: 0,
      last: p,
      tail: f,
      tailMode: v
    } : (T.isBackwards = u, T.rendering = null, T.renderingStartTime = 0, T.last = p, T.tail = f, T.tailMode = v);
  }
  function m0(a, u, f) {
    var p = u.pendingProps, v = p.revealOrder, T = p.tail;
    if (Hn(a, u, p.children, f), p = vn.current, (p & 2) !== 0)
      p = p & 1 | 2, u.flags |= 128;
    else {
      if (a !== null && (a.flags & 128) !== 0)
        e: for (a = u.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && Xr(a, f, u);
          else if (a.tag === 19)
            Xr(a, f, u);
          else if (a.child !== null) {
            a.child.return = a, a = a.child;
            continue;
          }
          if (a === u) break e;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === u)
              break e;
            a = a.return;
          }
          a.sibling.return = a.return, a = a.sibling;
        }
      p &= 1;
    }
    switch (le(vn, p), v) {
      case "forwards":
        for (f = u.child, v = null; f !== null; )
          a = f.alternate, a !== null && hl(a) === null && (v = f), f = f.sibling;
        f = v, f === null ? (v = u.child, u.child = null) : (v = f.sibling, f.sibling = null), sc(
          u,
          !1,
          v,
          f,
          T
        );
        break;
      case "backwards":
        for (f = null, v = u.child, u.child = null; v !== null; ) {
          if (a = v.alternate, a !== null && hl(a) === null) {
            u.child = v;
            break;
          }
          a = v.sibling, v.sibling = f, f = v, v = a;
        }
        sc(
          u,
          !0,
          f,
          null,
          T
        );
        break;
      case "together":
        sc(u, !1, null, null, void 0);
        break;
      default:
        u.memoizedState = null;
    }
    return u.child;
  }
  function pa(a, u, f) {
    if (a !== null && (u.dependencies = a.dependencies), Ds |= u.lanes, (f & u.childLanes) === 0)
      if (a !== null) {
        if (Df(
          a,
          u,
          f,
          !1
        ), (f & u.childLanes) === 0)
          return null;
      } else return null;
    if (a !== null && u.child !== a.child)
      throw Error(l(153));
    if (u.child !== null) {
      for (a = u.child, f = la(a, a.pendingProps), u.child = f, f.return = u; a.sibling !== null; )
        a = a.sibling, f = f.sibling = la(a, a.pendingProps), f.return = u;
      f.sibling = null;
    }
    return u.child;
  }
  function up(a, u) {
    return (a.lanes & u) !== 0 ? !0 : (a = a.dependencies, !!(a !== null && Mf(a)));
  }
  function fv(a, u, f) {
    switch (u.tag) {
      case 3:
        Nt(u, u.stateNode.containerInfo), Ua(u, xn, a.memoizedState.cache), Lu();
        break;
      case 27:
      case 5:
        Rn(u);
        break;
      case 4:
        Nt(u, u.stateNode.containerInfo);
        break;
      case 10:
        Ua(
          u,
          u.type,
          u.memoizedProps.value
        );
        break;
      case 13:
        var p = u.memoizedState;
        if (p !== null)
          return p.dehydrated !== null ? (Zi(u), u.flags |= 128, null) : (f & u.child.childLanes) !== 0 ? cv(a, u, f) : (Zi(u), a = pa(
            a,
            u,
            f
          ), a !== null ? a.sibling : null);
        Zi(u);
        break;
      case 19:
        var v = (a.flags & 128) !== 0;
        if (p = (f & u.childLanes) !== 0, p || (Df(
          a,
          u,
          f,
          !1
        ), p = (f & u.childLanes) !== 0), v) {
          if (p)
            return m0(
              a,
              u,
              f
            );
          u.flags |= 128;
        }
        if (v = u.memoizedState, v !== null && (v.rendering = null, v.tail = null, v.lastEffect = null), le(vn, vn.current), p) break;
        return null;
      case 22:
      case 23:
        return u.lanes = 0, Vr(a, u, f);
      case 24:
        Ua(u, xn, a.memoizedState.cache);
    }
    return pa(a, u, f);
  }
  function g0(a, u, f) {
    if (a !== null)
      if (a.memoizedProps !== u.pendingProps)
        mt = !0;
      else {
        if (!up(a, f) && (u.flags & 128) === 0)
          return mt = !1, fv(
            a,
            u,
            f
          );
        mt = (a.flags & 131072) !== 0;
      }
    else
      mt = !1, ut && (u.flags & 1048576) !== 0 && Bt(u, Ef, u.index);
    switch (u.lanes = 0, u.tag) {
      case 16:
        e: {
          a = u.pendingProps;
          var p = u.elementType, v = p._init;
          if (p = v(p._payload), u.type = p, typeof p == "function")
            Md(p) ? (a = Bl(p, a), u.tag = 1, u = h0(
              null,
              u,
              p,
              a,
              f
            )) : (u.tag = 0, u = ap(
              null,
              u,
              p,
              a,
              f
            ));
          else {
            if (p != null) {
              if (v = p.$$typeof, v === pe) {
                u.tag = 11, u = c0(
                  null,
                  u,
                  p,
                  a,
                  f
                );
                break e;
              } else if (v === Oe) {
                u.tag = 14, u = uv(
                  null,
                  u,
                  p,
                  a,
                  f
                );
                break e;
              }
            }
            throw u = Ve(p) || p, Error(l(306, u, ""));
          }
        }
        return u;
      case 0:
        return ap(
          a,
          u,
          u.type,
          u.pendingProps,
          f
        );
      case 1:
        return p = u.type, v = Bl(
          p,
          u.pendingProps
        ), h0(
          a,
          u,
          p,
          v,
          f
        );
      case 3:
        e: {
          if (Nt(
            u,
            u.stateNode.containerInfo
          ), a === null) throw Error(l(387));
          p = u.pendingProps;
          var T = u.memoizedState;
          v = T.element, Ld(a, u), Fu(u, p, null, f);
          var k = u.memoizedState;
          if (p = k.cache, Ua(u, xn, p), p !== T.cache && Bd(
            u,
            [xn],
            f,
            !0
          ), qf(), p = k.element, T.isDehydrated)
            if (T = {
              element: p,
              isDehydrated: !1,
              cache: k.cache
            }, u.updateQueue.baseState = T, u.memoizedState = T, u.flags & 256) {
              u = op(
                a,
                u,
                p,
                f
              );
              break e;
            } else if (p !== v) {
              v = cl(
                Error(l(424)),
                u
              ), Vu(v), u = op(
                a,
                u,
                p,
                f
              );
              break e;
            } else {
              switch (a = u.stateNode.containerInfo, a.nodeType) {
                case 9:
                  a = a.body;
                  break;
                default:
                  a = a.nodeName === "HTML" ? a.ownerDocument.body : a;
              }
              for (Lt = ba(a.firstChild), hn = u, ut = !0, Eo = null, wi = !0, f = n0(
                u,
                null,
                p,
                f
              ), u.child = f; f; )
                f.flags = f.flags & -3 | 4096, f = f.sibling;
            }
          else {
            if (Lu(), p === v) {
              u = pa(
                a,
                u,
                f
              );
              break e;
            }
            Hn(
              a,
              u,
              p,
              f
            );
          }
          u = u.child;
        }
        return u;
      case 26:
        return No(a, u), a === null ? (f = qp(
          u.type,
          null,
          u.pendingProps,
          null
        )) ? u.memoizedState = f : ut || (f = u.type, a = u.pendingProps, p = Tc(
          Ne.current
        ).createElement(f), p[$t] = u, p[fi] = a, I(p, f, a), On(p), u.stateNode = p) : u.memoizedState = qp(
          u.type,
          a.memoizedProps,
          u.pendingProps,
          a.memoizedState
        ), null;
      case 27:
        return Rn(u), a === null && ut && (p = u.stateNode = ii(
          u.type,
          u.pendingProps,
          Ne.current
        ), hn = u, wi = !0, v = Lt, ni(u.type) ? (Y0 = v, Lt = ba(
          p.firstChild
        )) : Lt = v), Hn(
          a,
          u,
          u.pendingProps.children,
          f
        ), No(a, u), a === null && (u.flags |= 4194304), u.child;
      case 5:
        return a === null && ut && ((v = p = Lt) && (p = X0(
          p,
          u.type,
          u.pendingProps,
          wi
        ), p !== null ? (u.stateNode = p, hn = u, Lt = ba(
          p.firstChild
        ), wi = !1, v = !0) : v = !1), v || sa(u)), Rn(u), v = u.type, T = u.pendingProps, k = a !== null ? a.memoizedProps : null, p = T.children, Wr(v, T) ? p = null : k !== null && Wr(v, k) && (u.flags |= 32), u.memoizedState !== null && (v = jd(
          a,
          u,
          IO,
          null,
          null,
          f
        ), li._currentValue = v), No(a, u), Hn(a, u, p, f), u.child;
      case 6:
        return a === null && ut && ((a = f = Lt) && (f = xc(
          f,
          u.pendingProps,
          wi
        ), f !== null ? (u.stateNode = f, hn = u, Lt = null, a = !0) : a = !1), a || sa(u)), null;
      case 13:
        return cv(a, u, f);
      case 4:
        return Nt(
          u,
          u.stateNode.containerInfo
        ), p = u.pendingProps, a === null ? u.child = _n(
          u,
          null,
          p,
          f
        ) : Hn(
          a,
          u,
          p,
          f
        ), u.child;
      case 11:
        return c0(
          a,
          u,
          u.type,
          u.pendingProps,
          f
        );
      case 7:
        return Hn(
          a,
          u,
          u.pendingProps,
          f
        ), u.child;
      case 8:
        return Hn(
          a,
          u,
          u.pendingProps.children,
          f
        ), u.child;
      case 12:
        return Hn(
          a,
          u,
          u.pendingProps.children,
          f
        ), u.child;
      case 10:
        return p = u.pendingProps, Ua(u, u.type, p.value), Hn(
          a,
          u,
          p.children,
          f
        ), u.child;
      case 9:
        return v = u.type._context, p = u.pendingProps.children, Os(u), v = ei(v), p = p(v), u.flags |= 1, Hn(a, u, p, f), u.child;
      case 14:
        return uv(
          a,
          u,
          u.type,
          u.pendingProps,
          f
        );
      case 15:
        return Qo(
          a,
          u,
          u.type,
          u.pendingProps,
          f
        );
      case 19:
        return m0(a, u, f);
      case 31:
        return p = u.pendingProps, f = u.mode, p = {
          mode: p.mode,
          children: p.children
        }, a === null ? (f = th(
          p,
          f
        ), f.ref = u.ref, u.child = f, f.return = u, u = f) : (f = la(a.child, p), f.ref = u.ref, u.child = f, f.return = u, u = f), u;
      case 22:
        return Vr(a, u, f);
      case 24:
        return Os(u), p = ei(xn), a === null ? (v = Yu(), v === null && (v = Xt, T = Rg(), v.pooledCache = T, T.refCount++, T !== null && (v.pooledCacheLanes |= f), v = T), u.memoizedState = {
          parent: p,
          cache: v
        }, Uf(u), Ua(u, xn, v)) : ((a.lanes & f) !== 0 && (Ld(a, u), Fu(u, null, null, f), qf()), v = a.memoizedState, T = u.memoizedState, v.parent !== p ? (v = { parent: p, cache: p }, u.memoizedState = v, u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = v), Ua(u, xn, p)) : (p = T.cache, Ua(u, xn, p), p !== v.cache && Bd(
          u,
          [xn],
          f,
          !0
        ))), Hn(
          a,
          u,
          u.pendingProps.children,
          f
        ), u.child;
      case 29:
        throw u.pendingProps;
    }
    throw Error(l(156, u.tag));
  }
  function Uo(a) {
    a.flags |= 4;
  }
  function y0(a, u) {
    if (u.type !== "stylesheet" || (u.state.loading & 4) !== 0)
      a.flags &= -16777217;
    else if (a.flags |= 16777216, !W0(u)) {
      if (u = An.current, u !== null && ((xt & 4194048) === xt ? ha !== null : (xt & 62914560) !== xt && (xt & 536870912) === 0 || u !== ha))
        throw Wu = _d, Nf;
      a.flags |= 8192;
    }
  }
  function As(a, u) {
    u !== null && (a.flags |= 4), a.flags & 16384 && (u = a.tag !== 22 ? xe() : 536870912, a.lanes |= u, dc |= u);
  }
  function rc(a, u) {
    if (!ut)
      switch (a.tailMode) {
        case "hidden":
          u = a.tail;
          for (var f = null; u !== null; )
            u.alternate !== null && (f = u), u = u.sibling;
          f === null ? a.tail = null : f.sibling = null;
          break;
        case "collapsed":
          f = a.tail;
          for (var p = null; f !== null; )
            f.alternate !== null && (p = f), f = f.sibling;
          p === null ? u || a.tail === null ? a.tail = null : a.tail.sibling = null : p.sibling = null;
      }
  }
  function an(a) {
    var u = a.alternate !== null && a.alternate.child === a.child, f = 0, p = 0;
    if (u)
      for (var v = a.child; v !== null; )
        f |= v.lanes | v.childLanes, p |= v.subtreeFlags & 65011712, p |= v.flags & 65011712, v.return = a, v = v.sibling;
    else
      for (v = a.child; v !== null; )
        f |= v.lanes | v.childLanes, p |= v.subtreeFlags, p |= v.flags, v.return = a, v = v.sibling;
    return a.subtreeFlags |= p, a.childLanes = f, u;
  }
  function Vt(a, u, f) {
    var p = u.pendingProps;
    switch (Mr(u), u.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return an(u), null;
      case 1:
        return an(u), null;
      case 3:
        return f = u.stateNode, p = null, a !== null && (p = a.memoizedState.cache), u.memoizedState.cache !== p && (u.flags |= 2048), Ba(xn), Ut(), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (a === null || a.child === null) && (Hu(u) ? Uo(u) : a === null || a.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024, Eg())), an(u), null;
      case 26:
        return f = u.memoizedState, a === null ? (Uo(u), f !== null ? (an(u), y0(u, f)) : (an(u), u.flags &= -16777217)) : f ? f !== a.memoizedState ? (Uo(u), an(u), y0(u, f)) : (an(u), u.flags &= -16777217) : (a.memoizedProps !== p && Uo(u), an(u), u.flags &= -16777217), null;
      case 27:
        Ti(u), f = Ne.current;
        var v = u.type;
        if (a !== null && u.stateNode != null)
          a.memoizedProps !== p && Uo(u);
        else {
          if (!p) {
            if (u.stateNode === null)
              throw Error(l(166));
            return an(u), null;
          }
          a = Ae.current, Hu(u) ? Qd(u) : (a = ii(v, p, f), u.stateNode = a, Uo(u));
        }
        return an(u), null;
      case 5:
        if (Ti(u), f = u.type, a !== null && u.stateNode != null)
          a.memoizedProps !== p && Uo(u);
        else {
          if (!p) {
            if (u.stateNode === null)
              throw Error(l(166));
            return an(u), null;
          }
          if (a = Ae.current, Hu(u))
            Qd(u);
          else {
            switch (v = Tc(
              Ne.current
            ), a) {
              case 1:
                a = v.createElementNS(
                  "http://www.w3.org/2000/svg",
                  f
                );
                break;
              case 2:
                a = v.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  f
                );
                break;
              default:
                switch (f) {
                  case "svg":
                    a = v.createElementNS(
                      "http://www.w3.org/2000/svg",
                      f
                    );
                    break;
                  case "math":
                    a = v.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      f
                    );
                    break;
                  case "script":
                    a = v.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild);
                    break;
                  case "select":
                    a = typeof p.is == "string" ? v.createElement("select", { is: p.is }) : v.createElement("select"), p.multiple ? a.multiple = !0 : p.size && (a.size = p.size);
                    break;
                  default:
                    a = typeof p.is == "string" ? v.createElement(f, { is: p.is }) : v.createElement(f);
                }
            }
            a[$t] = u, a[fi] = p;
            e: for (v = u.child; v !== null; ) {
              if (v.tag === 5 || v.tag === 6)
                a.appendChild(v.stateNode);
              else if (v.tag !== 4 && v.tag !== 27 && v.child !== null) {
                v.child.return = v, v = v.child;
                continue;
              }
              if (v === u) break e;
              for (; v.sibling === null; ) {
                if (v.return === null || v.return === u)
                  break e;
                v = v.return;
              }
              v.sibling.return = v.return, v = v.sibling;
            }
            u.stateNode = a;
            e: switch (I(a, f, p), f) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                a = !!p.autoFocus;
                break e;
              case "img":
                a = !0;
                break e;
              default:
                a = !1;
            }
            a && Uo(u);
          }
        }
        return an(u), u.flags &= -16777217, null;
      case 6:
        if (a && u.stateNode != null)
          a.memoizedProps !== p && Uo(u);
        else {
          if (typeof p != "string" && u.stateNode === null)
            throw Error(l(166));
          if (a = Ne.current, Hu(u)) {
            if (a = u.stateNode, f = u.memoizedProps, p = null, v = hn, v !== null)
              switch (v.tag) {
                case 27:
                case 5:
                  p = v.memoizedProps;
              }
            a[$t] = u, a = !!(a.nodeValue === f || p !== null && p.suppressHydrationWarning === !0 || Mv(a.nodeValue, f)), a || sa(u);
          } else
            a = Tc(a).createTextNode(
              p
            ), a[$t] = u, u.stateNode = a;
        }
        return an(u), null;
      case 13:
        if (p = u.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (v = Hu(u), p !== null && p.dehydrated !== null) {
            if (a === null) {
              if (!v) throw Error(l(318));
              if (v = u.memoizedState, v = v !== null ? v.dehydrated : null, !v) throw Error(l(317));
              v[$t] = u;
            } else
              Lu(), (u.flags & 128) === 0 && (u.memoizedState = null), u.flags |= 4;
            an(u), v = !1;
          } else
            v = Eg(), a !== null && a.memoizedState !== null && (a.memoizedState.hydrationErrors = v), v = !0;
          if (!v)
            return u.flags & 256 ? (da(u), u) : (da(u), null);
        }
        if (da(u), (u.flags & 128) !== 0)
          return u.lanes = f, u;
        if (f = p !== null, a = a !== null && a.memoizedState !== null, f) {
          p = u.child, v = null, p.alternate !== null && p.alternate.memoizedState !== null && p.alternate.memoizedState.cachePool !== null && (v = p.alternate.memoizedState.cachePool.pool);
          var T = null;
          p.memoizedState !== null && p.memoizedState.cachePool !== null && (T = p.memoizedState.cachePool.pool), T !== v && (p.flags |= 2048);
        }
        return f !== a && f && (u.child.flags |= 8192), As(u, u.updateQueue), an(u), null;
      case 4:
        return Ut(), a === null && fh(u.stateNode.containerInfo), an(u), null;
      case 10:
        return Ba(u.type), an(u), null;
      case 19:
        if (se(vn), v = u.memoizedState, v === null) return an(u), null;
        if (p = (u.flags & 128) !== 0, T = v.rendering, T === null)
          if (p) rc(v, !1);
          else {
            if (mn !== 0 || a !== null && (a.flags & 128) !== 0)
              for (a = u.child; a !== null; ) {
                if (T = hl(a), T !== null) {
                  for (u.flags |= 128, rc(v, !1), a = T.updateQueue, u.updateQueue = a, As(u, a), u.subtreeFlags = 0, a = f, f = u.child; f !== null; )
                    zd(f, a), f = f.sibling;
                  return le(
                    vn,
                    vn.current & 1 | 2
                  ), u.child;
                }
                a = a.sibling;
              }
            v.tail !== null && _t() > pp && (u.flags |= 128, p = !0, rc(v, !1), u.lanes = 4194304);
          }
        else {
          if (!p)
            if (a = hl(T), a !== null) {
              if (u.flags |= 128, p = !0, a = a.updateQueue, u.updateQueue = a, As(u, a), rc(v, !0), v.tail === null && v.tailMode === "hidden" && !T.alternate && !ut)
                return an(u), null;
            } else
              2 * _t() - v.renderingStartTime > pp && f !== 536870912 && (u.flags |= 128, p = !0, rc(v, !1), u.lanes = 4194304);
          v.isBackwards ? (T.sibling = u.child, u.child = T) : (a = v.last, a !== null ? a.sibling = T : u.child = T, v.last = T);
        }
        return v.tail !== null ? (u = v.tail, v.rendering = u, v.tail = u.sibling, v.renderingStartTime = _t(), u.sibling = null, a = vn.current, le(vn, p ? a & 1 | 2 : a & 1), u) : (an(u), null);
      case 22:
      case 23:
        return da(u), Ju(), p = u.memoizedState !== null, a !== null ? a.memoizedState !== null !== p && (u.flags |= 8192) : p && (u.flags |= 8192), p ? (f & 536870912) !== 0 && (u.flags & 128) === 0 && (an(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : an(u), f = u.updateQueue, f !== null && As(u, f.retryQueue), f = null, a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool), p = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (p = u.memoizedState.cachePool.pool), p !== f && (u.flags |= 2048), a !== null && se(Ro), null;
      case 24:
        return f = null, a !== null && (f = a.memoizedState.cache), u.memoizedState.cache !== f && (u.flags |= 2048), Ba(xn), an(u), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(l(156, u.tag));
  }
  function O0(a, u) {
    switch (Mr(u), u.tag) {
      case 1:
        return a = u.flags, a & 65536 ? (u.flags = a & -65537 | 128, u) : null;
      case 3:
        return Ba(xn), Ut(), a = u.flags, (a & 65536) !== 0 && (a & 128) === 0 ? (u.flags = a & -65537 | 128, u) : null;
      case 26:
      case 27:
      case 5:
        return Ti(u), null;
      case 13:
        if (da(u), a = u.memoizedState, a !== null && a.dehydrated !== null) {
          if (u.alternate === null)
            throw Error(l(340));
          Lu();
        }
        return a = u.flags, a & 65536 ? (u.flags = a & -65537 | 128, u) : null;
      case 19:
        return se(vn), null;
      case 4:
        return Ut(), null;
      case 10:
        return Ba(u.type), null;
      case 22:
      case 23:
        return da(u), Ju(), a !== null && se(Ro), a = u.flags, a & 65536 ? (u.flags = a & -65537 | 128, u) : null;
      case 24:
        return Ba(xn), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function hv(a, u) {
    switch (Mr(u), u.tag) {
      case 3:
        Ba(xn), Ut();
        break;
      case 26:
      case 27:
      case 5:
        Ti(u);
        break;
      case 4:
        Ut();
        break;
      case 13:
        da(u);
        break;
      case 19:
        se(vn);
        break;
      case 10:
        Ba(u.type);
        break;
      case 22:
      case 23:
        da(u), Ju(), a !== null && se(Ro);
        break;
      case 24:
        Ba(xn);
    }
  }
  function uc(a, u) {
    try {
      var f = u.updateQueue, p = f !== null ? f.lastEffect : null;
      if (p !== null) {
        var v = p.next;
        f = v;
        do {
          if ((f.tag & a) === a) {
            p = void 0;
            var T = f.create, k = f.inst;
            p = T(), k.destroy = p;
          }
          f = f.next;
        } while (f !== v);
      }
    } catch (D) {
      jt(u, u.return, D);
    }
  }
  function ws(a, u, f) {
    try {
      var p = u.updateQueue, v = p !== null ? p.lastEffect : null;
      if (v !== null) {
        var T = v.next;
        p = T;
        do {
          if ((p.tag & a) === a) {
            var k = p.inst, D = k.destroy;
            if (D !== void 0) {
              k.destroy = void 0, v = u;
              var q = f, P = D;
              try {
                P();
              } catch (ce) {
                jt(
                  v,
                  q,
                  ce
                );
              }
            }
          }
          p = p.next;
        } while (p !== T);
      }
    } catch (ce) {
      jt(u, u.return, ce);
    }
  }
  function dv(a) {
    var u = a.updateQueue;
    if (u !== null) {
      var f = a.stateNode;
      try {
        Vd(u, f);
      } catch (p) {
        jt(a, a.return, p);
      }
    }
  }
  function cp(a, u, f) {
    f.props = Bl(
      a.type,
      a.memoizedProps
    ), f.state = a.memoizedState;
    try {
      f.componentWillUnmount();
    } catch (p) {
      jt(a, u, p);
    }
  }
  function cc(a, u) {
    try {
      var f = a.ref;
      if (f !== null) {
        switch (a.tag) {
          case 26:
          case 27:
          case 5:
            var p = a.stateNode;
            break;
          case 30:
            p = a.stateNode;
            break;
          default:
            p = a.stateNode;
        }
        typeof f == "function" ? a.refCleanup = f(p) : f.current = p;
      }
    } catch (v) {
      jt(a, u, v);
    }
  }
  function ma(a, u) {
    var f = a.ref, p = a.refCleanup;
    if (f !== null)
      if (typeof p == "function")
        try {
          p();
        } catch (v) {
          jt(a, u, v);
        } finally {
          a.refCleanup = null, a = a.alternate, a != null && (a.refCleanup = null);
        }
      else if (typeof f == "function")
        try {
          f(null);
        } catch (v) {
          jt(a, u, v);
        }
      else f.current = null;
  }
  function v0(a) {
    var u = a.type, f = a.memoizedProps, p = a.stateNode;
    try {
      e: switch (u) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          f.autoFocus && p.focus();
          break e;
        case "img":
          f.src ? p.src = f.src : f.srcSet && (p.srcset = f.srcSet);
      }
    } catch (v) {
      jt(a, a.return, v);
    }
  }
  function jr(a, u, f) {
    try {
      var p = a.stateNode;
      Mt(p, a.type, f, u), p[fi] = u;
    } catch (v) {
      jt(a, a.return, v);
    }
  }
  function pv(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 26 || a.tag === 27 && ni(a.type) || a.tag === 4;
  }
  function b0(a) {
    e: for (; ; ) {
      for (; a.sibling === null; ) {
        if (a.return === null || pv(a.return)) return null;
        a = a.return;
      }
      for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
        if (a.tag === 27 && ni(a.type) || a.flags & 2 || a.child === null || a.tag === 4) continue e;
        a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function ql(a, u, f) {
    var p = a.tag;
    if (p === 5 || p === 6)
      a = a.stateNode, u ? (f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f).insertBefore(a, u) : (u = f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f, u.appendChild(a), f = f._reactRootContainer, f != null || u.onclick !== null || (u.onclick = dh));
    else if (p !== 4 && (p === 27 && ni(a.type) && (f = a.stateNode, u = null), a = a.child, a !== null))
      for (ql(a, u, f), a = a.sibling; a !== null; )
        ql(a, u, f), a = a.sibling;
  }
  function Es(a, u, f) {
    var p = a.tag;
    if (p === 5 || p === 6)
      a = a.stateNode, u ? f.insertBefore(a, u) : f.appendChild(a);
    else if (p !== 4 && (p === 27 && ni(a.type) && (f = a.stateNode), a = a.child, a !== null))
      for (Es(a, u, f), a = a.sibling; a !== null; )
        Es(a, u, f), a = a.sibling;
  }
  function mv(a) {
    var u = a.stateNode, f = a.memoizedProps;
    try {
      for (var p = a.type, v = u.attributes; v.length; )
        u.removeAttributeNode(v[0]);
      I(u, p, f), u[$t] = a, u[fi] = f;
    } catch (T) {
      jt(a, a.return, T);
    }
  }
  var ga = !1, pn = !1, fp = !1, S0 = typeof WeakSet == "function" ? WeakSet : Set, wn = null;
  function gv(a, u) {
    if (a = a.containerInfo, L0 = Sh, a = xf(a), Cd(a)) {
      if ("selectionStart" in a)
        var f = {
          start: a.selectionStart,
          end: a.selectionEnd
        };
      else
        e: {
          f = (f = a.ownerDocument) && f.defaultView || window;
          var p = f.getSelection && f.getSelection();
          if (p && p.rangeCount !== 0) {
            f = p.anchorNode;
            var v = p.anchorOffset, T = p.focusNode;
            p = p.focusOffset;
            try {
              f.nodeType, T.nodeType;
            } catch {
              f = null;
              break e;
            }
            var k = 0, D = -1, q = -1, P = 0, ce = 0, de = a, K = null;
            t: for (; ; ) {
              for (var te; de !== f || v !== 0 && de.nodeType !== 3 || (D = k + v), de !== T || p !== 0 && de.nodeType !== 3 || (q = k + p), de.nodeType === 3 && (k += de.nodeValue.length), (te = de.firstChild) !== null; )
                K = de, de = te;
              for (; ; ) {
                if (de === a) break t;
                if (K === f && ++P === v && (D = k), K === T && ++ce === p && (q = k), (te = de.nextSibling) !== null) break;
                de = K, K = de.parentNode;
              }
              de = te;
            }
            f = D === -1 || q === -1 ? null : { start: D, end: q };
          } else f = null;
        }
      f = f || { start: 0, end: 0 };
    } else f = null;
    for (ph = { focusedElem: a, selectionRange: f }, Sh = !1, wn = u; wn !== null; )
      if (u = wn, a = u.child, (u.subtreeFlags & 1024) !== 0 && a !== null)
        a.return = u, wn = a;
      else
        for (; wn !== null; ) {
          switch (u = wn, T = u.alternate, a = u.flags, u.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((a & 1024) !== 0 && T !== null) {
                a = void 0, f = u, v = T.memoizedProps, T = T.memoizedState, p = f.stateNode;
                try {
                  var Pe = Bl(
                    f.type,
                    v,
                    f.elementType === f.type
                  );
                  a = p.getSnapshotBeforeUpdate(
                    Pe,
                    T
                  ), p.__reactInternalSnapshotBeforeUpdate = a;
                } catch ($e) {
                  jt(
                    f,
                    f.return,
                    $e
                  );
                }
              }
              break;
            case 3:
              if ((a & 1024) !== 0) {
                if (a = u.stateNode.containerInfo, f = a.nodeType, f === 9)
                  mh(a);
                else if (f === 1)
                  switch (a.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      mh(a);
                      break;
                    default:
                      a.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((a & 1024) !== 0) throw Error(l(163));
          }
          if (a = u.sibling, a !== null) {
            a.return = u.return, wn = a;
            break;
          }
          wn = u.return;
        }
  }
  function hp(a, u, f) {
    var p = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 15:
        Bo(a, f), p & 4 && uc(5, f);
        break;
      case 1:
        if (Bo(a, f), p & 4)
          if (a = f.stateNode, u === null)
            try {
              a.componentDidMount();
            } catch (k) {
              jt(f, f.return, k);
            }
          else {
            var v = Bl(
              f.type,
              u.memoizedProps
            );
            u = u.memoizedState;
            try {
              a.componentDidUpdate(
                v,
                u,
                a.__reactInternalSnapshotBeforeUpdate
              );
            } catch (k) {
              jt(
                f,
                f.return,
                k
              );
            }
          }
        p & 64 && dv(f), p & 512 && cc(f, f.return);
        break;
      case 3:
        if (Bo(a, f), p & 64 && (a = f.updateQueue, a !== null)) {
          if (u = null, f.child !== null)
            switch (f.child.tag) {
              case 27:
              case 5:
                u = f.child.stateNode;
                break;
              case 1:
                u = f.child.stateNode;
            }
          try {
            Vd(a, u);
          } catch (k) {
            jt(f, f.return, k);
          }
        }
        break;
      case 27:
        u === null && p & 4 && mv(f);
      case 26:
      case 5:
        Bo(a, f), u === null && p & 4 && v0(f), p & 512 && cc(f, f.return);
        break;
      case 12:
        Bo(a, f);
        break;
      case 13:
        Bo(a, f), p & 4 && gt(a, f), p & 64 && (a = f.memoizedState, a !== null && (a = a.dehydrated, a !== null && (f = Rv.bind(
          null,
          f
        ), G0(a, f))));
        break;
      case 22:
        if (p = f.memoizedState !== null || ga, !p) {
          u = u !== null && u.memoizedState !== null || pn, v = ga;
          var T = pn;
          ga = p, (pn = u) && !T ? Jt(
            a,
            f,
            (f.subtreeFlags & 8772) !== 0
          ) : Bo(a, f), ga = v, pn = T;
        }
        break;
      case 30:
        break;
      default:
        Bo(a, f);
    }
  }
  function T0(a) {
    var u = a.alternate;
    u !== null && (a.alternate = null, T0(u)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (u = a.stateNode, u !== null && Ge(u)), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  var Kt = null, Pi = !1;
  function _l(a, u, f) {
    for (f = f.child; f !== null; )
      x0(a, u, f), f = f.sibling;
  }
  function x0(a, u, f) {
    if (ci && typeof ci.onCommitFiberUnmount == "function")
      try {
        ci.onCommitFiberUnmount(go, f);
      } catch {
      }
    switch (f.tag) {
      case 26:
        pn || ma(f, u), _l(
          a,
          u,
          f
        ), f.memoizedState ? f.memoizedState.count-- : f.stateNode && (f = f.stateNode, f.parentNode.removeChild(f));
        break;
      case 27:
        pn || ma(f, u);
        var p = Kt, v = Pi;
        ni(f.type) && (Kt = f.stateNode, Pi = !1), _l(
          a,
          u,
          f
        ), ke(f.stateNode), Kt = p, Pi = v;
        break;
      case 5:
        pn || ma(f, u);
      case 6:
        if (p = Kt, v = Pi, Kt = null, _l(
          a,
          u,
          f
        ), Kt = p, Pi = v, Kt !== null)
          if (Pi)
            try {
              (Kt.nodeType === 9 ? Kt.body : Kt.nodeName === "HTML" ? Kt.ownerDocument.body : Kt).removeChild(f.stateNode);
            } catch (T) {
              jt(
                f,
                u,
                T
              );
            }
          else
            try {
              Kt.removeChild(f.stateNode);
            } catch (T) {
              jt(
                f,
                u,
                T
              );
            }
        break;
      case 18:
        Kt !== null && (Pi ? (a = Kt, Qv(
          a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a,
          f.stateNode
        ), kc(a)) : Qv(Kt, f.stateNode));
        break;
      case 4:
        p = Kt, v = Pi, Kt = f.stateNode.containerInfo, Pi = !0, _l(
          a,
          u,
          f
        ), Kt = p, Pi = v;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        pn || ws(2, f, u), pn || ws(4, f, u), _l(
          a,
          u,
          f
        );
        break;
      case 1:
        pn || (ma(f, u), p = f.stateNode, typeof p.componentWillUnmount == "function" && cp(
          f,
          u,
          p
        )), _l(
          a,
          u,
          f
        );
        break;
      case 21:
        _l(
          a,
          u,
          f
        );
        break;
      case 22:
        pn = (p = pn) || f.memoizedState !== null, _l(
          a,
          u,
          f
        ), pn = p;
        break;
      default:
        _l(
          a,
          u,
          f
        );
    }
  }
  function gt(a, u) {
    if (u.memoizedState === null && (a = u.alternate, a !== null && (a = a.memoizedState, a !== null && (a = a.dehydrated, a !== null))))
      try {
        kc(a);
      } catch (f) {
        jt(u, u.return, f);
      }
  }
  function A0(a) {
    switch (a.tag) {
      case 13:
      case 19:
        var u = a.stateNode;
        return u === null && (u = a.stateNode = new S0()), u;
      case 22:
        return a = a.stateNode, u = a._retryCache, u === null && (u = a._retryCache = new S0()), u;
      default:
        throw Error(l(435, a.tag));
    }
  }
  function nh(a, u) {
    var f = A0(a);
    u.forEach(function(p) {
      var v = dS.bind(null, a, p);
      f.has(p) || (f.add(p), p.then(v, v));
    });
  }
  function Wi(a, u) {
    var f = u.deletions;
    if (f !== null)
      for (var p = 0; p < f.length; p++) {
        var v = f[p], T = a, k = u, D = k;
        e: for (; D !== null; ) {
          switch (D.tag) {
            case 27:
              if (ni(D.type)) {
                Kt = D.stateNode, Pi = !1;
                break e;
              }
              break;
            case 5:
              Kt = D.stateNode, Pi = !1;
              break e;
            case 3:
            case 4:
              Kt = D.stateNode.containerInfo, Pi = !0;
              break e;
          }
          D = D.return;
        }
        if (Kt === null) throw Error(l(160));
        x0(T, k, v), Kt = null, Pi = !1, T = v.alternate, T !== null && (T.return = null), v.return = null;
      }
    if (u.subtreeFlags & 13878)
      for (u = u.child; u !== null; )
        fc(u, a), u = u.sibling;
  }
  var pl = null;
  function fc(a, u) {
    var f = a.alternate, p = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Wi(u, a), mi(a), p & 4 && (ws(3, a, a.return), uc(3, a), ws(5, a, a.return));
        break;
      case 1:
        Wi(u, a), mi(a), p & 512 && (pn || f === null || ma(f, f.return)), p & 64 && ga && (a = a.updateQueue, a !== null && (p = a.callbacks, p !== null && (f = a.shared.hiddenCallbacks, a.shared.hiddenCallbacks = f === null ? p : f.concat(p))));
        break;
      case 26:
        var v = pl;
        if (Wi(u, a), mi(a), p & 512 && (pn || f === null || ma(f, f.return)), p & 4) {
          var T = f !== null ? f.memoizedState : null;
          if (p = a.memoizedState, f === null)
            if (p === null)
              if (a.stateNode === null) {
                e: {
                  p = a.type, f = a.memoizedProps, v = v.ownerDocument || v;
                  t: switch (p) {
                    case "title":
                      T = v.getElementsByTagName("title")[0], (!T || T[uf] || T[$t] || T.namespaceURI === "http://www.w3.org/2000/svg" || T.hasAttribute("itemprop")) && (T = v.createElement(p), v.head.insertBefore(
                        T,
                        v.querySelector("head > title")
                      )), I(T, p, f), T[$t] = a, On(T), p = T;
                      break e;
                    case "link":
                      var k = wc(
                        "link",
                        "href",
                        v
                      ).get(p + (f.href || ""));
                      if (k) {
                        for (var D = 0; D < k.length; D++)
                          if (T = k[D], T.getAttribute("href") === (f.href == null || f.href === "" ? null : f.href) && T.getAttribute("rel") === (f.rel == null ? null : f.rel) && T.getAttribute("title") === (f.title == null ? null : f.title) && T.getAttribute("crossorigin") === (f.crossOrigin == null ? null : f.crossOrigin)) {
                            k.splice(D, 1);
                            break t;
                          }
                      }
                      T = v.createElement(p), I(T, p, f), v.head.appendChild(T);
                      break;
                    case "meta":
                      if (k = wc(
                        "meta",
                        "content",
                        v
                      ).get(p + (f.content || ""))) {
                        for (D = 0; D < k.length; D++)
                          if (T = k[D], T.getAttribute("content") === (f.content == null ? null : "" + f.content) && T.getAttribute("name") === (f.name == null ? null : f.name) && T.getAttribute("property") === (f.property == null ? null : f.property) && T.getAttribute("http-equiv") === (f.httpEquiv == null ? null : f.httpEquiv) && T.getAttribute("charset") === (f.charSet == null ? null : f.charSet)) {
                            k.splice(D, 1);
                            break t;
                          }
                      }
                      T = v.createElement(p), I(T, p, f), v.head.appendChild(T);
                      break;
                    default:
                      throw Error(l(468, p));
                  }
                  T[$t] = a, On(T), p = T;
                }
                a.stateNode = p;
              } else
                P0(
                  v,
                  a.type,
                  a.stateNode
                );
            else
              a.stateNode = _p(
                v,
                p,
                a.memoizedProps
              );
          else
            T !== p ? (T === null ? f.stateNode !== null && (f = f.stateNode, f.parentNode.removeChild(f)) : T.count--, p === null ? P0(
              v,
              a.type,
              a.stateNode
            ) : _p(
              v,
              p,
              a.memoizedProps
            )) : p === null && a.stateNode !== null && jr(
              a,
              a.memoizedProps,
              f.memoizedProps
            );
        }
        break;
      case 27:
        Wi(u, a), mi(a), p & 512 && (pn || f === null || ma(f, f.return)), f !== null && p & 4 && jr(
          a,
          a.memoizedProps,
          f.memoizedProps
        );
        break;
      case 5:
        if (Wi(u, a), mi(a), p & 512 && (pn || f === null || ma(f, f.return)), a.flags & 32) {
          v = a.stateNode;
          try {
            gr(v, "");
          } catch (te) {
            jt(a, a.return, te);
          }
        }
        p & 4 && a.stateNode != null && (v = a.memoizedProps, jr(
          a,
          v,
          f !== null ? f.memoizedProps : v
        )), p & 1024 && (fp = !0);
        break;
      case 6:
        if (Wi(u, a), mi(a), p & 4) {
          if (a.stateNode === null)
            throw Error(l(162));
          p = a.memoizedProps, f = a.stateNode;
          try {
            f.nodeValue = p;
          } catch (te) {
            jt(a, a.return, te);
          }
        }
        break;
      case 3:
        if (Oh = null, v = pl, pl = Vn(u.containerInfo), Wi(u, a), pl = v, mi(a), p & 4 && f !== null && f.memoizedState.isDehydrated)
          try {
            kc(u.containerInfo);
          } catch (te) {
            jt(a, a.return, te);
          }
        fp && (fp = !1, Gr(a));
        break;
      case 4:
        p = pl, pl = Vn(
          a.stateNode.containerInfo
        ), Wi(u, a), mi(a), pl = p;
        break;
      case 12:
        Wi(u, a), mi(a);
        break;
      case 13:
        Wi(u, a), mi(a), a.child.flags & 8192 && a.memoizedState !== null != (f !== null && f.memoizedState !== null) && (D0 = _t()), p & 4 && (p = a.updateQueue, p !== null && (a.updateQueue = null, nh(a, p)));
        break;
      case 22:
        v = a.memoizedState !== null;
        var q = f !== null && f.memoizedState !== null, P = ga, ce = pn;
        if (ga = P || v, pn = ce || q, Wi(u, a), pn = ce, ga = P, mi(a), p & 8192)
          e: for (u = a.stateNode, u._visibility = v ? u._visibility & -2 : u._visibility | 1, v && (f === null || q || ga || pn || qo(a)), f = null, u = a; ; ) {
            if (u.tag === 5 || u.tag === 26) {
              if (f === null) {
                q = f = u;
                try {
                  if (T = q.stateNode, v)
                    k = T.style, typeof k.setProperty == "function" ? k.setProperty("display", "none", "important") : k.display = "none";
                  else {
                    D = q.stateNode;
                    var de = q.memoizedProps.style, K = de != null && de.hasOwnProperty("display") ? de.display : null;
                    D.style.display = K == null || typeof K == "boolean" ? "" : ("" + K).trim();
                  }
                } catch (te) {
                  jt(q, q.return, te);
                }
              }
            } else if (u.tag === 6) {
              if (f === null) {
                q = u;
                try {
                  q.stateNode.nodeValue = v ? "" : q.memoizedProps;
                } catch (te) {
                  jt(q, q.return, te);
                }
              }
            } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === a) && u.child !== null) {
              u.child.return = u, u = u.child;
              continue;
            }
            if (u === a) break e;
            for (; u.sibling === null; ) {
              if (u.return === null || u.return === a) break e;
              f === u && (f = null), u = u.return;
            }
            f === u && (f = null), u.sibling.return = u.return, u = u.sibling;
          }
        p & 4 && (p = a.updateQueue, p !== null && (f = p.retryQueue, f !== null && (p.retryQueue = null, nh(a, f))));
        break;
      case 19:
        Wi(u, a), mi(a), p & 4 && (p = a.updateQueue, p !== null && (a.updateQueue = null, nh(a, p)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Wi(u, a), mi(a);
    }
  }
  function mi(a) {
    var u = a.flags;
    if (u & 2) {
      try {
        for (var f, p = a.return; p !== null; ) {
          if (pv(p)) {
            f = p;
            break;
          }
          p = p.return;
        }
        if (f == null) throw Error(l(160));
        switch (f.tag) {
          case 27:
            var v = f.stateNode, T = b0(a);
            Es(a, T, v);
            break;
          case 5:
            var k = f.stateNode;
            f.flags & 32 && (gr(k, ""), f.flags &= -33);
            var D = b0(a);
            Es(a, D, k);
            break;
          case 3:
          case 4:
            var q = f.stateNode.containerInfo, P = b0(a);
            ql(
              a,
              P,
              q
            );
            break;
          default:
            throw Error(l(161));
        }
      } catch (ce) {
        jt(a, a.return, ce);
      }
      a.flags &= -3;
    }
    u & 4096 && (a.flags &= -4097);
  }
  function Gr(a) {
    if (a.subtreeFlags & 1024)
      for (a = a.child; a !== null; ) {
        var u = a;
        Gr(u), u.tag === 5 && u.flags & 1024 && u.stateNode.reset(), a = a.sibling;
      }
  }
  function Bo(a, u) {
    if (u.subtreeFlags & 8772)
      for (u = u.child; u !== null; )
        hp(a, u.alternate, u), u = u.sibling;
  }
  function qo(a) {
    for (a = a.child; a !== null; ) {
      var u = a;
      switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ws(4, u, u.return), qo(u);
          break;
        case 1:
          ma(u, u.return);
          var f = u.stateNode;
          typeof f.componentWillUnmount == "function" && cp(
            u,
            u.return,
            f
          ), qo(u);
          break;
        case 27:
          ke(u.stateNode);
        case 26:
        case 5:
          ma(u, u.return), qo(u);
          break;
        case 22:
          u.memoizedState === null && qo(u);
          break;
        case 30:
          qo(u);
          break;
        default:
          qo(u);
      }
      a = a.sibling;
    }
  }
  function Jt(a, u, f) {
    for (f = f && (u.subtreeFlags & 8772) !== 0, u = u.child; u !== null; ) {
      var p = u.alternate, v = a, T = u, k = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          Jt(
            v,
            T,
            f
          ), uc(4, T);
          break;
        case 1:
          if (Jt(
            v,
            T,
            f
          ), p = T, v = p.stateNode, typeof v.componentDidMount == "function")
            try {
              v.componentDidMount();
            } catch (P) {
              jt(p, p.return, P);
            }
          if (p = T, v = p.updateQueue, v !== null) {
            var D = p.stateNode;
            try {
              var q = v.shared.hiddenCallbacks;
              if (q !== null)
                for (v.shared.hiddenCallbacks = null, v = 0; v < q.length; v++)
                  Ku(q[v], D);
            } catch (P) {
              jt(p, p.return, P);
            }
          }
          f && k & 64 && dv(T), cc(T, T.return);
          break;
        case 27:
          mv(T);
        case 26:
        case 5:
          Jt(
            v,
            T,
            f
          ), f && p === null && k & 4 && v0(T), cc(T, T.return);
          break;
        case 12:
          Jt(
            v,
            T,
            f
          );
          break;
        case 13:
          Jt(
            v,
            T,
            f
          ), f && k & 4 && gt(v, T);
          break;
        case 22:
          T.memoizedState === null && Jt(
            v,
            T,
            f
          ), cc(T, T.return);
          break;
        case 30:
          break;
        default:
          Jt(
            v,
            T,
            f
          );
      }
      u = u.sibling;
    }
  }
  function w0(a, u) {
    var f = null;
    a !== null && a.memoizedState !== null && a.memoizedState.cachePool !== null && (f = a.memoizedState.cachePool.pool), a = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (a = u.memoizedState.cachePool.pool), a !== f && (a != null && a.refCount++, f != null && vs(f));
  }
  function Hl(a, u) {
    a = null, u.alternate !== null && (a = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== a && (u.refCount++, a != null && vs(a));
  }
  function ya(a, u, f, p) {
    if (u.subtreeFlags & 10256)
      for (u = u.child; u !== null; )
        _o(
          a,
          u,
          f,
          p
        ), u = u.sibling;
  }
  function _o(a, u, f, p) {
    var v = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 15:
        ya(
          a,
          u,
          f,
          p
        ), v & 2048 && uc(9, u);
        break;
      case 1:
        ya(
          a,
          u,
          f,
          p
        );
        break;
      case 3:
        ya(
          a,
          u,
          f,
          p
        ), v & 2048 && (a = null, u.alternate !== null && (a = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== a && (u.refCount++, a != null && vs(a)));
        break;
      case 12:
        if (v & 2048) {
          ya(
            a,
            u,
            f,
            p
          ), a = u.stateNode;
          try {
            var T = u.memoizedProps, k = T.id, D = T.onPostCommit;
            typeof D == "function" && D(
              k,
              u.alternate === null ? "mount" : "update",
              a.passiveEffectDuration,
              -0
            );
          } catch (q) {
            jt(u, u.return, q);
          }
        } else
          ya(
            a,
            u,
            f,
            p
          );
        break;
      case 13:
        ya(
          a,
          u,
          f,
          p
        );
        break;
      case 23:
        break;
      case 22:
        T = u.stateNode, k = u.alternate, u.memoizedState !== null ? T._visibility & 2 ? ya(
          a,
          u,
          f,
          p
        ) : Cs(a, u) : T._visibility & 2 ? ya(
          a,
          u,
          f,
          p
        ) : (T._visibility |= 2, Yr(
          a,
          u,
          f,
          p,
          (u.subtreeFlags & 10256) !== 0
        )), v & 2048 && w0(k, u);
        break;
      case 24:
        ya(
          a,
          u,
          f,
          p
        ), v & 2048 && Hl(u.alternate, u);
        break;
      default:
        ya(
          a,
          u,
          f,
          p
        );
    }
  }
  function Yr(a, u, f, p, v) {
    for (v = v && (u.subtreeFlags & 10256) !== 0, u = u.child; u !== null; ) {
      var T = a, k = u, D = f, q = p, P = k.flags;
      switch (k.tag) {
        case 0:
        case 11:
        case 15:
          Yr(
            T,
            k,
            D,
            q,
            v
          ), uc(8, k);
          break;
        case 23:
          break;
        case 22:
          var ce = k.stateNode;
          k.memoizedState !== null ? ce._visibility & 2 ? Yr(
            T,
            k,
            D,
            q,
            v
          ) : Cs(
            T,
            k
          ) : (ce._visibility |= 2, Yr(
            T,
            k,
            D,
            q,
            v
          )), v && P & 2048 && w0(
            k.alternate,
            k
          );
          break;
        case 24:
          Yr(
            T,
            k,
            D,
            q,
            v
          ), v && P & 2048 && Hl(k.alternate, k);
          break;
        default:
          Yr(
            T,
            k,
            D,
            q,
            v
          );
      }
      u = u.sibling;
    }
  }
  function Cs(a, u) {
    if (u.subtreeFlags & 10256)
      for (u = u.child; u !== null; ) {
        var f = a, p = u, v = p.flags;
        switch (p.tag) {
          case 22:
            Cs(f, p), v & 2048 && w0(
              p.alternate,
              p
            );
            break;
          case 24:
            Cs(f, p), v & 2048 && Hl(p.alternate, p);
            break;
          default:
            Cs(f, p);
        }
        u = u.sibling;
      }
  }
  var wt = 8192;
  function Rs(a) {
    if (a.subtreeFlags & wt)
      for (a = a.child; a !== null; )
        Ln(a), a = a.sibling;
  }
  function Ln(a) {
    switch (a.tag) {
      case 26:
        Rs(a), a.flags & wt && a.memoizedState !== null && Bv(
          pl,
          a.memoizedState,
          a.memoizedProps
        );
        break;
      case 5:
        Rs(a);
        break;
      case 3:
      case 4:
        var u = pl;
        pl = Vn(a.stateNode.containerInfo), Rs(a), pl = u;
        break;
      case 22:
        a.memoizedState === null && (u = a.alternate, u !== null && u.memoizedState !== null ? (u = wt, wt = 16777216, Rs(a), wt = u) : Rs(a));
        break;
      default:
        Rs(a);
    }
  }
  function yv(a) {
    var u = a.alternate;
    if (u !== null && (a = u.child, a !== null)) {
      u.child = null;
      do
        u = a.sibling, a.sibling = null, a = u;
      while (a !== null);
    }
  }
  function hc(a) {
    var u = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (u !== null)
        for (var f = 0; f < u.length; f++) {
          var p = u[f];
          wn = p, ml(
            p,
            a
          );
        }
      yv(a);
    }
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        dp(a), a = a.sibling;
  }
  function dp(a) {
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        hc(a), a.flags & 2048 && ws(9, a, a.return);
        break;
      case 3:
        hc(a);
        break;
      case 12:
        hc(a);
        break;
      case 22:
        var u = a.stateNode;
        a.memoizedState !== null && u._visibility & 2 && (a.return === null || a.return.tag !== 13) ? (u._visibility &= -3, ih(a)) : hc(a);
        break;
      default:
        hc(a);
    }
  }
  function ih(a) {
    var u = a.deletions;
    if ((a.flags & 16) !== 0) {
      if (u !== null)
        for (var f = 0; f < u.length; f++) {
          var p = u[f];
          wn = p, ml(
            p,
            a
          );
        }
      yv(a);
    }
    for (a = a.child; a !== null; ) {
      switch (u = a, u.tag) {
        case 0:
        case 11:
        case 15:
          ws(8, u, u.return), ih(u);
          break;
        case 22:
          f = u.stateNode, f._visibility & 2 && (f._visibility &= -3, ih(u));
          break;
        default:
          ih(u);
      }
      a = a.sibling;
    }
  }
  function ml(a, u) {
    for (; wn !== null; ) {
      var f = wn;
      switch (f.tag) {
        case 0:
        case 11:
        case 15:
          ws(8, f, u);
          break;
        case 23:
        case 22:
          if (f.memoizedState !== null && f.memoizedState.cachePool !== null) {
            var p = f.memoizedState.cachePool.pool;
            p != null && p.refCount++;
          }
          break;
        case 24:
          vs(f.memoizedState.cache);
      }
      if (p = f.child, p !== null) p.return = f, wn = p;
      else
        e: for (f = a; wn !== null; ) {
          p = wn;
          var v = p.sibling, T = p.return;
          if (T0(p), p === f) {
            wn = null;
            break e;
          }
          if (v !== null) {
            v.return = T, wn = v;
            break e;
          }
          wn = T;
        }
    }
  }
  var Ov = {
    getCacheForType: function(a) {
      var u = ei(xn), f = u.data.get(a);
      return f === void 0 && (f = a(), u.data.set(a, f)), f;
    }
  }, E0 = typeof WeakMap == "function" ? WeakMap : Map, qt = 0, Xt = null, yt = null, xt = 0, Et = 0, Fi = null, Ho = !1, ks = !1, C0 = !1, Lo = 0, mn = 0, Ds = 0, Ms = 0, R0 = 0, Mn = 0, dc = 0, lh = null, Ci = null, k0 = !1, D0 = 0, pp = 1 / 0, mp = null, La = null, ti = 0, zs = null, Qs = null, pc = 0, Ki = 0, gp = null, M0 = null, mc = 0, yp = null;
  function gl() {
    if ((qt & 2) !== 0 && xt !== 0)
      return xt & -xt;
    if (F.T !== null) {
      var a = bs;
      return a !== 0 ? a : Cp();
    }
    return Ma();
  }
  function vv() {
    Mn === 0 && (Mn = (xt & 536870912) === 0 || ut ? Y() : 536870912);
    var a = An.current;
    return a !== null && (a.flags |= 32), Mn;
  }
  function Ji(a, u, f) {
    (a === Xt && (Et === 2 || Et === 9) || a.cancelPendingCommit !== null) && (Oa(a, 0), Vo(
      a,
      xt,
      Mn,
      !1
    )), _e(a, f), ((qt & 2) === 0 || a !== Xt) && (a === Xt && ((qt & 2) === 0 && (Ms |= f), mn === 4 && Vo(
      a,
      xt,
      Mn,
      !1
    )), va(a));
  }
  function bv(a, u, f) {
    if ((qt & 6) !== 0) throw Error(l(327));
    var p = !f && (u & 124) === 0 && (u & a.expiredLanes) === 0 || Cl(a, u), v = p ? vp(a, u) : $r(a, u, !0), T = p;
    do {
      if (v === 0) {
        ks && !p && Vo(a, u, 0, !1);
        break;
      } else {
        if (f = a.current.alternate, T && !Op(f)) {
          v = $r(a, u, !1), T = !1;
          continue;
        }
        if (v === 2) {
          if (T = u, a.errorRecoveryDisabledLanes & T)
            var k = 0;
          else
            k = a.pendingLanes & -536870913, k = k !== 0 ? k : k & 536870912 ? 536870912 : 0;
          if (k !== 0) {
            u = k;
            e: {
              var D = a;
              v = lh;
              var q = D.current.memoizedState.isDehydrated;
              if (q && (Oa(D, k).flags |= 256), k = $r(
                D,
                k,
                !1
              ), k !== 2) {
                if (C0 && !q) {
                  D.errorRecoveryDisabledLanes |= T, Ms |= T, v = 4;
                  break e;
                }
                T = Ci, Ci = v, T !== null && (Ci === null ? Ci = T : Ci.push.apply(
                  Ci,
                  T
                ));
              }
              v = k;
            }
            if (T = !1, v !== 2) continue;
          }
        }
        if (v === 1) {
          Oa(a, 0), Vo(a, u, 0, !0);
          break;
        }
        e: {
          switch (p = a, T = v, T) {
            case 0:
            case 1:
              throw Error(l(345));
            case 4:
              if ((u & 4194048) !== u) break;
            case 6:
              Vo(
                p,
                u,
                Mn,
                !Ho
              );
              break e;
            case 2:
              Ci = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(l(329));
          }
          if ((u & 62914560) === u && (v = D0 + 300 - _t(), 10 < v)) {
            if (Vo(
              p,
              u,
              Mn,
              !Ho
            ), Ui(p, 0, !0) !== 0) break e;
            p.timeoutHandle = ja(
              gc.bind(
                null,
                p,
                f,
                Ci,
                mp,
                k0,
                u,
                Mn,
                Ms,
                dc,
                Ho,
                T,
                2,
                -0,
                0
              ),
              v
            );
            break e;
          }
          gc(
            p,
            f,
            Ci,
            mp,
            k0,
            u,
            Mn,
            Ms,
            dc,
            Ho,
            T,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    va(a);
  }
  function gc(a, u, f, p, v, T, k, D, q, P, ce, de, K, te) {
    if (a.timeoutHandle = -1, de = u.subtreeFlags, (de & 8192 || (de & 16785408) === 16785408) && (Ec = { stylesheets: null, count: 0, unsuspend: Uv }, Ln(u), de = qv(), de !== null)) {
      a.cancelPendingCommit = de(
        xv.bind(
          null,
          a,
          u,
          T,
          f,
          p,
          v,
          k,
          D,
          q,
          ce,
          1,
          K,
          te
        )
      ), Vo(a, T, k, !P);
      return;
    }
    xv(
      a,
      u,
      T,
      f,
      p,
      v,
      k,
      D,
      q
    );
  }
  function Op(a) {
    for (var u = a; ; ) {
      var f = u.tag;
      if ((f === 0 || f === 11 || f === 15) && u.flags & 16384 && (f = u.updateQueue, f !== null && (f = f.stores, f !== null)))
        for (var p = 0; p < f.length; p++) {
          var v = f[p], T = v.getSnapshot;
          v = v.value;
          try {
            if (!Ai(T(), v)) return !1;
          } catch {
            return !1;
          }
        }
      if (f = u.child, u.subtreeFlags & 16384 && f !== null)
        f.return = u, u = f;
      else {
        if (u === a) break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === a) return !0;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
    }
    return !0;
  }
  function Vo(a, u, f, p) {
    u &= ~R0, u &= ~Ms, a.suspendedLanes |= u, a.pingedLanes &= ~u, p && (a.warmLanes |= u), p = a.expirationTimes;
    for (var v = u; 0 < v; ) {
      var T = 31 - Fn(v), k = 1 << T;
      p[T] = -1, v &= ~k;
    }
    f !== 0 && tt(a, f, u);
  }
  function ah() {
    return (qt & 6) === 0 ? (Xo(0), !1) : !0;
  }
  function yc() {
    if (yt !== null) {
      if (Et === 0)
        var a = yt.return;
      else
        a = yt, ra = Co = null, Iu(a), Yi = null, ic = 0, a = yt;
      for (; a !== null; )
        hv(a.alternate, a), a = a.return;
      yt = null;
    }
  }
  function Oa(a, u) {
    var f = a.timeoutHandle;
    f !== -1 && (a.timeoutHandle = -1, V0(f)), f = a.cancelPendingCommit, f !== null && (a.cancelPendingCommit = null, f()), yc(), Xt = a, yt = f = la(a.current, null), xt = u, Et = 0, Fi = null, Ho = !1, ks = Cl(a, u), C0 = !1, dc = Mn = R0 = Ms = Ds = mn = 0, Ci = lh = null, k0 = !1, (u & 8) !== 0 && (u |= u & 32);
    var p = a.entangledLanes;
    if (p !== 0)
      for (a = a.entanglements, p &= u; 0 < p; ) {
        var v = 31 - Fn(p), T = 1 << v;
        u |= a[v], p &= ~T;
      }
    return Lo = u, na(), f;
  }
  function Oc(a, u) {
    nt = null, F.H = Ff, u === zr || u === Zu ? (u = Hd(), Et = 3) : u === Nf ? (u = Hd(), Et = 4) : Et = u === u0 ? 8 : u !== null && typeof u == "object" && typeof u.then == "function" ? 6 : 1, Fi = u, yt === null && (mn = 1, Lr(
      a,
      cl(u, a.current)
    ));
  }
  function z0() {
    var a = F.H;
    return F.H = Ff, a === null ? Ff : a;
  }
  function Sv() {
    var a = F.A;
    return F.A = Ov, a;
  }
  function Ns() {
    mn = 4, Ho || (xt & 4194048) !== xt && An.current !== null || (ks = !0), (Ds & 134217727) === 0 && (Ms & 134217727) === 0 || Xt === null || Vo(
      Xt,
      xt,
      Mn,
      !1
    );
  }
  function $r(a, u, f) {
    var p = qt;
    qt |= 2;
    var v = z0(), T = Sv();
    (Xt !== a || xt !== u) && (mp = null, Oa(a, u)), u = !1;
    var k = mn;
    e: do
      try {
        if (Et !== 0 && yt !== null) {
          var D = yt, q = Fi;
          switch (Et) {
            case 8:
              yc(), k = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              An.current === null && (u = !0);
              var P = Et;
              if (Et = 0, Fi = null, Zr(a, D, q, P), f && ks) {
                k = 0;
                break e;
              }
              break;
            default:
              P = Et, Et = 0, Fi = null, Zr(a, D, q, P);
          }
        }
        Tv(), k = mn;
        break;
      } catch (ce) {
        Oc(a, ce);
      }
    while (!0);
    return u && a.shellSuspendCounter++, ra = Co = null, qt = p, F.H = v, F.A = T, yt === null && (Xt = null, xt = 0, na()), k;
  }
  function Tv() {
    for (; yt !== null; ) bp(yt);
  }
  function vp(a, u) {
    var f = qt;
    qt |= 2;
    var p = z0(), v = Sv();
    Xt !== a || xt !== u ? (mp = null, pp = _t() + 500, Oa(a, u)) : ks = Cl(
      a,
      u
    );
    e: do
      try {
        if (Et !== 0 && yt !== null) {
          u = yt;
          var T = Fi;
          t: switch (Et) {
            case 1:
              Et = 0, Fi = null, Zr(a, u, T, 1);
              break;
            case 2:
            case 9:
              if (Mg(T)) {
                Et = 0, Fi = null, N0(u);
                break;
              }
              u = function() {
                Et !== 2 && Et !== 9 || Xt !== a || (Et = 7), va(a);
              }, T.then(u, u);
              break e;
            case 3:
              Et = 7;
              break e;
            case 4:
              Et = 5;
              break e;
            case 7:
              Mg(T) ? (Et = 0, Fi = null, N0(u)) : (Et = 0, Fi = null, Zr(a, u, T, 7));
              break;
            case 5:
              var k = null;
              switch (yt.tag) {
                case 26:
                  k = yt.memoizedState;
                case 5:
                case 27:
                  var D = yt;
                  if (!k || W0(k)) {
                    Et = 0, Fi = null;
                    var q = D.sibling;
                    if (q !== null) yt = q;
                    else {
                      var P = D.return;
                      P !== null ? (yt = P, Sp(P)) : yt = null;
                    }
                    break t;
                  }
              }
              Et = 0, Fi = null, Zr(a, u, T, 5);
              break;
            case 6:
              Et = 0, Fi = null, Zr(a, u, T, 6);
              break;
            case 8:
              yc(), mn = 6;
              break e;
            default:
              throw Error(l(462));
          }
        }
        Q0();
        break;
      } catch (ce) {
        Oc(a, ce);
      }
    while (!0);
    return ra = Co = null, F.H = p, F.A = v, qt = f, yt !== null ? 0 : (Xt = null, xt = 0, na(), mn);
  }
  function Q0() {
    for (; yt !== null && !ld(); )
      bp(yt);
  }
  function bp(a) {
    var u = g0(a.alternate, a, Lo);
    a.memoizedProps = a.pendingProps, u === null ? Sp(a) : yt = u;
  }
  function N0(a) {
    var u = a, f = u.alternate;
    switch (u.tag) {
      case 15:
      case 0:
        u = f0(
          f,
          u,
          u.pendingProps,
          u.type,
          void 0,
          xt
        );
        break;
      case 11:
        u = f0(
          f,
          u,
          u.pendingProps,
          u.type.render,
          u.ref,
          xt
        );
        break;
      case 5:
        Iu(u);
      default:
        hv(f, u), u = yt = zd(u, Lo), u = g0(f, u, Lo);
    }
    a.memoizedProps = a.pendingProps, u === null ? Sp(a) : yt = u;
  }
  function Zr(a, u, f, p) {
    ra = Co = null, Iu(u), Yi = null, ic = 0;
    var v = u.return;
    try {
      if (dl(
        a,
        v,
        u,
        f,
        xt
      )) {
        mn = 1, Lr(
          a,
          cl(f, a.current)
        ), yt = null;
        return;
      }
    } catch (T) {
      if (v !== null) throw yt = v, T;
      mn = 1, Lr(
        a,
        cl(f, a.current)
      ), yt = null;
      return;
    }
    u.flags & 32768 ? (ut || p === 1 ? a = !0 : ks || (xt & 536870912) !== 0 ? a = !1 : (Ho = a = !0, (p === 2 || p === 9 || p === 3 || p === 6) && (p = An.current, p !== null && p.tag === 13 && (p.flags |= 16384))), U0(u, a)) : Sp(u);
  }
  function Sp(a) {
    var u = a;
    do {
      if ((u.flags & 32768) !== 0) {
        U0(
          u,
          Ho
        );
        return;
      }
      a = u.return;
      var f = Vt(
        u.alternate,
        u,
        Lo
      );
      if (f !== null) {
        yt = f;
        return;
      }
      if (u = u.sibling, u !== null) {
        yt = u;
        return;
      }
      yt = u = a;
    } while (u !== null);
    mn === 0 && (mn = 5);
  }
  function U0(a, u) {
    do {
      var f = O0(a.alternate, a);
      if (f !== null) {
        f.flags &= 32767, yt = f;
        return;
      }
      if (f = a.return, f !== null && (f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null), !u && (a = a.sibling, a !== null)) {
        yt = a;
        return;
      }
      yt = a = f;
    } while (a !== null);
    mn = 6, yt = null;
  }
  function xv(a, u, f, p, v, T, k, D, q) {
    a.cancelPendingCommit = null;
    do
      xp();
    while (ti !== 0);
    if ((qt & 6) !== 0) throw Error(l(327));
    if (u !== null) {
      if (u === a.current) throw Error(l(177));
      if (T = u.lanes | u.childLanes, T |= wf, ht(
        a,
        f,
        T,
        k,
        D,
        q
      ), a === Xt && (yt = Xt = null, xt = 0), Qs = u, zs = a, pc = f, Ki = T, gp = v, M0 = p, (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? (a.callbackNode = null, a.callbackPriority = 0, pS(lt, function() {
        return Ev(), null;
      })) : (a.callbackNode = null, a.callbackPriority = 0), p = (u.flags & 13878) !== 0, (u.subtreeFlags & 13878) !== 0 || p) {
        p = F.T, F.T = null, v = Z.p, Z.p = 2, k = qt, qt |= 4;
        try {
          gv(a, u, f);
        } finally {
          qt = k, Z.p = v, F.T = p;
        }
      }
      ti = 1, Av(), wv(), oh();
    }
  }
  function Av() {
    if (ti === 1) {
      ti = 0;
      var a = zs, u = Qs, f = (u.flags & 13878) !== 0;
      if ((u.subtreeFlags & 13878) !== 0 || f) {
        f = F.T, F.T = null;
        var p = Z.p;
        Z.p = 2;
        var v = qt;
        qt |= 4;
        try {
          fc(u, a);
          var T = ph, k = xf(a.containerInfo), D = T.focusedElem, q = T.selectionRange;
          if (k !== D && D && D.ownerDocument && Wt(
            D.ownerDocument.documentElement,
            D
          )) {
            if (q !== null && Cd(D)) {
              var P = q.start, ce = q.end;
              if (ce === void 0 && (ce = P), "selectionStart" in D)
                D.selectionStart = P, D.selectionEnd = Math.min(
                  ce,
                  D.value.length
                );
              else {
                var de = D.ownerDocument || document, K = de && de.defaultView || window;
                if (K.getSelection) {
                  var te = K.getSelection(), Pe = D.textContent.length, $e = Math.min(q.start, Pe), zt = q.end === void 0 ? $e : Math.min(q.end, Pe);
                  !te.extend && $e > zt && (k = zt, zt = $e, $e = k);
                  var $ = hs(
                    D,
                    $e
                  ), j = hs(
                    D,
                    zt
                  );
                  if ($ && j && (te.rangeCount !== 1 || te.anchorNode !== $.node || te.anchorOffset !== $.offset || te.focusNode !== j.node || te.focusOffset !== j.offset)) {
                    var W = de.createRange();
                    W.setStart($.node, $.offset), te.removeAllRanges(), $e > zt ? (te.addRange(W), te.extend(j.node, j.offset)) : (W.setEnd(j.node, j.offset), te.addRange(W));
                  }
                }
              }
            }
            for (de = [], te = D; te = te.parentNode; )
              te.nodeType === 1 && de.push({
                element: te,
                left: te.scrollLeft,
                top: te.scrollTop
              });
            for (typeof D.focus == "function" && D.focus(), D = 0; D < de.length; D++) {
              var he = de[D];
              he.element.scrollLeft = he.left, he.element.scrollTop = he.top;
            }
          }
          Sh = !!L0, ph = L0 = null;
        } finally {
          qt = v, Z.p = p, F.T = f;
        }
      }
      a.current = u, ti = 2;
    }
  }
  function wv() {
    if (ti === 2) {
      ti = 0;
      var a = zs, u = Qs, f = (u.flags & 8772) !== 0;
      if ((u.subtreeFlags & 8772) !== 0 || f) {
        f = F.T, F.T = null;
        var p = Z.p;
        Z.p = 2;
        var v = qt;
        qt |= 4;
        try {
          hp(a, u.alternate, u);
        } finally {
          qt = v, Z.p = p, F.T = f;
        }
      }
      ti = 3;
    }
  }
  function oh() {
    if (ti === 4 || ti === 3) {
      ti = 0, af();
      var a = zs, u = Qs, f = pc, p = M0;
      (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? ti = 5 : (ti = 0, Qs = zs = null, Tp(a, a.pendingLanes));
      var v = a.pendingLanes;
      if (v === 0 && (La = null), Sn(f), u = u.stateNode, ci && typeof ci.onCommitFiberRoot == "function")
        try {
          ci.onCommitFiberRoot(
            go,
            u,
            void 0,
            (u.current.flags & 128) === 128
          );
        } catch {
        }
      if (p !== null) {
        u = F.T, v = Z.p, Z.p = 2, F.T = null;
        try {
          for (var T = a.onRecoverableError, k = 0; k < p.length; k++) {
            var D = p[k];
            T(D.value, {
              componentStack: D.stack
            });
          }
        } finally {
          F.T = u, Z.p = v;
        }
      }
      (pc & 3) !== 0 && xp(), va(a), v = a.pendingLanes, (f & 4194090) !== 0 && (v & 42) !== 0 ? a === yp ? mc++ : (mc = 0, yp = a) : mc = 0, Xo(0);
    }
  }
  function Tp(a, u) {
    (a.pooledCacheLanes &= u) === 0 && (u = a.pooledCache, u != null && (a.pooledCache = null, vs(u)));
  }
  function xp(a) {
    return Av(), wv(), oh(), Ev();
  }
  function Ev() {
    if (ti !== 5) return !1;
    var a = zs, u = Ki;
    Ki = 0;
    var f = Sn(pc), p = F.T, v = Z.p;
    try {
      Z.p = 32 > f ? 32 : f, F.T = null, f = gp, gp = null;
      var T = zs, k = pc;
      if (ti = 0, Qs = zs = null, pc = 0, (qt & 6) !== 0) throw Error(l(331));
      var D = qt;
      if (qt |= 4, dp(T.current), _o(
        T,
        T.current,
        k,
        f
      ), qt = D, Xo(0, !1), ci && typeof ci.onPostCommitFiberRoot == "function")
        try {
          ci.onPostCommitFiberRoot(go, T);
        } catch {
        }
      return !0;
    } finally {
      Z.p = v, F.T = p, Tp(a, u);
    }
  }
  function B0(a, u, f) {
    u = cl(f, u), u = ip(a.stateNode, u, 2), a = Xi(a, u, 2), a !== null && (_e(a, 2), va(a));
  }
  function jt(a, u, f) {
    if (a.tag === 3)
      B0(a, a, f);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          B0(
            u,
            a,
            f
          );
          break;
        } else if (u.tag === 1) {
          var p = u.stateNode;
          if (typeof u.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (La === null || !La.has(p))) {
            a = cl(f, a), f = rv(2), p = Xi(u, f, 2), p !== null && (r0(
              f,
              p,
              u,
              a
            ), _e(p, 2), va(p));
            break;
          }
        }
        u = u.return;
      }
  }
  function sh(a, u, f) {
    var p = a.pingCache;
    if (p === null) {
      p = a.pingCache = new E0();
      var v = /* @__PURE__ */ new Set();
      p.set(u, v);
    } else
      v = p.get(u), v === void 0 && (v = /* @__PURE__ */ new Set(), p.set(u, v));
    v.has(f) || (C0 = !0, v.add(f), a = Cv.bind(null, a, u, f), u.then(a, a));
  }
  function Cv(a, u, f) {
    var p = a.pingCache;
    p !== null && p.delete(u), a.pingedLanes |= a.suspendedLanes & f, a.warmLanes &= ~f, Xt === a && (xt & f) === f && (mn === 4 || mn === 3 && (xt & 62914560) === xt && 300 > _t() - D0 ? (qt & 2) === 0 && Oa(a, 0) : R0 |= f, dc === xt && (dc = 0)), va(a);
  }
  function Ap(a, u) {
    u === 0 && (u = xe()), a = Ao(a, u), a !== null && (_e(a, u), va(a));
  }
  function Rv(a) {
    var u = a.memoizedState, f = 0;
    u !== null && (f = u.retryLane), Ap(a, f);
  }
  function dS(a, u) {
    var f = 0;
    switch (a.tag) {
      case 13:
        var p = a.stateNode, v = a.memoizedState;
        v !== null && (f = v.retryLane);
        break;
      case 19:
        p = a.stateNode;
        break;
      case 22:
        p = a.stateNode._retryCache;
        break;
      default:
        throw Error(l(314));
    }
    p !== null && p.delete(u), Ap(a, f);
  }
  function pS(a, u) {
    return cr(a, u);
  }
  var wp = null, vc = null, rh = !1, bc = !1, uh = !1, Us = 0;
  function va(a) {
    a !== vc && a.next === null && (vc === null ? wp = vc = a : vc = vc.next = a), bc = !0, rh || (rh = !0, Ep());
  }
  function Xo(a, u) {
    if (!uh && bc) {
      uh = !0;
      do
        for (var f = !1, p = wp; p !== null; ) {
          if (a !== 0) {
            var v = p.pendingLanes;
            if (v === 0) var T = 0;
            else {
              var k = p.suspendedLanes, D = p.pingedLanes;
              T = (1 << 31 - Fn(42 | a) + 1) - 1, T &= v & ~(k & ~D), T = T & 201326741 ? T & 201326741 | 1 : T ? T | 2 : 0;
            }
            T !== 0 && (f = !0, kv(p, T));
          } else
            T = xt, T = Ui(
              p,
              p === Xt ? T : 0,
              p.cancelPendingCommit !== null || p.timeoutHandle !== -1
            ), (T & 3) === 0 || Cl(p, T) || (f = !0, kv(p, T));
          p = p.next;
        }
      while (f);
      uh = !1;
    }
  }
  function mS() {
    q0();
  }
  function q0() {
    bc = rh = !1;
    var a = 0;
    Us !== 0 && (Np() && (a = Us), Us = 0);
    for (var u = _t(), f = null, p = wp; p !== null; ) {
      var v = p.next, T = ch(p, u);
      T === 0 ? (p.next = null, f === null ? wp = v : f.next = v, v === null && (vc = f)) : (f = p, (a !== 0 || (T & 3) !== 0) && (bc = !0)), p = v;
    }
    Xo(a);
  }
  function ch(a, u) {
    for (var f = a.suspendedLanes, p = a.pingedLanes, v = a.expirationTimes, T = a.pendingLanes & -62914561; 0 < T; ) {
      var k = 31 - Fn(T), D = 1 << k, q = v[k];
      q === -1 ? ((D & f) === 0 || (D & p) !== 0) && (v[k] = M(D, u)) : q <= u && (a.expiredLanes |= D), T &= ~D;
    }
    if (u = Xt, f = xt, f = Ui(
      a,
      a === u ? f : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), p = a.callbackNode, f === 0 || a === u && (Et === 2 || Et === 9) || a.cancelPendingCommit !== null)
      return p !== null && p !== null && Da(p), a.callbackNode = null, a.callbackPriority = 0;
    if ((f & 3) === 0 || Cl(a, f)) {
      if (u = f & -f, u === a.callbackPriority) return u;
      switch (p !== null && Da(p), Sn(f)) {
        case 2:
        case 8:
          f = ad;
          break;
        case 32:
          f = lt;
          break;
        case 268435456:
          f = hr;
          break;
        default:
          f = lt;
      }
      return p = _0.bind(null, a), f = cr(f, p), a.callbackPriority = u, a.callbackNode = f, u;
    }
    return p !== null && p !== null && Da(p), a.callbackPriority = 2, a.callbackNode = null, 2;
  }
  function _0(a, u) {
    if (ti !== 0 && ti !== 5)
      return a.callbackNode = null, a.callbackPriority = 0, null;
    var f = a.callbackNode;
    if (xp() && a.callbackNode !== f)
      return null;
    var p = xt;
    return p = Ui(
      a,
      a === Xt ? p : 0,
      a.cancelPendingCommit !== null || a.timeoutHandle !== -1
    ), p === 0 ? null : (bv(a, p, u), ch(a, _t()), a.callbackNode != null && a.callbackNode === f ? _0.bind(null, a) : null);
  }
  function kv(a, u) {
    if (xp()) return null;
    bv(a, u, !0);
  }
  function Ep() {
    OS(function() {
      (qt & 6) !== 0 ? cr(
        mo,
        mS
      ) : q0();
    });
  }
  function Cp() {
    return Us === 0 && (Us = Y()), Us;
  }
  function Sc(a) {
    return a == null || typeof a == "symbol" || typeof a == "boolean" ? null : typeof a == "function" ? a : pf("" + a);
  }
  function Rp(a, u) {
    var f = u.ownerDocument.createElement("input");
    return f.name = u.name, f.value = u.value, a.id && f.setAttribute("form", a.id), u.parentNode.insertBefore(f, u), a = new FormData(a), f.parentNode.removeChild(f), a;
  }
  function kp(a, u, f, p, v) {
    if (u === "submit" && f && f.stateNode === v) {
      var T = Sc(
        (v[fi] || null).action
      ), k = p.submitter;
      k && (u = (u = k[fi] || null) ? Sc(u.formAction) : k.getAttribute("formAction"), u !== null && (T = u, k = null));
      var D = new yf(
        "action",
        "action",
        null,
        p,
        v
      );
      a.push({
        event: D,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (p.defaultPrevented) {
                if (Us !== 0) {
                  var q = k ? Rp(v, k) : new FormData(v);
                  Kg(
                    f,
                    {
                      pending: !0,
                      data: q,
                      method: v.method,
                      action: T
                    },
                    null,
                    q
                  );
                }
              } else
                typeof T == "function" && (D.preventDefault(), q = k ? Rp(v, k) : new FormData(v), Kg(
                  f,
                  {
                    pending: !0,
                    data: q,
                    method: v.method,
                    action: T
                  },
                  T,
                  q
                ));
            },
            currentTarget: v
          }
        ]
      });
    }
  }
  for (var Dp = 0; Dp < Dd.length; Dp++) {
    var gn = Dd[Dp], H0 = gn.toLowerCase(), gS = gn[0].toUpperCase() + gn.slice(1);
    _i(
      H0,
      "on" + gS
    );
  }
  _i(Af, "onAnimationEnd"), _i(KO, "onAnimationIteration"), _i(Sg, "onAnimationStart"), _i("dblclick", "onDoubleClick"), _i("focusin", "onFocus"), _i("focusout", "onBlur"), _i(uS, "onTransitionRun"), _i(Tg, "onTransitionStart"), _i(kd, "onTransitionCancel"), _i(xg, "onTransitionEnd"), pr("onMouseEnter", ["mouseout", "mouseover"]), pr("onMouseLeave", ["mouseout", "mouseover"]), pr("onPointerEnter", ["pointerout", "pointerover"]), pr("onPointerLeave", ["pointerout", "pointerover"]), qn(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), qn(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), qn("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), qn(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), qn(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), qn(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Ie = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), yS = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ie)
  );
  function jo(a, u) {
    u = (u & 4) !== 0;
    for (var f = 0; f < a.length; f++) {
      var p = a[f], v = p.event;
      p = p.listeners;
      e: {
        var T = void 0;
        if (u)
          for (var k = p.length - 1; 0 <= k; k--) {
            var D = p[k], q = D.instance, P = D.currentTarget;
            if (D = D.listener, q !== T && v.isPropagationStopped())
              break e;
            T = D, v.currentTarget = P;
            try {
              T(v);
            } catch (ce) {
              If(ce);
            }
            v.currentTarget = null, T = q;
          }
        else
          for (k = 0; k < p.length; k++) {
            if (D = p[k], q = D.instance, P = D.currentTarget, D = D.listener, q !== T && v.isPropagationStopped())
              break e;
            T = D, v.currentTarget = P;
            try {
              T(v);
            } catch (ce) {
              If(ce);
            }
            v.currentTarget = null, T = q;
          }
      }
    }
  }
  function at(a, u) {
    var f = u[Wm];
    f === void 0 && (f = u[Wm] = /* @__PURE__ */ new Set());
    var p = a + "__bubble";
    f.has(p) || (Dv(u, a, 2, !1), f.add(p));
  }
  function Bs(a, u, f) {
    var p = 0;
    u && (p |= 4), Dv(
      f,
      a,
      p,
      u
    );
  }
  var Pr = "_reactListening" + Math.random().toString(36).slice(2);
  function fh(a) {
    if (!a[Pr]) {
      a[Pr] = !0, Fm.forEach(function(f) {
        f !== "selectionchange" && (yS.has(f) || Bs(f, !1, a), Bs(f, !0, a));
      });
      var u = a.nodeType === 9 ? a : a.ownerDocument;
      u === null || u[Pr] || (u[Pr] = !0, Bs("selectionchange", !1, u));
    }
  }
  function Dv(a, u, f, p) {
    switch (Vv(u)) {
      case 2:
        var v = Hv;
        break;
      case 8:
        v = Lv;
        break;
      default:
        v = Xp;
    }
    f = v.bind(
      null,
      u,
      f,
      a
    ), v = void 0, !dd || u !== "touchstart" && u !== "touchmove" && u !== "wheel" || (v = !0), p ? v !== void 0 ? a.addEventListener(u, f, {
      capture: !0,
      passive: v
    }) : a.addEventListener(u, f, !0) : v !== void 0 ? a.addEventListener(u, f, {
      passive: v
    }) : a.addEventListener(u, f, !1);
  }
  function hh(a, u, f, p, v) {
    var T = p;
    if ((u & 1) === 0 && (u & 2) === 0 && p !== null)
      e: for (; ; ) {
        if (p === null) return;
        var k = p.tag;
        if (k === 3 || k === 4) {
          var D = p.stateNode.containerInfo;
          if (D === v) break;
          if (k === 4)
            for (k = p.return; k !== null; ) {
              var q = k.tag;
              if ((q === 3 || q === 4) && k.stateNode.containerInfo === v)
                return;
              k = k.return;
            }
          for (; D !== null; ) {
            if (k = os(D), k === null) return;
            if (q = k.tag, q === 5 || q === 6 || q === 26 || q === 27) {
              p = T = k;
              continue e;
            }
            D = D.parentNode;
          }
        }
        p = p.return;
      }
    LO(function() {
      var P = T, ce = yr(f), de = [];
      e: {
        var K = Ag.get(a);
        if (K !== void 0) {
          var te = yf, Pe = a;
          switch (a) {
            case "keypress":
              if (gf(f) === 0) break e;
            case "keydown":
            case "keyup":
              te = Sr;
              break;
            case "focusin":
              Pe = "focus", te = rg;
              break;
            case "focusout":
              Pe = "blur", te = rg;
              break;
            case "beforeblur":
            case "afterblur":
              te = rg;
              break;
            case "click":
              if (f.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              te = vf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              te = jO;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              te = vd;
              break;
            case Af:
            case KO:
            case Sg:
              te = aS;
              break;
            case xg:
              te = qi;
              break;
            case "scroll":
            case "scrollend":
              te = iS;
              break;
            case "wheel":
              te = bd;
              break;
            case "copy":
            case "cut":
            case "paste":
              te = sS;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              te = Bi;
              break;
            case "toggle":
            case "beforetoggle":
              te = hg;
          }
          var $e = (u & 4) !== 0, zt = !$e && (a === "scroll" || a === "scrollend"), $ = $e ? K !== null ? K + "Capture" : null : K;
          $e = [];
          for (var j = P, W; j !== null; ) {
            var he = j;
            if (W = he.stateNode, he = he.tag, he !== 5 && he !== 26 && he !== 27 || W === null || $ === null || (he = bo(j, $), he != null && $e.push(
              Ii(j, he, W)
            )), zt) break;
            j = j.return;
          }
          0 < $e.length && (K = new te(
            K,
            Pe,
            null,
            f,
            ce
          ), de.push({ event: K, listeners: $e }));
        }
      }
      if ((u & 7) === 0) {
        e: {
          if (K = a === "mouseover" || a === "pointerover", te = a === "mouseout" || a === "pointerout", K && f !== hd && (Pe = f.relatedTarget || f.fromElement) && (os(Pe) || Pe[dr]))
            break e;
          if ((te || K) && (K = ce.window === ce ? ce : (K = ce.ownerDocument) ? K.defaultView || K.parentWindow : window, te ? (Pe = f.relatedTarget || f.toElement, te = P, Pe = Pe ? os(Pe) : null, Pe !== null && (zt = c(Pe), $e = Pe.tag, Pe !== zt || $e !== 5 && $e !== 27 && $e !== 6) && (Pe = null)) : (te = null, Pe = P), te !== Pe)) {
            if ($e = vf, he = "onMouseLeave", $ = "onMouseEnter", j = "mouse", (a === "pointerout" || a === "pointerover") && ($e = Bi, he = "onPointerLeave", $ = "onPointerEnter", j = "pointer"), zt = te == null ? K : Su(te), W = Pe == null ? K : Su(Pe), K = new $e(
              he,
              j + "leave",
              te,
              f,
              ce
            ), K.target = zt, K.relatedTarget = W, he = null, os(ce) === P && ($e = new $e(
              $,
              j + "enter",
              Pe,
              f,
              ce
            ), $e.target = W, $e.relatedTarget = zt, he = $e), zt = he, te && Pe)
              t: {
                for ($e = te, $ = Pe, j = 0, W = $e; W; W = _s(W))
                  j++;
                for (W = 0, he = $; he; he = _s(he))
                  W++;
                for (; 0 < j - W; )
                  $e = _s($e), j--;
                for (; 0 < W - j; )
                  $ = _s($), W--;
                for (; j--; ) {
                  if ($e === $ || $ !== null && $e === $.alternate)
                    break t;
                  $e = _s($e), $ = _s($);
                }
                $e = null;
              }
            else $e = null;
            te !== null && Mp(
              de,
              K,
              te,
              $e,
              !1
            ), Pe !== null && zt !== null && Mp(
              de,
              zt,
              Pe,
              $e,
              !0
            );
          }
        }
        e: {
          if (K = P ? Su(P) : window, te = K.nodeName && K.nodeName.toLowerCase(), te === "select" || te === "input" && K.type === "file")
            var Ue = cs;
          else if (gg(K))
            if (yg)
              Ue = So;
            else {
              Ue = Ed;
              var ct = FO;
            }
          else
            te = K.nodeName, !te || te.toLowerCase() !== "input" || K.type !== "checkbox" && K.type !== "radio" ? P && Cu(P.elementType) && (Ue = cs) : Ue = fs;
          if (Ue && (Ue = Ue(a, P))) {
            Ad(
              de,
              Ue,
              f,
              ce
            );
            break e;
          }
          ct && ct(a, K, P), a === "focusout" && P && K.type === "number" && P.memoizedProps.value != null && hf(K, "number", K.value);
        }
        switch (ct = P ? Su(P) : window, a) {
          case "focusin":
            (gg(ct) || ct.contentEditable === "true") && (Ml = ct, Rr = P, ul = null);
            break;
          case "focusout":
            ul = Rr = Ml = null;
            break;
          case "mousedown":
            Nu = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Nu = !1, Uu(de, f, ce);
            break;
          case "selectionchange":
            if (bg) break;
          case "keydown":
          case "keyup":
            Uu(de, f, ce);
        }
        var Ye;
        if (Sd)
          e: {
            switch (a) {
              case "compositionstart":
                var We = "onCompositionStart";
                break e;
              case "compositionend":
                We = "onCompositionEnd";
                break e;
              case "compositionupdate":
                We = "onCompositionUpdate";
                break e;
            }
            We = void 0;
          }
        else
          Dl ? xd(a, f) && (We = "onCompositionEnd") : a === "keydown" && f.keyCode === 229 && (We = "onCompositionStart");
        We && (Td && f.locale !== "ko" && (Dl || We !== "onCompositionStart" ? We === "onCompositionEnd" && Dl && (Ye = mf()) : (kl = ce, pd = "value" in kl ? kl.value : kl.textContent, Dl = !0)), ct = qs(P, We), 0 < ct.length && (We = new ug(
          We,
          a,
          null,
          f,
          ce
        ), de.push({ event: We, listeners: ct }), Ye ? We.data = Ye : (Ye = Sf(f), Ye !== null && (We.data = Ye)))), (Ye = rS ? pg(a, f) : mg(a, f)) && (We = qs(P, "onBeforeInput"), 0 < We.length && (ct = new ug(
          "onBeforeInput",
          "beforeinput",
          null,
          f,
          ce
        ), de.push({
          event: ct,
          listeners: We
        }), ct.data = Ye)), kp(
          de,
          a,
          P,
          f,
          ce
        );
      }
      jo(de, u);
    });
  }
  function Ii(a, u, f) {
    return {
      instance: a,
      listener: u,
      currentTarget: f
    };
  }
  function qs(a, u) {
    for (var f = u + "Capture", p = []; a !== null; ) {
      var v = a, T = v.stateNode;
      if (v = v.tag, v !== 5 && v !== 26 && v !== 27 || T === null || (v = bo(a, f), v != null && p.unshift(
        Ii(a, v, T)
      ), v = bo(a, u), v != null && p.push(
        Ii(a, v, T)
      )), a.tag === 3) return p;
      a = a.return;
    }
    return [];
  }
  function _s(a) {
    if (a === null) return null;
    do
      a = a.return;
    while (a && a.tag !== 5 && a.tag !== 27);
    return a || null;
  }
  function Mp(a, u, f, p, v) {
    for (var T = u._reactName, k = []; f !== null && f !== p; ) {
      var D = f, q = D.alternate, P = D.stateNode;
      if (D = D.tag, q !== null && q === p) break;
      D !== 5 && D !== 26 && D !== 27 || P === null || (q = P, v ? (P = bo(f, T), P != null && k.unshift(
        Ii(f, P, q)
      )) : v || (P = bo(f, T), P != null && k.push(
        Ii(f, P, q)
      ))), f = f.return;
    }
    k.length !== 0 && a.push({ event: u, listeners: k });
  }
  var zp = /\r\n?/g, yl = /\u0000|\uFFFD/g;
  function Qp(a) {
    return (typeof a == "string" ? a : "" + a).replace(zp, `
`).replace(yl, "");
  }
  function Mv(a, u) {
    return u = Qp(u), Qp(a) === u;
  }
  function dh() {
  }
  function Gt(a, u, f, p, v, T) {
    switch (f) {
      case "children":
        typeof p == "string" ? u === "body" || u === "textarea" && p === "" || gr(a, p) : (typeof p == "number" || typeof p == "bigint") && u !== "body" && gr(a, "" + p);
        break;
      case "className":
        Oo(a, "class", p);
        break;
      case "tabIndex":
        Oo(a, "tabindex", p);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Oo(a, f, p);
        break;
      case "style":
        fd(a, p, T);
        break;
      case "data":
        if (u !== "object") {
          Oo(a, "data", p);
          break;
        }
      case "src":
      case "href":
        if (p === "" && (u !== "a" || f !== "href")) {
          a.removeAttribute(f);
          break;
        }
        if (p == null || typeof p == "function" || typeof p == "symbol" || typeof p == "boolean") {
          a.removeAttribute(f);
          break;
        }
        p = pf("" + p), a.setAttribute(f, p);
        break;
      case "action":
      case "formAction":
        if (typeof p == "function") {
          a.setAttribute(
            f,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof T == "function" && (f === "formAction" ? (u !== "input" && Gt(a, u, "name", v.name, v, null), Gt(
            a,
            u,
            "formEncType",
            v.formEncType,
            v,
            null
          ), Gt(
            a,
            u,
            "formMethod",
            v.formMethod,
            v,
            null
          ), Gt(
            a,
            u,
            "formTarget",
            v.formTarget,
            v,
            null
          )) : (Gt(a, u, "encType", v.encType, v, null), Gt(a, u, "method", v.method, v, null), Gt(a, u, "target", v.target, v, null)));
        if (p == null || typeof p == "symbol" || typeof p == "boolean") {
          a.removeAttribute(f);
          break;
        }
        p = pf("" + p), a.setAttribute(f, p);
        break;
      case "onClick":
        p != null && (a.onclick = dh);
        break;
      case "onScroll":
        p != null && at("scroll", a);
        break;
      case "onScrollEnd":
        p != null && at("scrollend", a);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(l(61));
          if (f = p.__html, f != null) {
            if (v.children != null) throw Error(l(60));
            a.innerHTML = f;
          }
        }
        break;
      case "multiple":
        a.multiple = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "muted":
        a.muted = p && typeof p != "function" && typeof p != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (p == null || typeof p == "function" || typeof p == "boolean" || typeof p == "symbol") {
          a.removeAttribute("xlink:href");
          break;
        }
        f = pf("" + p), a.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          f
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        p != null && typeof p != "function" && typeof p != "symbol" ? a.setAttribute(f, "" + p) : a.removeAttribute(f);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        p && typeof p != "function" && typeof p != "symbol" ? a.setAttribute(f, "") : a.removeAttribute(f);
        break;
      case "capture":
      case "download":
        p === !0 ? a.setAttribute(f, "") : p !== !1 && p != null && typeof p != "function" && typeof p != "symbol" ? a.setAttribute(f, p) : a.removeAttribute(f);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        p != null && typeof p != "function" && typeof p != "symbol" && !isNaN(p) && 1 <= p ? a.setAttribute(f, p) : a.removeAttribute(f);
        break;
      case "rowSpan":
      case "start":
        p == null || typeof p == "function" || typeof p == "symbol" || isNaN(p) ? a.removeAttribute(f) : a.setAttribute(f, p);
        break;
      case "popover":
        at("beforetoggle", a), at("toggle", a), ff(a, "popover", p);
        break;
      case "xlinkActuate":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          p
        );
        break;
      case "xlinkArcrole":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          p
        );
        break;
      case "xlinkRole":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          p
        );
        break;
      case "xlinkShow":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          p
        );
        break;
      case "xlinkTitle":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          p
        );
        break;
      case "xlinkType":
        Qa(
          a,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          p
        );
        break;
      case "xmlBase":
        Qa(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          p
        );
        break;
      case "xmlLang":
        Qa(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          p
        );
        break;
      case "xmlSpace":
        Qa(
          a,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          p
        );
        break;
      case "is":
        ff(a, "is", p);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < f.length) || f[0] !== "o" && f[0] !== "O" || f[1] !== "n" && f[1] !== "N") && (f = df.get(f) || f, ff(a, f, p));
    }
  }
  function zn(a, u, f, p, v, T) {
    switch (f) {
      case "style":
        fd(a, p, T);
        break;
      case "dangerouslySetInnerHTML":
        if (p != null) {
          if (typeof p != "object" || !("__html" in p))
            throw Error(l(61));
          if (f = p.__html, f != null) {
            if (v.children != null) throw Error(l(60));
            a.innerHTML = f;
          }
        }
        break;
      case "children":
        typeof p == "string" ? gr(a, p) : (typeof p == "number" || typeof p == "bigint") && gr(a, "" + p);
        break;
      case "onScroll":
        p != null && at("scroll", a);
        break;
      case "onScrollEnd":
        p != null && at("scrollend", a);
        break;
      case "onClick":
        p != null && (a.onclick = dh);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!cf.hasOwnProperty(f))
          e: {
            if (f[0] === "o" && f[1] === "n" && (v = f.endsWith("Capture"), u = f.slice(2, v ? f.length - 7 : void 0), T = a[fi] || null, T = T != null ? T[f] : null, typeof T == "function" && a.removeEventListener(u, T, v), typeof p == "function")) {
              typeof T != "function" && T !== null && (f in a ? a[f] = null : a.hasAttribute(f) && a.removeAttribute(f)), a.addEventListener(u, p, v);
              break e;
            }
            f in a ? a[f] = p : p === !0 ? a.setAttribute(f, "") : ff(a, f, p);
          }
    }
  }
  function I(a, u, f) {
    switch (u) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        at("error", a), at("load", a);
        var p = !1, v = !1, T;
        for (T in f)
          if (f.hasOwnProperty(T)) {
            var k = f[T];
            if (k != null)
              switch (T) {
                case "src":
                  p = !0;
                  break;
                case "srcSet":
                  v = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(l(137, u));
                default:
                  Gt(a, u, T, k, f, null);
              }
          }
        v && Gt(a, u, "srcSet", f.srcSet, f, null), p && Gt(a, u, "src", f.src, f, null);
        return;
      case "input":
        at("invalid", a);
        var D = T = k = v = null, q = null, P = null;
        for (p in f)
          if (f.hasOwnProperty(p)) {
            var ce = f[p];
            if (ce != null)
              switch (p) {
                case "name":
                  v = ce;
                  break;
                case "type":
                  k = ce;
                  break;
                case "checked":
                  q = ce;
                  break;
                case "defaultChecked":
                  P = ce;
                  break;
                case "value":
                  T = ce;
                  break;
                case "defaultValue":
                  D = ce;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ce != null)
                    throw Error(l(137, u));
                  break;
                default:
                  Gt(a, u, p, ce, f, null);
              }
          }
        ng(
          a,
          T,
          D,
          q,
          P,
          k,
          v,
          !1
        ), wu(a);
        return;
      case "select":
        at("invalid", a), p = k = T = null;
        for (v in f)
          if (f.hasOwnProperty(v) && (D = f[v], D != null))
            switch (v) {
              case "value":
                T = D;
                break;
              case "defaultValue":
                k = D;
                break;
              case "multiple":
                p = D;
              default:
                Gt(a, u, v, D, f, null);
            }
        u = T, f = k, a.multiple = !!p, u != null ? rs(a, !!p, u, !1) : f != null && rs(a, !!p, f, !0);
        return;
      case "textarea":
        at("invalid", a), T = v = p = null;
        for (k in f)
          if (f.hasOwnProperty(k) && (D = f[k], D != null))
            switch (k) {
              case "value":
                p = D;
                break;
              case "defaultValue":
                v = D;
                break;
              case "children":
                T = D;
                break;
              case "dangerouslySetInnerHTML":
                if (D != null) throw Error(l(91));
                break;
              default:
                Gt(a, u, k, D, f, null);
            }
        lg(a, p, v, T), wu(a);
        return;
      case "option":
        for (q in f)
          if (f.hasOwnProperty(q) && (p = f[q], p != null))
            switch (q) {
              case "selected":
                a.selected = p && typeof p != "function" && typeof p != "symbol";
                break;
              default:
                Gt(a, u, q, p, f, null);
            }
        return;
      case "dialog":
        at("beforetoggle", a), at("toggle", a), at("cancel", a), at("close", a);
        break;
      case "iframe":
      case "object":
        at("load", a);
        break;
      case "video":
      case "audio":
        for (p = 0; p < Ie.length; p++)
          at(Ie[p], a);
        break;
      case "image":
        at("error", a), at("load", a);
        break;
      case "details":
        at("toggle", a);
        break;
      case "embed":
      case "source":
      case "link":
        at("error", a), at("load", a);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (P in f)
          if (f.hasOwnProperty(P) && (p = f[P], p != null))
            switch (P) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(l(137, u));
              default:
                Gt(a, u, P, p, f, null);
            }
        return;
      default:
        if (Cu(u)) {
          for (ce in f)
            f.hasOwnProperty(ce) && (p = f[ce], p !== void 0 && zn(
              a,
              u,
              ce,
              p,
              f,
              void 0
            ));
          return;
        }
    }
    for (D in f)
      f.hasOwnProperty(D) && (p = f[D], p != null && Gt(a, u, D, p, f, null));
  }
  function Mt(a, u, f, p) {
    switch (u) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var v = null, T = null, k = null, D = null, q = null, P = null, ce = null;
        for (te in f) {
          var de = f[te];
          if (f.hasOwnProperty(te) && de != null)
            switch (te) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                q = de;
              default:
                p.hasOwnProperty(te) || Gt(a, u, te, null, p, de);
            }
        }
        for (var K in p) {
          var te = p[K];
          if (de = f[K], p.hasOwnProperty(K) && (te != null || de != null))
            switch (K) {
              case "type":
                T = te;
                break;
              case "name":
                v = te;
                break;
              case "checked":
                P = te;
                break;
              case "defaultChecked":
                ce = te;
                break;
              case "value":
                k = te;
                break;
              case "defaultValue":
                D = te;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (te != null)
                  throw Error(l(137, u));
                break;
              default:
                te !== de && Gt(
                  a,
                  u,
                  K,
                  te,
                  p,
                  de
                );
            }
        }
        tg(
          a,
          k,
          D,
          q,
          P,
          ce,
          T,
          v
        );
        return;
      case "select":
        te = k = D = K = null;
        for (T in f)
          if (q = f[T], f.hasOwnProperty(T) && q != null)
            switch (T) {
              case "value":
                break;
              case "multiple":
                te = q;
              default:
                p.hasOwnProperty(T) || Gt(
                  a,
                  u,
                  T,
                  null,
                  p,
                  q
                );
            }
        for (v in p)
          if (T = p[v], q = f[v], p.hasOwnProperty(v) && (T != null || q != null))
            switch (v) {
              case "value":
                K = T;
                break;
              case "defaultValue":
                D = T;
                break;
              case "multiple":
                k = T;
              default:
                T !== q && Gt(
                  a,
                  u,
                  v,
                  T,
                  p,
                  q
                );
            }
        u = D, f = k, p = te, K != null ? rs(a, !!f, K, !1) : !!p != !!f && (u != null ? rs(a, !!f, u, !0) : rs(a, !!f, f ? [] : "", !1));
        return;
      case "textarea":
        te = K = null;
        for (D in f)
          if (v = f[D], f.hasOwnProperty(D) && v != null && !p.hasOwnProperty(D))
            switch (D) {
              case "value":
                break;
              case "children":
                break;
              default:
                Gt(a, u, D, null, p, v);
            }
        for (k in p)
          if (v = p[k], T = f[k], p.hasOwnProperty(k) && (v != null || T != null))
            switch (k) {
              case "value":
                K = v;
                break;
              case "defaultValue":
                te = v;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (v != null) throw Error(l(91));
                break;
              default:
                v !== T && Gt(a, u, k, v, p, T);
            }
        ig(a, K, te);
        return;
      case "option":
        for (var Pe in f)
          if (K = f[Pe], f.hasOwnProperty(Pe) && K != null && !p.hasOwnProperty(Pe))
            switch (Pe) {
              case "selected":
                a.selected = !1;
                break;
              default:
                Gt(
                  a,
                  u,
                  Pe,
                  null,
                  p,
                  K
                );
            }
        for (q in p)
          if (K = p[q], te = f[q], p.hasOwnProperty(q) && K !== te && (K != null || te != null))
            switch (q) {
              case "selected":
                a.selected = K && typeof K != "function" && typeof K != "symbol";
                break;
              default:
                Gt(
                  a,
                  u,
                  q,
                  K,
                  p,
                  te
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var $e in f)
          K = f[$e], f.hasOwnProperty($e) && K != null && !p.hasOwnProperty($e) && Gt(a, u, $e, null, p, K);
        for (P in p)
          if (K = p[P], te = f[P], p.hasOwnProperty(P) && K !== te && (K != null || te != null))
            switch (P) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (K != null)
                  throw Error(l(137, u));
                break;
              default:
                Gt(
                  a,
                  u,
                  P,
                  K,
                  p,
                  te
                );
            }
        return;
      default:
        if (Cu(u)) {
          for (var zt in f)
            K = f[zt], f.hasOwnProperty(zt) && K !== void 0 && !p.hasOwnProperty(zt) && zn(
              a,
              u,
              zt,
              void 0,
              p,
              K
            );
          for (ce in p)
            K = p[ce], te = f[ce], !p.hasOwnProperty(ce) || K === te || K === void 0 && te === void 0 || zn(
              a,
              u,
              ce,
              K,
              p,
              te
            );
          return;
        }
    }
    for (var $ in f)
      K = f[$], f.hasOwnProperty($) && K != null && !p.hasOwnProperty($) && Gt(a, u, $, null, p, K);
    for (de in p)
      K = p[de], te = f[de], !p.hasOwnProperty(de) || K === te || K == null && te == null || Gt(a, u, de, K, p, te);
  }
  var L0 = null, ph = null;
  function Tc(a) {
    return a.nodeType === 9 ? a : a.ownerDocument;
  }
  function Va(a) {
    switch (a) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Go(a, u) {
    if (a === 0)
      switch (u) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return a === 1 && u === "foreignObject" ? 0 : a;
  }
  function Wr(a, u) {
    return a === "textarea" || a === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.children == "bigint" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null;
  }
  var Xa = null;
  function Np() {
    var a = window.event;
    return a && a.type === "popstate" ? a === Xa ? !1 : (Xa = a, !0) : (Xa = null, !1);
  }
  var ja = typeof setTimeout == "function" ? setTimeout : void 0, V0 = typeof clearTimeout == "function" ? clearTimeout : void 0, zv = typeof Promise == "function" ? Promise : void 0, OS = typeof queueMicrotask == "function" ? queueMicrotask : typeof zv < "u" ? function(a) {
    return zv.resolve(null).then(a).catch(vS);
  } : ja;
  function vS(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function ni(a) {
    return a === "head";
  }
  function Qv(a, u) {
    var f = u, p = 0, v = 0;
    do {
      var T = f.nextSibling;
      if (a.removeChild(f), T && T.nodeType === 8)
        if (f = T.data, f === "/$") {
          if (0 < p && 8 > p) {
            f = p;
            var k = a.ownerDocument;
            if (f & 1 && ke(k.documentElement), f & 2 && ke(k.body), f & 4)
              for (f = k.head, ke(f), k = f.firstChild; k; ) {
                var D = k.nextSibling, q = k.nodeName;
                k[uf] || q === "SCRIPT" || q === "STYLE" || q === "LINK" && k.rel.toLowerCase() === "stylesheet" || f.removeChild(k), k = D;
              }
          }
          if (v === 0) {
            a.removeChild(T), kc(u);
            return;
          }
          v--;
        } else
          f === "$" || f === "$?" || f === "$!" ? v++ : p = f.charCodeAt(0) - 48;
      else p = 0;
      f = T;
    } while (f);
    kc(u);
  }
  function mh(a) {
    var u = a.firstChild;
    for (u && u.nodeType === 10 && (u = u.nextSibling); u; ) {
      var f = u;
      switch (u = u.nextSibling, f.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          mh(f), Ge(f);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (f.rel.toLowerCase() === "stylesheet") continue;
      }
      a.removeChild(f);
    }
  }
  function X0(a, u, f, p) {
    for (; a.nodeType === 1; ) {
      var v = f;
      if (a.nodeName.toLowerCase() !== u.toLowerCase()) {
        if (!p && (a.nodeName !== "INPUT" || a.type !== "hidden"))
          break;
      } else if (p) {
        if (!a[uf])
          switch (u) {
            case "meta":
              if (!a.hasAttribute("itemprop")) break;
              return a;
            case "link":
              if (T = a.getAttribute("rel"), T === "stylesheet" && a.hasAttribute("data-precedence"))
                break;
              if (T !== v.rel || a.getAttribute("href") !== (v.href == null || v.href === "" ? null : v.href) || a.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin) || a.getAttribute("title") !== (v.title == null ? null : v.title))
                break;
              return a;
            case "style":
              if (a.hasAttribute("data-precedence")) break;
              return a;
            case "script":
              if (T = a.getAttribute("src"), (T !== (v.src == null ? null : v.src) || a.getAttribute("type") !== (v.type == null ? null : v.type) || a.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin)) && T && a.hasAttribute("async") && !a.hasAttribute("itemprop"))
                break;
              return a;
            default:
              return a;
          }
      } else if (u === "input" && a.type === "hidden") {
        var T = v.name == null ? null : "" + v.name;
        if (v.type === "hidden" && a.getAttribute("name") === T)
          return a;
      } else return a;
      if (a = ba(a.nextSibling), a === null) break;
    }
    return null;
  }
  function xc(a, u, f) {
    if (u === "") return null;
    for (; a.nodeType !== 3; )
      if ((a.nodeType !== 1 || a.nodeName !== "INPUT" || a.type !== "hidden") && !f || (a = ba(a.nextSibling), a === null)) return null;
    return a;
  }
  function j0(a) {
    return a.data === "$!" || a.data === "$?" && a.ownerDocument.readyState === "complete";
  }
  function G0(a, u) {
    var f = a.ownerDocument;
    if (a.data !== "$?" || f.readyState === "complete")
      u();
    else {
      var p = function() {
        u(), f.removeEventListener("DOMContentLoaded", p);
      };
      f.addEventListener("DOMContentLoaded", p), a._reactRetry = p;
    }
  }
  function ba(a) {
    for (; a != null; a = a.nextSibling) {
      var u = a.nodeType;
      if (u === 1 || u === 3) break;
      if (u === 8) {
        if (u = a.data, u === "$" || u === "$!" || u === "$?" || u === "F!" || u === "F")
          break;
        if (u === "/$") return null;
      }
    }
    return a;
  }
  var Y0 = null;
  function Fr(a) {
    a = a.previousSibling;
    for (var u = 0; a; ) {
      if (a.nodeType === 8) {
        var f = a.data;
        if (f === "$" || f === "$!" || f === "$?") {
          if (u === 0) return a;
          u--;
        } else f === "/$" && u++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  function ii(a, u, f) {
    switch (u = Tc(f), a) {
      case "html":
        if (a = u.documentElement, !a) throw Error(l(452));
        return a;
      case "head":
        if (a = u.head, !a) throw Error(l(453));
        return a;
      case "body":
        if (a = u.body, !a) throw Error(l(454));
        return a;
      default:
        throw Error(l(451));
    }
  }
  function ke(a) {
    for (var u = a.attributes; u.length; )
      a.removeAttributeNode(u[0]);
    Ge(a);
  }
  var bn = /* @__PURE__ */ new Map(), Ll = /* @__PURE__ */ new Set();
  function Vn(a) {
    return typeof a.getRootNode == "function" ? a.getRootNode() : a.nodeType === 9 ? a : a.ownerDocument;
  }
  var Yo = Z.d;
  Z.d = {
    f: bS,
    r: Up,
    D: Ga,
    C: Zo,
    L: Bp,
    m: Hs,
    X: el,
    S: gi,
    M: Ls
  };
  function bS() {
    var a = Yo.f(), u = ah();
    return a || u;
  }
  function Up(a) {
    var u = Jn(a);
    u !== null && u.tag === 5 && u.type === "form" ? iv(u) : Yo.r(a);
  }
  var $o = typeof document > "u" ? null : document;
  function Ol(a, u, f) {
    var p = $o;
    if (p && typeof u == "string" && u) {
      var v = Rl(u);
      v = 'link[rel="' + a + '"][href="' + v + '"]', typeof f == "string" && (v += '[crossorigin="' + f + '"]'), Ll.has(v) || (Ll.add(v), a = { rel: a, crossOrigin: f, href: u }, p.querySelector(v) === null && (u = p.createElement("link"), I(u, "link", a), On(u), p.head.appendChild(u)));
    }
  }
  function Ga(a) {
    Yo.D(a), Ol("dns-prefetch", a, null);
  }
  function Zo(a, u) {
    Yo.C(a, u), Ol("preconnect", a, u);
  }
  function Bp(a, u, f) {
    Yo.L(a, u, f);
    var p = $o;
    if (p && a && u) {
      var v = 'link[rel="preload"][as="' + Rl(u) + '"]';
      u === "image" && f && f.imageSrcSet ? (v += '[imagesrcset="' + Rl(
        f.imageSrcSet
      ) + '"]', typeof f.imageSizes == "string" && (v += '[imagesizes="' + Rl(
        f.imageSizes
      ) + '"]')) : v += '[href="' + Rl(a) + '"]';
      var T = v;
      switch (u) {
        case "style":
          T = Ac(a);
          break;
        case "script":
          T = Kr(a);
      }
      bn.has(T) || (a = S(
        {
          rel: "preload",
          href: u === "image" && f && f.imageSrcSet ? void 0 : a,
          as: u
        },
        f
      ), bn.set(T, a), p.querySelector(v) !== null || u === "style" && p.querySelector(gh(T)) || u === "script" && p.querySelector(Sa(T)) || (u = p.createElement("link"), I(u, "link", a), On(u), p.head.appendChild(u)));
    }
  }
  function Hs(a, u) {
    Yo.m(a, u);
    var f = $o;
    if (f && a) {
      var p = u && typeof u.as == "string" ? u.as : "script", v = 'link[rel="modulepreload"][as="' + Rl(p) + '"][href="' + Rl(a) + '"]', T = v;
      switch (p) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          T = Kr(a);
      }
      if (!bn.has(T) && (a = S({ rel: "modulepreload", href: a }, u), bn.set(T, a), f.querySelector(v) === null)) {
        switch (p) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (f.querySelector(Sa(T)))
              return;
        }
        p = f.createElement("link"), I(p, "link", a), On(p), f.head.appendChild(p);
      }
    }
  }
  function gi(a, u, f) {
    Yo.S(a, u, f);
    var p = $o;
    if (p && a) {
      var v = Tu(p).hoistableStyles, T = Ac(a);
      u = u || "default";
      var k = v.get(T);
      if (!k) {
        var D = { loading: 0, preload: null };
        if (k = p.querySelector(
          gh(T)
        ))
          D.loading = 5;
        else {
          a = S(
            { rel: "stylesheet", href: a, "data-precedence": u },
            f
          ), (f = bn.get(T)) && Z0(a, f);
          var q = k = p.createElement("link");
          On(q), I(q, "link", a), q._p = new Promise(function(P, ce) {
            q.onload = P, q.onerror = ce;
          }), q.addEventListener("load", function() {
            D.loading |= 1;
          }), q.addEventListener("error", function() {
            D.loading |= 2;
          }), D.loading |= 4, Hp(k, u, p);
        }
        k = {
          type: "stylesheet",
          instance: k,
          count: 1,
          state: D
        }, v.set(T, k);
      }
    }
  }
  function el(a, u) {
    Yo.X(a, u);
    var f = $o;
    if (f && a) {
      var p = Tu(f).hoistableScripts, v = Kr(a), T = p.get(v);
      T || (T = f.querySelector(Sa(v)), T || (a = S({ src: a, async: !0 }, u), (u = bn.get(v)) && Lp(a, u), T = f.createElement("script"), On(T), I(T, "link", a), f.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, p.set(v, T));
    }
  }
  function Ls(a, u) {
    Yo.M(a, u);
    var f = $o;
    if (f && a) {
      var p = Tu(f).hoistableScripts, v = Kr(a), T = p.get(v);
      T || (T = f.querySelector(Sa(v)), T || (a = S({ src: a, async: !0, type: "module" }, u), (u = bn.get(v)) && Lp(a, u), T = f.createElement("script"), On(T), I(T, "link", a), f.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, p.set(v, T));
    }
  }
  function qp(a, u, f, p) {
    var v = (v = Ne.current) ? Vn(v) : null;
    if (!v) throw Error(l(446));
    switch (a) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof f.precedence == "string" && typeof f.href == "string" ? (u = Ac(f.href), f = Tu(
          v
        ).hoistableStyles, p = f.get(u), p || (p = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, f.set(u, p)), p) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (f.rel === "stylesheet" && typeof f.href == "string" && typeof f.precedence == "string") {
          a = Ac(f.href);
          var T = Tu(
            v
          ).hoistableStyles, k = T.get(a);
          if (k || (v = v.ownerDocument || v, k = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, T.set(a, k), (T = v.querySelector(
            gh(a)
          )) && !T._p && (k.instance = T, k.state.loading = 5), bn.has(a) || (f = {
            rel: "preload",
            as: "style",
            href: f.href,
            crossOrigin: f.crossOrigin,
            integrity: f.integrity,
            media: f.media,
            hrefLang: f.hrefLang,
            referrerPolicy: f.referrerPolicy
          }, bn.set(a, f), T || yh(
            v,
            a,
            f,
            k.state
          ))), u && p === null)
            throw Error(l(528, ""));
          return k;
        }
        if (u && p !== null)
          throw Error(l(529, ""));
        return null;
      case "script":
        return u = f.async, f = f.src, typeof f == "string" && u && typeof u != "function" && typeof u != "symbol" ? (u = Kr(f), f = Tu(
          v
        ).hoistableScripts, p = f.get(u), p || (p = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, f.set(u, p)), p) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(l(444, a));
    }
  }
  function Ac(a) {
    return 'href="' + Rl(a) + '"';
  }
  function gh(a) {
    return 'link[rel="stylesheet"][' + a + "]";
  }
  function $0(a) {
    return S({}, a, {
      "data-precedence": a.precedence,
      precedence: null
    });
  }
  function yh(a, u, f, p) {
    a.querySelector('link[rel="preload"][as="style"][' + u + "]") ? p.loading = 1 : (u = a.createElement("link"), p.preload = u, u.addEventListener("load", function() {
      return p.loading |= 1;
    }), u.addEventListener("error", function() {
      return p.loading |= 2;
    }), I(u, "link", f), On(u), a.head.appendChild(u));
  }
  function Kr(a) {
    return '[src="' + Rl(a) + '"]';
  }
  function Sa(a) {
    return "script[async]" + a;
  }
  function _p(a, u, f) {
    if (u.count++, u.instance === null)
      switch (u.type) {
        case "style":
          var p = a.querySelector(
            'style[data-href~="' + Rl(f.href) + '"]'
          );
          if (p)
            return u.instance = p, On(p), p;
          var v = S({}, f, {
            "data-href": f.href,
            "data-precedence": f.precedence,
            href: null,
            precedence: null
          });
          return p = (a.ownerDocument || a).createElement(
            "style"
          ), On(p), I(p, "style", v), Hp(p, f.precedence, a), u.instance = p;
        case "stylesheet":
          v = Ac(f.href);
          var T = a.querySelector(
            gh(v)
          );
          if (T)
            return u.state.loading |= 4, u.instance = T, On(T), T;
          p = $0(f), (v = bn.get(v)) && Z0(p, v), T = (a.ownerDocument || a).createElement("link"), On(T);
          var k = T;
          return k._p = new Promise(function(D, q) {
            k.onload = D, k.onerror = q;
          }), I(T, "link", p), u.state.loading |= 4, Hp(T, f.precedence, a), u.instance = T;
        case "script":
          return T = Kr(f.src), (v = a.querySelector(
            Sa(T)
          )) ? (u.instance = v, On(v), v) : (p = f, (v = bn.get(T)) && (p = S({}, f), Lp(p, v)), a = a.ownerDocument || a, v = a.createElement("script"), On(v), I(v, "link", p), a.head.appendChild(v), u.instance = v);
        case "void":
          return null;
        default:
          throw Error(l(443, u.type));
      }
    else
      u.type === "stylesheet" && (u.state.loading & 4) === 0 && (p = u.instance, u.state.loading |= 4, Hp(p, f.precedence, a));
    return u.instance;
  }
  function Hp(a, u, f) {
    for (var p = f.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), v = p.length ? p[p.length - 1] : null, T = v, k = 0; k < p.length; k++) {
      var D = p[k];
      if (D.dataset.precedence === u) T = D;
      else if (T !== v) break;
    }
    T ? T.parentNode.insertBefore(a, T.nextSibling) : (u = f.nodeType === 9 ? f.head : f, u.insertBefore(a, u.firstChild));
  }
  function Z0(a, u) {
    a.crossOrigin == null && (a.crossOrigin = u.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = u.referrerPolicy), a.title == null && (a.title = u.title);
  }
  function Lp(a, u) {
    a.crossOrigin == null && (a.crossOrigin = u.crossOrigin), a.referrerPolicy == null && (a.referrerPolicy = u.referrerPolicy), a.integrity == null && (a.integrity = u.integrity);
  }
  var Oh = null;
  function wc(a, u, f) {
    if (Oh === null) {
      var p = /* @__PURE__ */ new Map(), v = Oh = /* @__PURE__ */ new Map();
      v.set(f, p);
    } else
      v = Oh, p = v.get(f), p || (p = /* @__PURE__ */ new Map(), v.set(f, p));
    if (p.has(a)) return p;
    for (p.set(a, null), f = f.getElementsByTagName(a), v = 0; v < f.length; v++) {
      var T = f[v];
      if (!(T[uf] || T[$t] || a === "link" && T.getAttribute("rel") === "stylesheet") && T.namespaceURI !== "http://www.w3.org/2000/svg") {
        var k = T.getAttribute(u) || "";
        k = a + k;
        var D = p.get(k);
        D ? D.push(T) : p.set(k, [T]);
      }
    }
    return p;
  }
  function P0(a, u, f) {
    a = a.ownerDocument || a, a.head.insertBefore(
      f,
      u === "title" ? a.querySelector("head > title") : null
    );
  }
  function Nv(a, u, f) {
    if (f === 1 || u.itemProp != null) return !1;
    switch (a) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof u.precedence != "string" || typeof u.href != "string" || u.href === "")
          break;
        return !0;
      case "link":
        if (typeof u.rel != "string" || typeof u.href != "string" || u.href === "" || u.onLoad || u.onError)
          break;
        switch (u.rel) {
          case "stylesheet":
            return a = u.disabled, typeof u.precedence == "string" && a == null;
          default:
            return !0;
        }
      case "script":
        if (u.async && typeof u.async != "function" && typeof u.async != "symbol" && !u.onLoad && !u.onError && u.src && typeof u.src == "string")
          return !0;
    }
    return !1;
  }
  function W0(a) {
    return !(a.type === "stylesheet" && (a.state.loading & 3) === 0);
  }
  var Ec = null;
  function Uv() {
  }
  function Bv(a, u, f) {
    if (Ec === null) throw Error(l(475));
    var p = Ec;
    if (u.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (u.state.loading & 4) === 0) {
      if (u.instance === null) {
        var v = Ac(f.href), T = a.querySelector(
          gh(v)
        );
        if (T) {
          a = T._p, a !== null && typeof a == "object" && typeof a.then == "function" && (p.count++, p = Cc.bind(p), a.then(p, p)), u.state.loading |= 4, u.instance = T, On(T);
          return;
        }
        T = a.ownerDocument || a, f = $0(f), (v = bn.get(v)) && Z0(f, v), T = T.createElement("link"), On(T);
        var k = T;
        k._p = new Promise(function(D, q) {
          k.onload = D, k.onerror = q;
        }), I(T, "link", f), u.instance = T;
      }
      p.stylesheets === null && (p.stylesheets = /* @__PURE__ */ new Map()), p.stylesheets.set(u, a), (a = u.state.preload) && (u.state.loading & 3) === 0 && (p.count++, u = Cc.bind(p), a.addEventListener("load", u), a.addEventListener("error", u));
    }
  }
  function qv() {
    if (Ec === null) throw Error(l(475));
    var a = Ec;
    return a.stylesheets && a.count === 0 && bh(a, a.stylesheets), 0 < a.count ? function(u) {
      var f = setTimeout(function() {
        if (a.stylesheets && bh(a, a.stylesheets), a.unsuspend) {
          var p = a.unsuspend;
          a.unsuspend = null, p();
        }
      }, 6e4);
      return a.unsuspend = u, function() {
        a.unsuspend = null, clearTimeout(f);
      };
    } : null;
  }
  function Cc() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) bh(this, this.stylesheets);
      else if (this.unsuspend) {
        var a = this.unsuspend;
        this.unsuspend = null, a();
      }
    }
  }
  var vh = null;
  function bh(a, u) {
    a.stylesheets = null, a.unsuspend !== null && (a.count++, vh = /* @__PURE__ */ new Map(), u.forEach(F0, a), vh = null, Cc.call(a));
  }
  function F0(a, u) {
    if (!(u.state.loading & 4)) {
      var f = vh.get(a);
      if (f) var p = f.get(null);
      else {
        f = /* @__PURE__ */ new Map(), vh.set(a, f);
        for (var v = a.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), T = 0; T < v.length; T++) {
          var k = v[T];
          (k.nodeName === "LINK" || k.getAttribute("media") !== "not all") && (f.set(k.dataset.precedence, k), p = k);
        }
        p && f.set(null, p);
      }
      v = u.instance, k = v.getAttribute("data-precedence"), T = f.get(k) || p, T === p && f.set(null, v), f.set(k, v), this.count++, p = Cc.bind(this), v.addEventListener("load", p), v.addEventListener("error", p), T ? T.parentNode.insertBefore(v, T.nextSibling) : (a = a.nodeType === 9 ? a.head : a, a.insertBefore(v, a.firstChild)), u.state.loading |= 4;
    }
  }
  var li = {
    $$typeof: me,
    Provider: null,
    Consumer: null,
    _currentValue: ge,
    _currentValue2: ge,
    _threadCount: 0
  };
  function Ya(a, u, f, p, v, T, k, D) {
    this.tag = 1, this.containerInfo = a, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Ee(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ee(0), this.hiddenUpdates = Ee(null), this.identifierPrefix = p, this.onUncaughtError = v, this.onCaughtError = T, this.onRecoverableError = k, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = D, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function _v(a, u, f, p, v, T, k, D, q, P, ce, de) {
    return a = new Ya(
      a,
      u,
      f,
      k,
      D,
      q,
      P,
      de
    ), u = 1, T === !0 && (u |= 24), T = Hi(3, null, null, u), a.current = T, T.stateNode = a, u = Rg(), u.refCount++, a.pooledCache = u, u.refCount++, T.memoizedState = {
      element: p,
      isDehydrated: f,
      cache: u
    }, Uf(T), a;
  }
  function K0(a) {
    return a ? (a = Dr, a) : Dr;
  }
  function J0(a, u, f, p, v, T) {
    v = K0(v), p.context === null ? p.context = v : p.pendingContext = v, p = Do(u), p.payload = { element: f }, T = T === void 0 ? null : T, T !== null && (p.callback = T), f = Xi(a, p, u), f !== null && (Ji(f, a, u), Qr(f, a, u));
  }
  function I0(a, u) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var f = a.retryLane;
      a.retryLane = f !== 0 && f < u ? f : u;
    }
  }
  function Vp(a, u) {
    I0(a, u), (a = a.alternate) && I0(a, u);
  }
  function ey(a) {
    if (a.tag === 13) {
      var u = Ao(a, 67108864);
      u !== null && Ji(u, a, 67108864), Vp(a, 67108864);
    }
  }
  var Sh = !0;
  function Hv(a, u, f, p) {
    var v = F.T;
    F.T = null;
    var T = Z.p;
    try {
      Z.p = 2, Xp(a, u, f, p);
    } finally {
      Z.p = T, F.T = v;
    }
  }
  function Lv(a, u, f, p) {
    var v = F.T;
    F.T = null;
    var T = Z.p;
    try {
      Z.p = 8, Xp(a, u, f, p);
    } finally {
      Z.p = T, F.T = v;
    }
  }
  function Xp(a, u, f, p) {
    if (Sh) {
      var v = ty(p);
      if (v === null)
        hh(
          a,
          u,
          p,
          Th,
          f
        ), iy(a, p);
      else if (ly(
        v,
        a,
        u,
        f,
        p
      ))
        p.stopPropagation();
      else if (iy(a, p), u & 4 && -1 < SS.indexOf(a)) {
        for (; v !== null; ) {
          var T = Jn(v);
          if (T !== null)
            switch (T.tag) {
              case 3:
                if (T = T.stateNode, T.current.memoizedState.isDehydrated) {
                  var k = Kn(T.pendingLanes);
                  if (k !== 0) {
                    var D = T;
                    for (D.pendingLanes |= 2, D.entangledLanes |= 2; k; ) {
                      var q = 1 << 31 - Fn(k);
                      D.entanglements[1] |= q, k &= ~q;
                    }
                    va(T), (qt & 6) === 0 && (pp = _t() + 500, Xo(0));
                  }
                }
                break;
              case 13:
                D = Ao(T, 2), D !== null && Ji(D, T, 2), ah(), Vp(T, 2);
            }
          if (T = ty(p), T === null && hh(
            a,
            u,
            p,
            Th,
            f
          ), T === v) break;
          v = T;
        }
        v !== null && p.stopPropagation();
      } else
        hh(
          a,
          u,
          p,
          null,
          f
        );
    }
  }
  function ty(a) {
    return a = yr(a), ny(a);
  }
  var Th = null;
  function ny(a) {
    if (Th = null, a = os(a), a !== null) {
      var u = c(a);
      if (u === null) a = null;
      else {
        var f = u.tag;
        if (f === 13) {
          if (a = d(u), a !== null) return a;
          a = null;
        } else if (f === 3) {
          if (u.stateNode.current.memoizedState.isDehydrated)
            return u.tag === 3 ? u.stateNode.containerInfo : null;
          a = null;
        } else u !== a && (a = null);
      }
    }
    return Th = a, null;
  }
  function Vv(a) {
    switch (a) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (po()) {
          case mo:
            return 2;
          case ad:
            return 8;
          case lt:
          case fr:
            return 32;
          case hr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var jp = !1, Ta = null, $a = null, Po = null, Rc = /* @__PURE__ */ new Map(), xh = /* @__PURE__ */ new Map(), Vs = [], SS = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function iy(a, u) {
    switch (a) {
      case "focusin":
      case "focusout":
        Ta = null;
        break;
      case "dragenter":
      case "dragleave":
        $a = null;
        break;
      case "mouseover":
      case "mouseout":
        Po = null;
        break;
      case "pointerover":
      case "pointerout":
        Rc.delete(u.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        xh.delete(u.pointerId);
    }
  }
  function Za(a, u, f, p, v, T) {
    return a === null || a.nativeEvent !== T ? (a = {
      blockedOn: u,
      domEventName: f,
      eventSystemFlags: p,
      nativeEvent: T,
      targetContainers: [v]
    }, u !== null && (u = Jn(u), u !== null && ey(u)), a) : (a.eventSystemFlags |= p, u = a.targetContainers, v !== null && u.indexOf(v) === -1 && u.push(v), a);
  }
  function ly(a, u, f, p, v) {
    switch (u) {
      case "focusin":
        return Ta = Za(
          Ta,
          a,
          u,
          f,
          p,
          v
        ), !0;
      case "dragenter":
        return $a = Za(
          $a,
          a,
          u,
          f,
          p,
          v
        ), !0;
      case "mouseover":
        return Po = Za(
          Po,
          a,
          u,
          f,
          p,
          v
        ), !0;
      case "pointerover":
        var T = v.pointerId;
        return Rc.set(
          T,
          Za(
            Rc.get(T) || null,
            a,
            u,
            f,
            p,
            v
          )
        ), !0;
      case "gotpointercapture":
        return T = v.pointerId, xh.set(
          T,
          Za(
            xh.get(T) || null,
            a,
            u,
            f,
            p,
            v
          )
        ), !0;
    }
    return !1;
  }
  function ay(a) {
    var u = os(a.target);
    if (u !== null) {
      var f = c(u);
      if (f !== null) {
        if (u = f.tag, u === 13) {
          if (u = d(f), u !== null) {
            a.blockedOn = u, Pm(a.priority, function() {
              if (f.tag === 13) {
                var p = gl();
                p = Je(p);
                var v = Ao(f, p);
                v !== null && Ji(v, f, p), Vp(f, p);
              }
            });
            return;
          }
        } else if (u === 3 && f.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = f.tag === 3 ? f.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Ah(a) {
    if (a.blockedOn !== null) return !1;
    for (var u = a.targetContainers; 0 < u.length; ) {
      var f = ty(a.nativeEvent);
      if (f === null) {
        f = a.nativeEvent;
        var p = new f.constructor(
          f.type,
          f
        );
        hd = p, f.target.dispatchEvent(p), hd = null;
      } else
        return u = Jn(f), u !== null && ey(u), a.blockedOn = f, !1;
      u.shift();
    }
    return !0;
  }
  function oy(a, u, f) {
    Ah(a) && f.delete(u);
  }
  function Gp() {
    jp = !1, Ta !== null && Ah(Ta) && (Ta = null), $a !== null && Ah($a) && ($a = null), Po !== null && Ah(Po) && (Po = null), Rc.forEach(oy), xh.forEach(oy);
  }
  function Wo(a, u) {
    a.blockedOn === u && (a.blockedOn = null, jp || (jp = !0, o.unstable_scheduleCallback(
      o.unstable_NormalPriority,
      Gp
    )));
  }
  var Yp = null;
  function wh(a) {
    Yp !== a && (Yp = a, o.unstable_scheduleCallback(
      o.unstable_NormalPriority,
      function() {
        Yp === a && (Yp = null);
        for (var u = 0; u < a.length; u += 3) {
          var f = a[u], p = a[u + 1], v = a[u + 2];
          if (typeof p != "function") {
            if (ny(p || f) === null)
              continue;
            break;
          }
          var T = Jn(f);
          T !== null && (a.splice(u, 3), u -= 3, Kg(
            T,
            {
              pending: !0,
              data: v,
              method: f.method,
              action: p
            },
            p,
            v
          ));
        }
      }
    ));
  }
  function kc(a) {
    function u(q) {
      return Wo(q, a);
    }
    Ta !== null && Wo(Ta, a), $a !== null && Wo($a, a), Po !== null && Wo(Po, a), Rc.forEach(u), xh.forEach(u);
    for (var f = 0; f < Vs.length; f++) {
      var p = Vs[f];
      p.blockedOn === a && (p.blockedOn = null);
    }
    for (; 0 < Vs.length && (f = Vs[0], f.blockedOn === null); )
      ay(f), f.blockedOn === null && Vs.shift();
    if (f = (a.ownerDocument || a).$$reactFormReplay, f != null)
      for (p = 0; p < f.length; p += 3) {
        var v = f[p], T = f[p + 1], k = v[fi] || null;
        if (typeof T == "function")
          k || wh(f);
        else if (k) {
          var D = null;
          if (T && T.hasAttribute("formAction")) {
            if (v = T, k = T[fi] || null)
              D = k.formAction;
            else if (ny(v) !== null) continue;
          } else D = k.action;
          typeof D == "function" ? f[p + 1] = D : (f.splice(p, 3), p -= 3), wh(f);
        }
      }
  }
  function Xs(a) {
    this._internalRoot = a;
  }
  $p.prototype.render = Xs.prototype.render = function(a) {
    var u = this._internalRoot;
    if (u === null) throw Error(l(409));
    var f = u.current, p = gl();
    J0(f, p, a, u, null, null);
  }, $p.prototype.unmount = Xs.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var u = a.containerInfo;
      J0(a.current, 2, null, a, null, null), ah(), u[dr] = null;
    }
  };
  function $p(a) {
    this._internalRoot = a;
  }
  $p.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var u = Ma();
      a = { blockedOn: null, target: a, priority: u };
      for (var f = 0; f < Vs.length && u !== 0 && u < Vs[f].priority; f++) ;
      Vs.splice(f, 0, a), f === 0 && ay(a);
    }
  };
  var Xv = e.version;
  if (Xv !== "19.1.0")
    throw Error(
      l(
        527,
        Xv,
        "19.1.0"
      )
    );
  Z.findDOMNode = function(a) {
    var u = a._reactInternals;
    if (u === void 0)
      throw typeof a.render == "function" ? Error(l(188)) : (a = Object.keys(a).join(","), Error(l(268, a)));
    return a = y(u), a = a !== null ? b(a) : null, a = a === null ? null : a.stateNode, a;
  };
  var jv = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: F,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Xn = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Xn.isDisabled && Xn.supportsFiber)
      try {
        go = Xn.inject(
          jv
        ), ci = Xn;
      } catch {
      }
  }
  return Vy.createRoot = function(a, u) {
    if (!s(a)) throw Error(l(299));
    var f = !1, p = "", v = a0, T = oc, k = o0, D = null;
    return u != null && (u.unstable_strictMode === !0 && (f = !0), u.identifierPrefix !== void 0 && (p = u.identifierPrefix), u.onUncaughtError !== void 0 && (v = u.onUncaughtError), u.onCaughtError !== void 0 && (T = u.onCaughtError), u.onRecoverableError !== void 0 && (k = u.onRecoverableError), u.unstable_transitionCallbacks !== void 0 && (D = u.unstable_transitionCallbacks)), u = _v(
      a,
      1,
      !1,
      null,
      null,
      f,
      p,
      v,
      T,
      k,
      D,
      null
    ), a[dr] = u.current, fh(a), new Xs(u);
  }, Vy.hydrateRoot = function(a, u, f) {
    if (!s(a)) throw Error(l(299));
    var p = !1, v = "", T = a0, k = oc, D = o0, q = null, P = null;
    return f != null && (f.unstable_strictMode === !0 && (p = !0), f.identifierPrefix !== void 0 && (v = f.identifierPrefix), f.onUncaughtError !== void 0 && (T = f.onUncaughtError), f.onCaughtError !== void 0 && (k = f.onCaughtError), f.onRecoverableError !== void 0 && (D = f.onRecoverableError), f.unstable_transitionCallbacks !== void 0 && (q = f.unstable_transitionCallbacks), f.formState !== void 0 && (P = f.formState)), u = _v(
      a,
      1,
      !0,
      u,
      f ?? null,
      p,
      v,
      T,
      k,
      D,
      q,
      P
    ), u.context = K0(null), f = u.current, p = gl(), p = Je(p), v = Do(p), v.callback = null, Xi(f, v, p), f = p, u.current.lanes = f, _e(u, f), va(u), a[dr] = u.current, fh(a), new $p(u);
  }, Vy.version = "19.1.0", Vy;
}
var Xy = {}, PE;
function z3() {
  if (PE) return Xy;
  PE = 1;
  var o = {};
  /**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return o.NODE_ENV !== "production" && function() {
    function e(t, i) {
      for (t = t.memoizedState; t !== null && 0 < i; )
        t = t.next, i--;
      return t;
    }
    function n(t, i, r, h) {
      if (r >= i.length) return h;
      var g = i[r], O = zn(t) ? t.slice() : Ie({}, t);
      return O[g] = n(t[g], i, r + 1, h), O;
    }
    function l(t, i, r) {
      if (i.length !== r.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var h = 0; h < r.length - 1; h++)
          if (i[h] !== r[h]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return s(t, i, r, 0);
      }
    }
    function s(t, i, r, h) {
      var g = i[h], O = zn(t) ? t.slice() : Ie({}, t);
      return h + 1 === i.length ? (O[r[h]] = O[g], zn(O) ? O.splice(g, 1) : delete O[g]) : O[g] = s(
        t[g],
        i,
        r,
        h + 1
      ), O;
    }
    function c(t, i, r) {
      var h = i[r], g = zn(t) ? t.slice() : Ie({}, t);
      return r + 1 === i.length ? (zn(g) ? g.splice(h, 1) : delete g[h], g) : (g[h] = c(t[h], i, r + 1), g);
    }
    function d() {
      return !1;
    }
    function m() {
      return null;
    }
    function y() {
    }
    function b() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function S() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function A() {
    }
    function w(t) {
      var i = [];
      return t.forEach(function(r) {
        i.push(r);
      }), i.sort().join(", ");
    }
    function E(t, i, r, h) {
      return new rS(t, i, r, h);
    }
    function z(t, i) {
      t.context === Dc && (sh(t.current, 2, i, t, null, null), Vr());
    }
    function U(t, i) {
      if (Fa !== null) {
        var r = i.staleFamilies;
        i = i.updatedFamilies, As(), xr(
          t.current,
          i,
          r
        ), Vr();
      }
    }
    function V(t) {
      Fa = t;
    }
    function G(t) {
      return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
    }
    function ie(t) {
      var i = t, r = t;
      if (t.alternate) for (; i.return; ) i = i.return;
      else {
        t = i;
        do
          i = t, (i.flags & 4098) !== 0 && (r = i.return), t = i.return;
        while (t);
      }
      return i.tag === 3 ? r : null;
    }
    function me(t) {
      if (t.tag === 13) {
        var i = t.memoizedState;
        if (i === null && (t = t.alternate, t !== null && (i = t.memoizedState)), i !== null) return i.dehydrated;
      }
      return null;
    }
    function pe(t) {
      if (ie(t) !== t)
        throw Error("Unable to find node on an unmounted component.");
    }
    function ne(t) {
      var i = t.alternate;
      if (!i) {
        if (i = ie(t), i === null)
          throw Error("Unable to find node on an unmounted component.");
        return i !== t ? null : t;
      }
      for (var r = t, h = i; ; ) {
        var g = r.return;
        if (g === null) break;
        var O = g.alternate;
        if (O === null) {
          if (h = g.return, h !== null) {
            r = h;
            continue;
          }
          break;
        }
        if (g.child === O.child) {
          for (O = g.child; O; ) {
            if (O === r) return pe(g), t;
            if (O === h) return pe(g), i;
            O = O.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (r.return !== h.return) r = g, h = O;
        else {
          for (var x = !1, R = g.child; R; ) {
            if (R === r) {
              x = !0, r = g, h = O;
              break;
            }
            if (R === h) {
              x = !0, h = g, r = O;
              break;
            }
            R = R.sibling;
          }
          if (!x) {
            for (R = O.child; R; ) {
              if (R === r) {
                x = !0, r = O, h = g;
                break;
              }
              if (R === h) {
                x = !0, h = O, r = g;
                break;
              }
              R = R.sibling;
            }
            if (!x)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (r.alternate !== h)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (r.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return r.stateNode.current === r ? t : i;
    }
    function ye(t) {
      var i = t.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6) return t;
      for (t = t.child; t !== null; ) {
        if (i = ye(t), i !== null) return i;
        t = t.sibling;
      }
      return null;
    }
    function Oe(t) {
      return t === null || typeof t != "object" ? null : (t = dh && t[dh] || t["@@iterator"], typeof t == "function" ? t : null);
    }
    function we(t) {
      if (t == null) return null;
      if (typeof t == "function")
        return t.$$typeof === Gt ? null : t.displayName || t.name || null;
      if (typeof t == "string") return t;
      switch (t) {
        case Bs:
          return "Fragment";
        case fh:
          return "Profiler";
        case Pr:
          return "StrictMode";
        case _s:
          return "Suspense";
        case Mp:
          return "SuspenseList";
        case Qp:
          return "Activity";
      }
      if (typeof t == "object")
        switch (typeof t.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), t.$$typeof) {
          case at:
            return "Portal";
          case Ii:
            return (t.displayName || "Context") + ".Provider";
          case hh:
            return (t._context.displayName || "Context") + ".Consumer";
          case qs:
            var i = t.render;
            return t = t.displayName, t || (t = i.displayName || i.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
          case zp:
            return i = t.displayName || null, i !== null ? i : we(t.type) || "Memo";
          case yl:
            i = t._payload, t = t._init;
            try {
              return we(t(i));
            } catch {
            }
        }
      return null;
    }
    function Re(t) {
      return typeof t.tag == "number" ? Te(t) : typeof t.name == "string" ? t.name : null;
    }
    function Te(t) {
      var i = t.type;
      switch (t.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (i._context.displayName || "Context") + ".Consumer";
        case 10:
          return (i.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return t = i.render, t = t.displayName || t.name || "", i.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return i;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return we(i);
        case 8:
          return i === Pr ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof i == "function")
            return i.displayName || i.name || null;
          if (typeof i == "string") return i;
          break;
        case 29:
          if (i = t._debugInfo, i != null) {
            for (var r = i.length - 1; 0 <= r; r--)
              if (typeof i[r].name == "string") return i[r].name;
          }
          if (t.return !== null)
            return Te(t.return);
      }
      return null;
    }
    function ze(t) {
      return { current: t };
    }
    function fe(t, i) {
      0 > Va ? console.error("Unexpected pop.") : (i !== Tc[Va] && console.error("Unexpected Fiber popped."), t.current = ph[Va], ph[Va] = null, Tc[Va] = null, Va--);
    }
    function Qe(t, i, r) {
      Va++, ph[Va] = t.current, Tc[Va] = r, t.current = i;
    }
    function Ve(t) {
      return t === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), t;
    }
    function Xe(t, i) {
      Qe(Xa, i, t), Qe(Wr, t, t), Qe(Go, null, t);
      var r = i.nodeType;
      switch (r) {
        case 9:
        case 11:
          r = r === 9 ? "#document" : "#fragment", i = (i = i.documentElement) && (i = i.namespaceURI) ? Fi(i) : ou;
          break;
        default:
          if (r = i.tagName, i = i.namespaceURI)
            i = Fi(i), i = Ho(
              i,
              r
            );
          else
            switch (r) {
              case "svg":
                i = bm;
                break;
              case "math":
                i = Ob;
                break;
              default:
                i = ou;
            }
      }
      r = r.toLowerCase(), r = lg(null, r), r = {
        context: i,
        ancestorInfo: r
      }, fe(Go, t), Qe(Go, r, t);
    }
    function F(t) {
      fe(Go, t), fe(Wr, t), fe(Xa, t);
    }
    function Z() {
      return Ve(Go.current);
    }
    function ge(t) {
      t.memoizedState !== null && Qe(Np, t, t);
      var i = Ve(Go.current), r = t.type, h = Ho(i.context, r);
      r = lg(i.ancestorInfo, r), h = { context: h, ancestorInfo: r }, i !== h && (Qe(Wr, t, t), Qe(Go, h, t));
    }
    function Se(t) {
      Wr.current === t && (fe(Go, t), fe(Wr, t)), Np.current === t && (fe(Np, t), _y._currentValue = Gh);
    }
    function B(t) {
      return typeof Symbol == "function" && Symbol.toStringTag && t[Symbol.toStringTag] || t.constructor.name || "Object";
    }
    function L(t) {
      try {
        return se(t), !1;
      } catch {
        return !0;
      }
    }
    function se(t) {
      return "" + t;
    }
    function le(t, i) {
      if (L(t))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          B(t)
        ), se(t);
    }
    function Ae(t, i) {
      if (L(t))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          B(t)
        ), se(t);
    }
    function je(t) {
      if (L(t))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          B(t)
        ), se(t);
    }
    function Ne(t) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var i = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (i.isDisabled) return !0;
      if (!i.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        Fr = i.inject(t), ii = i;
      } catch (r) {
        console.error("React instrumentation encountered an error: %s.", r);
      }
      return !!i.checkDCE;
    }
    function Ke(t) {
      if (typeof ba == "function" && Y0(t), ii && typeof ii.setStrictMode == "function")
        try {
          ii.setStrictMode(Fr, t);
        } catch (i) {
          bn || (bn = !0, console.error(
            "React instrumentation encountered an error: %s",
            i
          ));
        }
    }
    function Nt(t) {
      ke = t;
    }
    function Ut() {
      ke !== null && typeof ke.markCommitStopped == "function" && ke.markCommitStopped();
    }
    function Rn(t) {
      ke !== null && typeof ke.markComponentRenderStarted == "function" && ke.markComponentRenderStarted(t);
    }
    function Ti() {
      ke !== null && typeof ke.markComponentRenderStopped == "function" && ke.markComponentRenderStopped();
    }
    function ho(t) {
      ke !== null && typeof ke.markRenderStarted == "function" && ke.markRenderStarted(t);
    }
    function cr() {
      ke !== null && typeof ke.markRenderStopped == "function" && ke.markRenderStopped();
    }
    function Da(t, i) {
      ke !== null && typeof ke.markStateUpdateScheduled == "function" && ke.markStateUpdateScheduled(t, i);
    }
    function ld(t) {
      return t >>>= 0, t === 0 ? 32 : 31 - (Yo(t) / bS | 0) | 0;
    }
    function af(t) {
      if (t & 1) return "SyncHydrationLane";
      if (t & 2) return "Sync";
      if (t & 4) return "InputContinuousHydration";
      if (t & 8) return "InputContinuous";
      if (t & 16) return "DefaultHydration";
      if (t & 32) return "Default";
      if (t & 128) return "TransitionHydration";
      if (t & 4194048) return "Transition";
      if (t & 62914560) return "Retry";
      if (t & 67108864) return "SelectiveHydration";
      if (t & 134217728) return "IdleHydration";
      if (t & 268435456) return "Idle";
      if (t & 536870912) return "Offscreen";
      if (t & 1073741824) return "Deferred";
    }
    function _t(t) {
      var i = t & 42;
      if (i !== 0) return i;
      switch (t & -t) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return t & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return t & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), t;
      }
    }
    function po(t, i, r) {
      var h = t.pendingLanes;
      if (h === 0) return 0;
      var g = 0, O = t.suspendedLanes, x = t.pingedLanes;
      t = t.warmLanes;
      var R = h & 134217727;
      return R !== 0 ? (h = R & ~O, h !== 0 ? g = _t(h) : (x &= R, x !== 0 ? g = _t(x) : r || (r = R & ~t, r !== 0 && (g = _t(r))))) : (R = h & ~O, R !== 0 ? g = _t(R) : x !== 0 ? g = _t(x) : r || (r = h & ~t, r !== 0 && (g = _t(r)))), g === 0 ? 0 : i !== 0 && i !== g && (i & O) === 0 && (O = g & -g, r = i & -i, O >= r || O === 32 && (r & 4194048) !== 0) ? i : g;
    }
    function mo(t, i) {
      return (t.pendingLanes & ~(t.suspendedLanes & ~t.pingedLanes) & i) === 0;
    }
    function ad(t, i) {
      switch (t) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return i + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function lt() {
      var t = Up;
      return Up <<= 1, (Up & 4194048) === 0 && (Up = 256), t;
    }
    function fr() {
      var t = $o;
      return $o <<= 1, ($o & 62914560) === 0 && ($o = 4194304), t;
    }
    function hr(t) {
      for (var i = [], r = 0; 31 > r; r++) i.push(t);
      return i;
    }
    function as(t, i) {
      t.pendingLanes |= i, i !== 268435456 && (t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0);
    }
    function od(t, i, r, h, g, O) {
      var x = t.pendingLanes;
      t.pendingLanes = r, t.suspendedLanes = 0, t.pingedLanes = 0, t.warmLanes = 0, t.expiredLanes &= r, t.entangledLanes &= r, t.errorRecoveryDisabledLanes &= r, t.shellSuspendCounter = 0;
      var R = t.entanglements, Q = t.expirationTimes, N = t.hiddenUpdates;
      for (r = x & ~r; 0 < r; ) {
        var ee = 31 - Vn(r), oe = 1 << ee;
        R[ee] = 0, Q[ee] = -1;
        var J = N[ee];
        if (J !== null)
          for (N[ee] = null, ee = 0; ee < J.length; ee++) {
            var re = J[ee];
            re !== null && (re.lane &= -536870913);
          }
        r &= ~oe;
      }
      h !== 0 && go(t, h, 0), O !== 0 && g === 0 && t.tag !== 0 && (t.suspendedLanes |= O & ~(x & ~i));
    }
    function go(t, i, r) {
      t.pendingLanes |= i, t.suspendedLanes &= ~i;
      var h = 31 - Vn(i);
      t.entangledLanes |= i, t.entanglements[h] = t.entanglements[h] | 1073741824 | r & 4194090;
    }
    function ci(t, i) {
      var r = t.entangledLanes |= i;
      for (t = t.entanglements; r; ) {
        var h = 31 - Vn(r), g = 1 << h;
        g & i | t[h] & i && (t[h] |= i), r &= ~g;
      }
    }
    function El(t) {
      switch (t) {
        case 2:
          t = 1;
          break;
        case 8:
          t = 4;
          break;
        case 32:
          t = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          t = 128;
          break;
        case 268435456:
          t = 134217728;
          break;
        default:
          t = 0;
      }
      return t;
    }
    function Fn(t, i, r) {
      if (Ll)
        for (t = t.pendingUpdatersLaneMap; 0 < r; ) {
          var h = 31 - Vn(r), g = 1 << h;
          t[h].add(i), r &= ~g;
        }
    }
    function of(t, i) {
      if (Ll)
        for (var r = t.pendingUpdatersLaneMap, h = t.memoizedUpdaters; 0 < i; ) {
          var g = 31 - Vn(i);
          t = 1 << g, g = r[g], 0 < g.size && (g.forEach(function(O) {
            var x = O.alternate;
            x !== null && h.has(x) || h.add(O);
          }), g.clear()), i &= ~t;
        }
    }
    function bu(t) {
      return t &= -t, Ol < t ? Ga < t ? (t & 134217727) !== 0 ? Zo : Bp : Ga : Ol;
    }
    function sf() {
      var t = Mt.p;
      return t !== 0 ? t : (t = window.event, t === void 0 ? Zo : Us(t.type));
    }
    function yo(t, i) {
      var r = Mt.p;
      try {
        return Mt.p = t, i();
      } finally {
        Mt.p = r;
      }
    }
    function Kl(t) {
      delete t[gi], delete t[el], delete t[qp], delete t[Ac], delete t[gh];
    }
    function Kn(t) {
      var i = t[gi];
      if (i) return i;
      for (var r = t.parentNode; r; ) {
        if (i = r[Ls] || r[gi]) {
          if (r = i.alternate, i.child !== null || r !== null && r.child !== null)
            for (t = yp(t); t !== null; ) {
              if (r = t[gi])
                return r;
              t = yp(t);
            }
          return i;
        }
        t = r, r = t.parentNode;
      }
      return null;
    }
    function Ui(t) {
      if (t = t[gi] || t[Ls]) {
        var i = t.tag;
        if (i === 5 || i === 6 || i === 13 || i === 26 || i === 27 || i === 3)
          return t;
      }
      return null;
    }
    function Cl(t) {
      var i = t.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6)
        return t.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function M(t) {
      var i = t[$0];
      return i || (i = t[$0] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
    }
    function Y(t) {
      t[yh] = !0;
    }
    function xe(t, i) {
      Ee(t, i), Ee(t + "Capture", i);
    }
    function Ee(t, i) {
      Sa[t] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        t
      ), Sa[t] = i;
      var r = t.toLowerCase();
      for (_p[r] = t, t === "onDoubleClick" && (_p.ondblclick = t), t = 0; t < i.length; t++)
        Kr.add(i[t]);
    }
    function _e(t, i) {
      Hp[i.type] || i.onChange || i.onInput || i.readOnly || i.disabled || i.value == null || console.error(
        t === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), i.onChange || i.readOnly || i.disabled || i.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function ht(t) {
      return ja.call(Oh, t) ? !0 : ja.call(Lp, t) ? !1 : Z0.test(t) ? Oh[t] = !0 : (Lp[t] = !0, console.error("Invalid attribute name: `%s`", t), !1);
    }
    function tt(t, i, r) {
      if (ht(i)) {
        if (!t.hasAttribute(i)) {
          switch (typeof r) {
            case "symbol":
            case "object":
              return r;
            case "function":
              return r;
            case "boolean":
              if (r === !1) return r;
          }
          return r === void 0 ? void 0 : null;
        }
        return t = t.getAttribute(i), t === "" && r === !0 ? !0 : (le(r, i), t === "" + r ? r : t);
      }
    }
    function St(t, i, r) {
      if (ht(i))
        if (r === null) t.removeAttribute(i);
        else {
          switch (typeof r) {
            case "undefined":
            case "function":
            case "symbol":
              t.removeAttribute(i);
              return;
            case "boolean":
              var h = i.toLowerCase().slice(0, 5);
              if (h !== "data-" && h !== "aria-") {
                t.removeAttribute(i);
                return;
              }
          }
          le(r, i), t.setAttribute(i, "" + r);
        }
    }
    function Je(t, i, r) {
      if (r === null) t.removeAttribute(i);
      else {
        switch (typeof r) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(i);
            return;
        }
        le(r, i), t.setAttribute(i, "" + r);
      }
    }
    function Sn(t, i, r, h) {
      if (h === null) t.removeAttribute(r);
      else {
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            t.removeAttribute(r);
            return;
        }
        le(h, r), t.setAttributeNS(i, r, "" + h);
      }
    }
    function Ma() {
    }
    function Pm() {
      if (wc === 0) {
        P0 = console.log, Nv = console.info, W0 = console.warn, Ec = console.error, Uv = console.group, Bv = console.groupCollapsed, qv = console.groupEnd;
        var t = {
          configurable: !0,
          enumerable: !0,
          value: Ma,
          writable: !0
        };
        Object.defineProperties(console, {
          info: t,
          log: t,
          warn: t,
          error: t,
          group: t,
          groupCollapsed: t,
          groupEnd: t
        });
      }
      wc++;
    }
    function za() {
      if (wc--, wc === 0) {
        var t = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: Ie({}, t, { value: P0 }),
          info: Ie({}, t, { value: Nv }),
          warn: Ie({}, t, { value: W0 }),
          error: Ie({}, t, { value: Ec }),
          group: Ie({}, t, { value: Uv }),
          groupCollapsed: Ie({}, t, { value: Bv }),
          groupEnd: Ie({}, t, { value: qv })
        });
      }
      0 > wc && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function $t(t) {
      if (Cc === void 0)
        try {
          throw Error();
        } catch (r) {
          var i = r.stack.trim().match(/\n( *(at )?)/);
          Cc = i && i[1] || "", vh = -1 < r.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < r.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + Cc + t + vh;
    }
    function fi(t, i) {
      if (!t || bh) return "";
      var r = F0.get(t);
      if (r !== void 0) return r;
      bh = !0, r = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var h = null;
      h = I.H, I.H = null, Pm();
      try {
        var g = {
          DetermineComponentFrameRoot: function() {
            try {
              if (i) {
                var J = function() {
                  throw Error();
                };
                if (Object.defineProperty(J.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(J, []);
                  } catch (He) {
                    var re = He;
                  }
                  Reflect.construct(t, [], J);
                } else {
                  try {
                    J.call();
                  } catch (He) {
                    re = He;
                  }
                  t.call(J.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (He) {
                  re = He;
                }
                (J = t()) && typeof J.catch == "function" && J.catch(function() {
                });
              }
            } catch (He) {
              if (He && re && typeof He.stack == "string")
                return [He.stack, re.stack];
            }
            return [null, null];
          }
        };
        g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var O = Object.getOwnPropertyDescriptor(
          g.DetermineComponentFrameRoot,
          "name"
        );
        O && O.configurable && Object.defineProperty(
          g.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var x = g.DetermineComponentFrameRoot(), R = x[0], Q = x[1];
        if (R && Q) {
          var N = R.split(`
`), ee = Q.split(`
`);
          for (x = O = 0; O < N.length && !N[O].includes(
            "DetermineComponentFrameRoot"
          ); )
            O++;
          for (; x < ee.length && !ee[x].includes(
            "DetermineComponentFrameRoot"
          ); )
            x++;
          if (O === N.length || x === ee.length)
            for (O = N.length - 1, x = ee.length - 1; 1 <= O && 0 <= x && N[O] !== ee[x]; )
              x--;
          for (; 1 <= O && 0 <= x; O--, x--)
            if (N[O] !== ee[x]) {
              if (O !== 1 || x !== 1)
                do
                  if (O--, x--, 0 > x || N[O] !== ee[x]) {
                    var oe = `
` + N[O].replace(
                      " at new ",
                      " at "
                    );
                    return t.displayName && oe.includes("<anonymous>") && (oe = oe.replace("<anonymous>", t.displayName)), typeof t == "function" && F0.set(t, oe), oe;
                  }
                while (1 <= O && 0 <= x);
              break;
            }
        }
      } finally {
        bh = !1, I.H = h, za(), Error.prepareStackTrace = r;
      }
      return N = (N = t ? t.displayName || t.name : "") ? $t(N) : "", typeof t == "function" && F0.set(t, N), N;
    }
    function dr(t) {
      var i = Error.prepareStackTrace;
      if (Error.prepareStackTrace = void 0, t = t.stack, Error.prepareStackTrace = i, t.startsWith(`Error: react-stack-top-frame
`) && (t = t.slice(29)), i = t.indexOf(`
`), i !== -1 && (t = t.slice(i + 1)), i = t.indexOf("react-stack-bottom-frame"), i !== -1 && (i = t.lastIndexOf(
        `
`,
        i
      )), i !== -1)
        t = t.slice(0, i);
      else return "";
      return t;
    }
    function Wm(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return $t(t.type);
        case 16:
          return $t("Lazy");
        case 13:
          return $t("Suspense");
        case 19:
          return $t("SuspenseList");
        case 0:
        case 15:
          return fi(t.type, !1);
        case 11:
          return fi(t.type.render, !1);
        case 1:
          return fi(t.type, !0);
        case 31:
          return $t("Activity");
        default:
          return "";
      }
    }
    function BO(t) {
      try {
        var i = "";
        do {
          i += Wm(t);
          var r = t._debugInfo;
          if (r)
            for (var h = r.length - 1; 0 <= h; h--) {
              var g = r[h];
              if (typeof g.name == "string") {
                var O = i, x = g.env, R = $t(
                  g.name + (x ? " [" + x + "]" : "")
                );
                i = O + R;
              }
            }
          t = t.return;
        } while (t);
        return i;
      } catch (Q) {
        return `
Error generating stack: ` + Q.message + `
` + Q.stack;
      }
    }
    function qO(t) {
      return (t = t ? t.displayName || t.name : "") ? $t(t) : "";
    }
    function rf() {
      if (li === null) return null;
      var t = li._debugOwner;
      return t != null ? Re(t) : null;
    }
    function uf() {
      if (li === null) return "";
      var t = li;
      try {
        var i = "";
        switch (t.tag === 6 && (t = t.return), t.tag) {
          case 26:
          case 27:
          case 5:
            i += $t(t.type);
            break;
          case 13:
            i += $t("Suspense");
            break;
          case 19:
            i += $t("SuspenseList");
            break;
          case 31:
            i += $t("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            t._debugOwner || i !== "" || (i += qO(
              t.type
            ));
            break;
          case 11:
            t._debugOwner || i !== "" || (i += qO(
              t.type.render
            ));
        }
        for (; t; )
          if (typeof t.tag == "number") {
            var r = t;
            t = r._debugOwner;
            var h = r._debugStack;
            t && h && (typeof h != "string" && (r._debugStack = h = dr(h)), h !== "" && (i += `
` + h));
          } else if (t.debugStack != null) {
            var g = t.debugStack;
            (t = t.owner) && g && (i += `
` + dr(g));
          } else break;
        var O = i;
      } catch (x) {
        O = `
Error generating stack: ` + x.message + `
` + x.stack;
      }
      return O;
    }
    function Ge(t, i, r, h, g, O, x) {
      var R = li;
      os(t);
      try {
        return t !== null && t._debugTask ? t._debugTask.run(
          i.bind(null, r, h, g, O, x)
        ) : i(r, h, g, O, x);
      } finally {
        os(R);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function os(t) {
      I.getCurrentStack = t === null ? null : uf, Ya = !1, li = t;
    }
    function Jn(t) {
      switch (typeof t) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return t;
        case "object":
          return je(t), t;
        default:
          return "";
      }
    }
    function Su(t) {
      var i = t.type;
      return (t = t.nodeName) && t.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
    }
    function Tu(t) {
      var i = Su(t) ? "checked" : "value", r = Object.getOwnPropertyDescriptor(
        t.constructor.prototype,
        i
      );
      je(t[i]);
      var h = "" + t[i];
      if (!t.hasOwnProperty(i) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var g = r.get, O = r.set;
        return Object.defineProperty(t, i, {
          configurable: !0,
          get: function() {
            return g.call(this);
          },
          set: function(x) {
            je(x), h = "" + x, O.call(this, x);
          }
        }), Object.defineProperty(t, i, {
          enumerable: r.enumerable
        }), {
          getValue: function() {
            return h;
          },
          setValue: function(x) {
            je(x), h = "" + x;
          },
          stopTracking: function() {
            t._valueTracker = null, delete t[i];
          }
        };
      }
    }
    function On(t) {
      t._valueTracker || (t._valueTracker = Tu(t));
    }
    function Fm(t) {
      if (!t) return !1;
      var i = t._valueTracker;
      if (!i) return !0;
      var r = i.getValue(), h = "";
      return t && (h = Su(t) ? t.checked ? "true" : "false" : t.value), t = h, t !== r ? (i.setValue(t), !0) : !1;
    }
    function cf(t) {
      if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
      try {
        return t.activeElement || t.body;
      } catch {
        return t.body;
      }
    }
    function qn(t) {
      return t.replace(
        _v,
        function(i) {
          return "\\" + i.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function pr(t, i) {
      i.checked === void 0 || i.defaultChecked === void 0 || J0 || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        rf() || "A component",
        i.type
      ), J0 = !0), i.value === void 0 || i.defaultValue === void 0 || K0 || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        rf() || "A component",
        i.type
      ), K0 = !0);
    }
    function Km(t, i, r, h, g, O, x, R) {
      t.name = "", x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" ? (le(x, "type"), t.type = x) : t.removeAttribute("type"), i != null ? x === "number" ? (i === 0 && t.value === "" || t.value != i) && (t.value = "" + Jn(i)) : t.value !== "" + Jn(i) && (t.value = "" + Jn(i)) : x !== "submit" && x !== "reset" || t.removeAttribute("value"), i != null ? sd(t, x, Jn(i)) : r != null ? sd(t, x, Jn(r)) : h != null && t.removeAttribute("value"), g == null && O != null && (t.defaultChecked = !!O), g != null && (t.checked = g && typeof g != "function" && typeof g != "symbol"), R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" ? (le(R, "name"), t.name = "" + Jn(R)) : t.removeAttribute("name");
    }
    function Jm(t, i, r, h, g, O, x, R) {
      if (O != null && typeof O != "function" && typeof O != "symbol" && typeof O != "boolean" && (le(O, "type"), t.type = O), i != null || r != null) {
        if (!(O !== "submit" && O !== "reset" || i != null))
          return;
        r = r != null ? "" + Jn(r) : "", i = i != null ? "" + Jn(i) : r, R || i === t.value || (t.value = i), t.defaultValue = i;
      }
      h = h ?? g, h = typeof h != "function" && typeof h != "symbol" && !!h, t.checked = R ? t.checked : !!h, t.defaultChecked = !!h, x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" && (le(x, "name"), t.name = x);
    }
    function sd(t, i, r) {
      i === "number" && cf(t.ownerDocument) === t || t.defaultValue === "" + r || (t.defaultValue = "" + r);
    }
    function _O(t, i) {
      i.value == null && (typeof i.children == "object" && i.children !== null ? H0.Children.forEach(i.children, function(r) {
        r == null || typeof r == "string" || typeof r == "number" || typeof r == "bigint" || Vp || (Vp = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : i.dangerouslySetInnerHTML == null || ey || (ey = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), i.selected == null || I0 || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), I0 = !0);
    }
    function ff() {
      var t = rf();
      return t ? `

Check the render method of \`` + t + "`." : "";
    }
    function Oo(t, i, r, h) {
      if (t = t.options, i) {
        i = {};
        for (var g = 0; g < r.length; g++)
          i["$" + r[g]] = !0;
        for (r = 0; r < t.length; r++)
          g = i.hasOwnProperty("$" + t[r].value), t[r].selected !== g && (t[r].selected = g), g && h && (t[r].defaultSelected = !0);
      } else {
        for (r = "" + Jn(r), i = null, g = 0; g < t.length; g++) {
          if (t[g].value === r) {
            t[g].selected = !0, h && (t[g].defaultSelected = !0);
            return;
          }
          i !== null || t[g].disabled || (i = t[g]);
        }
        i !== null && (i.selected = !0);
      }
    }
    function Qa(t, i) {
      for (t = 0; t < Hv.length; t++) {
        var r = Hv[t];
        if (i[r] != null) {
          var h = zn(i[r]);
          i.multiple && !h ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            r,
            ff()
          ) : !i.multiple && h && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            r,
            ff()
          );
        }
      }
      i.value === void 0 || i.defaultValue === void 0 || Sh || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), Sh = !0);
    }
    function rd(t, i) {
      i.value === void 0 || i.defaultValue === void 0 || Lv || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        rf() || "A component"
      ), Lv = !0), i.children != null && i.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function Im(t, i, r) {
      if (i != null && (i = "" + Jn(i), i !== t.value && (t.value = i), r == null)) {
        t.defaultValue !== i && (t.defaultValue = i);
        return;
      }
      t.defaultValue = r != null ? "" + Jn(r) : "";
    }
    function mr(t, i, r, h) {
      if (i == null) {
        if (h != null) {
          if (r != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (zn(h)) {
            if (1 < h.length)
              throw Error("<textarea> can only have at most one child.");
            h = h[0];
          }
          r = h;
        }
        r == null && (r = ""), i = r;
      }
      r = Jn(i), t.defaultValue = r, h = t.textContent, h === r && h !== "" && h !== null && (t.value = h);
    }
    function ud(t, i) {
      return t.serverProps === void 0 && t.serverTail.length === 0 && t.children.length === 1 && 3 < t.distanceFromLeaf && t.distanceFromLeaf > 15 - i ? ud(t.children[0], i) : t;
    }
    function xi(t) {
      return "  " + "  ".repeat(t);
    }
    function xu(t) {
      return "+ " + "  ".repeat(t);
    }
    function ss(t) {
      return "- " + "  ".repeat(t);
    }
    function rl(t) {
      switch (t.tag) {
        case 26:
        case 27:
        case 5:
          return t.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return t = t.type, t.displayName || t.name || null;
        case 11:
          return t = t.type.render, t.displayName || t.name || null;
        case 1:
          return t = t.type, t.displayName || t.name || null;
        default:
          return null;
      }
    }
    function Au(t, i) {
      return Xp.test(t) ? (t = JSON.stringify(t), t.length > i - 2 ? 8 > i ? '{"..."}' : "{" + t.slice(0, i - 7) + '..."}' : "{" + t + "}") : t.length > i ? 5 > i ? '{"..."}' : t.slice(0, i - 3) + "..." : t;
    }
    function cd(t, i, r) {
      var h = 120 - 2 * r;
      if (i === null)
        return xu(r) + Au(t, h) + `
`;
      if (typeof i == "string") {
        for (var g = 0; g < i.length && g < t.length && i.charCodeAt(g) === t.charCodeAt(g); g++) ;
        return g > h - 8 && 10 < g && (t = "..." + t.slice(g - 8), i = "..." + i.slice(g - 8)), xu(r) + Au(t, h) + `
` + ss(r) + Au(i, h) + `
`;
      }
      return xi(r) + Au(t, h) + `
`;
    }
    function wu(t) {
      return Object.prototype.toString.call(t).replace(/^\[object (.*)\]$/, function(i, r) {
        return r;
      });
    }
    function Eu(t, i) {
      switch (typeof t) {
        case "string":
          return t = JSON.stringify(t), t.length > i ? 5 > i ? '"..."' : t.slice(0, i - 4) + '..."' : t;
        case "object":
          if (t === null) return "null";
          if (zn(t)) return "[...]";
          if (t.$$typeof === jo)
            return (i = we(t.type)) ? "<" + i + ">" : "<...>";
          var r = wu(t);
          if (r === "Object") {
            r = "", i -= 2;
            for (var h in t)
              if (t.hasOwnProperty(h)) {
                var g = JSON.stringify(h);
                if (g !== '"' + h + '"' && (h = g), i -= h.length - 2, g = Eu(
                  t[h],
                  15 > i ? i : 15
                ), i -= g.length, 0 > i) {
                  r += r === "" ? "..." : ", ...";
                  break;
                }
                r += (r === "" ? "" : ",") + h + ":" + g;
              }
            return "{" + r + "}";
          }
          return r;
        case "function":
          return (i = t.displayName || t.name) ? "function " + i : "function";
        default:
          return String(t);
      }
    }
    function vo(t, i) {
      return typeof t != "string" || Xp.test(t) ? "{" + Eu(t, i - 2) + "}" : t.length > i - 2 ? 5 > i ? '"..."' : '"' + t.slice(0, i - 5) + '..."' : '"' + t + '"';
    }
    function eg(t, i, r) {
      var h = 120 - r.length - t.length, g = [], O;
      for (O in i)
        if (i.hasOwnProperty(O) && O !== "children") {
          var x = vo(
            i[O],
            120 - r.length - O.length - 1
          );
          h -= O.length + x.length + 2, g.push(O + "=" + x);
        }
      return g.length === 0 ? r + "<" + t + `>
` : 0 < h ? r + "<" + t + " " + g.join(" ") + `>
` : r + "<" + t + `
` + r + "  " + g.join(`
` + r + "  ") + `
` + r + `>
`;
    }
    function Rl(t, i, r) {
      var h = "", g = Ie({}, i), O;
      for (O in t)
        if (t.hasOwnProperty(O)) {
          delete g[O];
          var x = 120 - 2 * r - O.length - 2, R = Eu(t[O], x);
          i.hasOwnProperty(O) ? (x = Eu(i[O], x), h += xu(r) + O + ": " + R + `
`, h += ss(r) + O + ": " + x + `
`) : h += xu(r) + O + ": " + R + `
`;
        }
      for (var Q in g)
        g.hasOwnProperty(Q) && (t = Eu(
          g[Q],
          120 - 2 * r - Q.length - 2
        ), h += ss(r) + Q + ": " + t + `
`);
      return h;
    }
    function tg(t, i, r, h) {
      var g = "", O = /* @__PURE__ */ new Map();
      for (N in r)
        r.hasOwnProperty(N) && O.set(
          N.toLowerCase(),
          N
        );
      if (O.size === 1 && O.has("children"))
        g += eg(
          t,
          i,
          xi(h)
        );
      else {
        for (var x in i)
          if (i.hasOwnProperty(x) && x !== "children") {
            var R = 120 - 2 * (h + 1) - x.length - 1, Q = O.get(x.toLowerCase());
            if (Q !== void 0) {
              O.delete(x.toLowerCase());
              var N = i[x];
              Q = r[Q];
              var ee = vo(
                N,
                R
              );
              R = vo(
                Q,
                R
              ), typeof N == "object" && N !== null && typeof Q == "object" && Q !== null && wu(N) === "Object" && wu(Q) === "Object" && (2 < Object.keys(N).length || 2 < Object.keys(Q).length || -1 < ee.indexOf("...") || -1 < R.indexOf("...")) ? g += xi(h + 1) + x + `={{
` + Rl(
                N,
                Q,
                h + 2
              ) + xi(h + 1) + `}}
` : (g += xu(h + 1) + x + "=" + ee + `
`, g += ss(h + 1) + x + "=" + R + `
`);
            } else
              g += xi(h + 1) + x + "=" + vo(i[x], R) + `
`;
          }
        O.forEach(function(oe) {
          if (oe !== "children") {
            var J = 120 - 2 * (h + 1) - oe.length - 1;
            g += ss(h + 1) + oe + "=" + vo(r[oe], J) + `
`;
          }
        }), g = g === "" ? xi(h) + "<" + t + `>
` : xi(h) + "<" + t + `
` + g + xi(h) + `>
`;
      }
      return t = r.children, i = i.children, typeof t == "string" || typeof t == "number" || typeof t == "bigint" ? (O = "", (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (O = "" + i), g += cd(O, "" + t, h + 1)) : (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (g = t == null ? g + cd("" + i, null, h + 1) : g + cd("" + i, void 0, h + 1)), g;
    }
    function ng(t, i) {
      var r = rl(t);
      if (r === null) {
        for (r = "", t = t.child; t; )
          r += ng(t, i), t = t.sibling;
        return r;
      }
      return xi(i) + "<" + r + `>
`;
    }
    function hf(t, i) {
      var r = ud(t, i);
      if (r !== t && (t.children.length !== 1 || t.children[0] !== r))
        return xi(i) + `...
` + hf(r, i + 1);
      r = "";
      var h = t.fiber._debugInfo;
      if (h)
        for (var g = 0; g < h.length; g++) {
          var O = h[g].name;
          typeof O == "string" && (r += xi(i) + "<" + O + `>
`, i++);
        }
      if (h = "", g = t.fiber.pendingProps, t.fiber.tag === 6)
        h = cd(g, t.serverProps, i), i++;
      else if (O = rl(t.fiber), O !== null)
        if (t.serverProps === void 0) {
          h = i;
          var x = 120 - 2 * h - O.length - 2, R = "";
          for (N in g)
            if (g.hasOwnProperty(N) && N !== "children") {
              var Q = vo(g[N], 15);
              if (x -= N.length + Q.length + 2, 0 > x) {
                R += " ...";
                break;
              }
              R += " " + N + "=" + Q;
            }
          h = xi(h) + "<" + O + R + `>
`, i++;
        } else
          t.serverProps === null ? (h = eg(
            O,
            g,
            xu(i)
          ), i++) : typeof t.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (h = tg(
            O,
            g,
            t.serverProps,
            i
          ), i++);
      var N = "";
      for (g = t.fiber.child, O = 0; g && O < t.children.length; )
        x = t.children[O], x.fiber === g ? (N += hf(x, i), O++) : N += ng(g, i), g = g.sibling;
      for (g && 0 < t.children.length && (N += xi(i) + `...
`), g = t.serverTail, t.serverProps === null && i--, t = 0; t < g.length; t++)
        O = g[t], N = typeof O == "string" ? N + (ss(i) + Au(O, 120 - 2 * i) + `
`) : N + eg(
          O.type,
          O.props,
          ss(i)
        );
      return r + h + N;
    }
    function rs(t) {
      try {
        return `

` + hf(t, 0);
      } catch {
        return "";
      }
    }
    function ig(t, i, r) {
      for (var h = i, g = null, O = 0; h; )
        h === t && (O = 0), g = {
          fiber: h,
          children: g !== null ? [g] : [],
          serverProps: h === i ? r : h === t ? null : void 0,
          serverTail: [],
          distanceFromLeaf: O
        }, O++, h = h.return;
      return g !== null ? rs(g).replaceAll(/^[+-]/gm, ">") : "";
    }
    function lg(t, i) {
      var r = Ie({}, t || jp), h = { tag: i };
      return Th.indexOf(i) !== -1 && (r.aTagInScope = null, r.buttonTagInScope = null, r.nobrTagInScope = null), ny.indexOf(i) !== -1 && (r.pTagInButtonScope = null), ty.indexOf(i) !== -1 && i !== "address" && i !== "div" && i !== "p" && (r.listItemTagAutoclosing = null, r.dlItemTagAutoclosing = null), r.current = h, i === "form" && (r.formTag = h), i === "a" && (r.aTagInScope = h), i === "button" && (r.buttonTagInScope = h), i === "nobr" && (r.nobrTagInScope = h), i === "p" && (r.pTagInButtonScope = h), i === "li" && (r.listItemTagAutoclosing = h), (i === "dd" || i === "dt") && (r.dlItemTagAutoclosing = h), i === "#document" || i === "html" ? r.containerTagInScope = null : r.containerTagInScope || (r.containerTagInScope = h), t !== null || i !== "#document" && i !== "html" && i !== "body" ? r.implicitRootScope === !0 && (r.implicitRootScope = !1) : r.implicitRootScope = !0, r;
    }
    function gr(t, i, r) {
      switch (i) {
        case "select":
          return t === "hr" || t === "option" || t === "optgroup" || t === "script" || t === "template" || t === "#text";
        case "optgroup":
          return t === "option" || t === "#text";
        case "option":
          return t === "#text";
        case "tr":
          return t === "th" || t === "td" || t === "style" || t === "script" || t === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return t === "tr" || t === "style" || t === "script" || t === "template";
        case "colgroup":
          return t === "col" || t === "template";
        case "table":
          return t === "caption" || t === "colgroup" || t === "tbody" || t === "tfoot" || t === "thead" || t === "style" || t === "script" || t === "template";
        case "head":
          return t === "base" || t === "basefont" || t === "bgsound" || t === "link" || t === "meta" || t === "title" || t === "noscript" || t === "noframes" || t === "style" || t === "script" || t === "template";
        case "html":
          if (r) break;
          return t === "head" || t === "body" || t === "frameset";
        case "frameset":
          return t === "frame";
        case "#document":
          if (!r) return t === "html";
      }
      switch (t) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i !== "h1" && i !== "h2" && i !== "h3" && i !== "h4" && i !== "h5" && i !== "h6";
        case "rp":
        case "rt":
          return Vv.indexOf(i) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return i == null;
        case "head":
          return r || i === null;
        case "html":
          return r && i === "#document" || i === null;
        case "body":
          return r && (i === "#document" || i === "html") || i === null;
      }
      return !0;
    }
    function tS(t, i) {
      switch (t) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i.pTagInButtonScope;
        case "form":
          return i.formTag || i.pTagInButtonScope;
        case "li":
          return i.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return i.dlItemTagAutoclosing;
        case "button":
          return i.buttonTagInScope;
        case "a":
          return i.aTagInScope;
        case "nobr":
          return i.nobrTagInScope;
      }
      return null;
    }
    function ag(t, i) {
      for (; t; ) {
        switch (t.tag) {
          case 5:
          case 26:
          case 27:
            if (t.type === i) return t;
        }
        t = t.return;
      }
      return null;
    }
    function fd(t, i) {
      i = i || jp;
      var r = i.current;
      if (i = (r = gr(
        t,
        r && r.tag,
        i.implicitRootScope
      ) ? null : r) ? null : tS(t, i), i = r || i, !i) return !0;
      var h = i.tag;
      if (i = String(!!r) + "|" + t + "|" + h, Ta[i]) return !1;
      Ta[i] = !0;
      var g = (i = li) ? ag(i.return, h) : null, O = i !== null && g !== null ? ig(g, i, null) : "", x = "<" + t + ">";
      return r ? (r = "", h === "table" && t === "tr" && (r += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        x,
        h,
        r,
        O
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        x,
        h,
        O
      ), i && (t = i.return, g === null || t === null || g === t && t._debugOwner === i._debugOwner || Ge(g, function() {
        console.error(
          `<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,
          h,
          x
        );
      })), !1;
    }
    function Cu(t, i, r) {
      if (r || gr("#text", i, !1))
        return !0;
      if (r = "#text|" + i, Ta[r]) return !1;
      Ta[r] = !0;
      var h = (r = li) ? ag(r, i) : null;
      return r = r !== null && h !== null ? ig(
        h,
        r,
        r.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(t) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        i,
        r
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        i,
        r
      ), !1;
    }
    function df(t, i) {
      if (i) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
          r.nodeValue = i;
          return;
        }
      }
      t.textContent = i;
    }
    function nS(t) {
      return t.replace(SS, function(i, r) {
        return r.toUpperCase();
      });
    }
    function pf(t, i, r) {
      var h = i.indexOf("--") === 0;
      h || (-1 < i.indexOf("-") ? Za.hasOwnProperty(i) && Za[i] || (Za[i] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        i,
        nS(i.replace(Vs, "ms-"))
      )) : xh.test(i) ? Za.hasOwnProperty(i) && Za[i] || (Za[i] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        i,
        i.charAt(0).toUpperCase() + i.slice(1)
      )) : !iy.test(r) || ly.hasOwnProperty(r) && ly[r] || (ly[r] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        i,
        r.replace(iy, "")
      )), typeof r == "number" && (isNaN(r) ? ay || (ay = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        i
      )) : isFinite(r) || Ah || (Ah = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        i
      )))), r == null || typeof r == "boolean" || r === "" ? h ? t.setProperty(i, "") : i === "float" ? t.cssFloat = "" : t[i] = "" : h ? t.setProperty(i, r) : typeof r != "number" || r === 0 || oy.has(i) ? i === "float" ? t.cssFloat = r : (Ae(r, i), t[i] = ("" + r).trim()) : t[i] = r + "px";
    }
    function hd(t, i, r) {
      if (i != null && typeof i != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (i && Object.freeze(i), t = t.style, r != null) {
        if (i) {
          var h = {};
          if (r) {
            for (var g in r)
              if (r.hasOwnProperty(g) && !i.hasOwnProperty(g))
                for (var O = $a[g] || [g], x = 0; x < O.length; x++)
                  h[O[x]] = g;
          }
          for (var R in i)
            if (i.hasOwnProperty(R) && (!r || r[R] !== i[R]))
              for (g = $a[R] || [R], O = 0; O < g.length; O++)
                h[g[O]] = R;
          R = {};
          for (var Q in i)
            for (g = $a[Q] || [Q], O = 0; O < g.length; O++)
              R[g[O]] = Q;
          Q = {};
          for (var N in h)
            if (g = h[N], (O = R[N]) && g !== O && (x = g + "," + O, !Q[x])) {
              Q[x] = !0, x = console;
              var ee = i[g];
              x.error.call(
                x,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                ee == null || typeof ee == "boolean" || ee === "" ? "Removing" : "Updating",
                g,
                O
              );
            }
        }
        for (var oe in r)
          !r.hasOwnProperty(oe) || i != null && i.hasOwnProperty(oe) || (oe.indexOf("--") === 0 ? t.setProperty(oe, "") : oe === "float" ? t.cssFloat = "" : t[oe] = "");
        for (var J in i)
          N = i[J], i.hasOwnProperty(J) && r[J] !== N && pf(t, J, N);
      } else
        for (h in i)
          i.hasOwnProperty(h) && pf(t, h, i[h]);
    }
    function yr(t) {
      if (t.indexOf("-") === -1) return !1;
      switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function Or(t) {
      return Yp.get(t) || t;
    }
    function Ru(t, i) {
      if (ja.call(Xs, i) && Xs[i])
        return !0;
      if (Xv.test(i)) {
        if (t = "aria-" + i.slice(4).toLowerCase(), t = kc.hasOwnProperty(t) ? t : null, t == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            i
          ), Xs[i] = !0;
        if (i !== t)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            i,
            t
          ), Xs[i] = !0;
      }
      if ($p.test(i)) {
        if (t = i.toLowerCase(), t = kc.hasOwnProperty(t) ? t : null, t == null) return Xs[i] = !0, !1;
        i !== t && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          i,
          t
        ), Xs[i] = !0);
      }
      return !0;
    }
    function HO(t, i) {
      var r = [], h;
      for (h in i)
        Ru(t, h) || r.push(h);
      i = r.map(function(g) {
        return "`" + g + "`";
      }).join(", "), r.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        t
      ) : 1 < r.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        t
      );
    }
    function og(t, i, r, h) {
      if (ja.call(Xn, i) && Xn[i])
        return !0;
      var g = i.toLowerCase();
      if (g === "onfocusin" || g === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), Xn[i] = !0;
      if (typeof r == "function" && (t === "form" && i === "action" || t === "input" && i === "formAction" || t === "button" && i === "formAction"))
        return !0;
      if (h != null) {
        if (t = h.possibleRegistrationNames, h.registrationNameDependencies.hasOwnProperty(i))
          return !0;
        if (h = t.hasOwnProperty(g) ? t[g] : null, h != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            i,
            h
          ), Xn[i] = !0;
        if (a.test(i))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            i
          ), Xn[i] = !0;
      } else if (a.test(i))
        return u.test(i) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          i
        ), Xn[i] = !0;
      if (f.test(i) || p.test(i)) return !0;
      if (g === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), Xn[i] = !0;
      if (g === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), Xn[i] = !0;
      if (g === "is" && r !== null && r !== void 0 && typeof r != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof r
        ), Xn[i] = !0;
      if (typeof r == "number" && isNaN(r))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          i
        ), Xn[i] = !0;
      if (wh.hasOwnProperty(g)) {
        if (g = wh[g], g !== i)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            i,
            g
          ), Xn[i] = !0;
      } else if (i !== g)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          i,
          g
        ), Xn[i] = !0;
      switch (i) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof r) {
        case "boolean":
          switch (i) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return g = i.toLowerCase().slice(0, 5), g === "data-" || g === "aria-" ? !0 : (r ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                r,
                i,
                i,
                r,
                i
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                r,
                i,
                i,
                r,
                i,
                i,
                i
              ), Xn[i] = !0);
          }
        case "function":
        case "symbol":
          return Xn[i] = !0, !1;
        case "string":
          if (r === "false" || r === "true") {
            switch (i) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              r,
              i,
              r === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              i,
              r
            ), Xn[i] = !0;
          }
      }
      return !0;
    }
    function LO(t, i, r) {
      var h = [], g;
      for (g in i)
        og(t, g, i[g], r) || h.push(g);
      i = h.map(function(O) {
        return "`" + O + "`";
      }).join(", "), h.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        t
      ) : 1 < h.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        t
      );
    }
    function bo(t) {
      return v.test("" + t) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : t;
    }
    function Jl(t) {
      return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
    }
    function dd(t) {
      var i = Ui(t);
      if (i && (t = i.stateNode)) {
        var r = t[el] || null;
        e: switch (t = i.stateNode, i.type) {
          case "input":
            if (Km(
              t,
              r.value,
              r.defaultValue,
              r.defaultValue,
              r.checked,
              r.defaultChecked,
              r.type,
              r.name
            ), i = r.name, r.type === "radio" && i != null) {
              for (r = t; r.parentNode; ) r = r.parentNode;
              for (le(i, "name"), r = r.querySelectorAll(
                'input[name="' + qn(
                  "" + i
                ) + '"][type="radio"]'
              ), i = 0; i < r.length; i++) {
                var h = r[i];
                if (h !== t && h.form === t.form) {
                  var g = h[el] || null;
                  if (!g)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  Km(
                    h,
                    g.value,
                    g.defaultValue,
                    g.defaultValue,
                    g.checked,
                    g.defaultChecked,
                    g.type,
                    g.name
                  );
                }
              }
              for (i = 0; i < r.length; i++)
                h = r[i], h.form === t.form && Fm(h);
            }
            break e;
          case "textarea":
            Im(t, r.value, r.defaultValue);
            break e;
          case "select":
            i = r.value, i != null && Oo(t, !!r.multiple, i, !1);
        }
      }
    }
    function ku(t, i, r) {
      if (q) return t(i, r);
      q = !0;
      try {
        var h = t(i);
        return h;
      } finally {
        if (q = !1, (k !== null || D !== null) && (Vr(), k && (i = k, t = D, D = k = null, dd(i), t)))
          for (i = 0; i < t.length; i++) dd(t[i]);
      }
    }
    function kl(t, i) {
      var r = t.stateNode;
      if (r === null) return null;
      var h = r[el] || null;
      if (h === null) return null;
      r = h[i];
      e: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (h = !h.disabled) || (t = t.type, h = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !h;
          break e;
        default:
          t = !1;
      }
      if (t) return null;
      if (r && typeof r != "function")
        throw Error(
          "Expected `" + i + "` listener to be a function, instead got a value of `" + typeof r + "` type."
        );
      return r;
    }
    function pd() {
      if (Pe) return Pe;
      var t, i = te, r = i.length, h, g = "value" in K ? K.value : K.textContent, O = g.length;
      for (t = 0; t < r && i[t] === g[t]; t++) ;
      var x = r - t;
      for (h = 1; h <= x && i[r - h] === g[O - h]; h++) ;
      return Pe = g.slice(t, 1 < h ? 1 - h : void 0);
    }
    function vr(t) {
      var i = t.keyCode;
      return "charCode" in t ? (t = t.charCode, t === 0 && i === 13 && (t = 13)) : t = i, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
    }
    function mf() {
      return !0;
    }
    function gf() {
      return !1;
    }
    function In(t) {
      function i(r, h, g, O, x) {
        this._reactName = r, this._targetInst = g, this.type = h, this.nativeEvent = O, this.target = x, this.currentTarget = null;
        for (var R in t)
          t.hasOwnProperty(R) && (r = t[R], this[R] = r ? r(O) : O[R]);
        return this.isDefaultPrevented = (O.defaultPrevented != null ? O.defaultPrevented : O.returnValue === !1) ? mf : gf, this.isPropagationStopped = gf, this;
      }
      return Ie(i.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var r = this.nativeEvent;
          r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = mf);
        },
        stopPropagation: function() {
          var r = this.nativeEvent;
          r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = mf);
        },
        persist: function() {
        },
        isPersistent: mf
      }), i;
    }
    function VO(t) {
      var i = this.nativeEvent;
      return i.getModifierState ? i.getModifierState(t) : (t = Az[t]) ? !!i[t] : !1;
    }
    function hi() {
      return VO;
    }
    function us(t, i) {
      switch (t) {
        case "keyup":
          return Bz.indexOf(i.keyCode) !== -1;
        case "keydown":
          return i.keyCode !== XA;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function yf(t) {
      return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
    }
    function Of(t, i) {
      switch (t) {
        case "compositionend":
          return yf(i);
        case "keypress":
          return i.which !== GA ? null : ($A = !0, YA);
        case "textInput":
          return t = i.data, t === YA && $A ? null : t;
        default:
          return null;
      }
    }
    function iS(t, i) {
      if (Zp)
        return t === "compositionend" || !xS && us(t, i) ? (t = pd(), Pe = te = K = null, Zp = !1, t) : null;
      switch (t) {
        case "paste":
          return null;
        case "keypress":
          if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
            if (i.char && 1 < i.char.length)
              return i.char;
            if (i.which)
              return String.fromCharCode(i.which);
          }
          return null;
        case "compositionend":
          return jA && i.locale !== "ko" ? null : i.data;
        default:
          return null;
      }
    }
    function md(t) {
      var i = t && t.nodeName && t.nodeName.toLowerCase();
      return i === "input" ? !!_z[t.type] : i === "textarea";
    }
    function sg(t) {
      if (!P) return !1;
      t = "on" + t;
      var i = t in document;
      return i || (i = document.createElement("div"), i.setAttribute(t, "return;"), i = typeof i[t] == "function"), i;
    }
    function Du(t, i, r, h) {
      k ? D ? D.push(h) : D = [h] : k = h, i = mi(i, "onChange"), 0 < i.length && (r = new zt(
        "onChange",
        "change",
        null,
        r,
        h
      ), t.push({ event: r, listeners: i }));
    }
    function gd(t) {
      x0(t, 0);
    }
    function vf(t) {
      var i = Cl(t);
      if (Fm(i)) return t;
    }
    function XO(t, i) {
      if (t === "change") return i;
    }
    function jO() {
      ry && (ry.detachEvent("onpropertychange", GO), uy = ry = null);
    }
    function GO(t) {
      if (t.propertyName === "value" && vf(uy)) {
        var i = [];
        Du(
          i,
          uy,
          t,
          Jl(t)
        ), ku(gd, i);
      }
    }
    function rg(t, i, r) {
      t === "focusin" ? (jO(), ry = i, uy = r, ry.attachEvent("onpropertychange", GO)) : t === "focusout" && jO();
    }
    function lS(t) {
      if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return vf(uy);
    }
    function aS(t, i) {
      if (t === "click") return vf(i);
    }
    function oS(t, i) {
      if (t === "input" || t === "change")
        return vf(i);
    }
    function sS(t, i) {
      return t === i && (t !== 0 || 1 / t === 1 / i) || t !== t && i !== i;
    }
    function bf(t, i) {
      if (vl(t, i)) return !0;
      if (typeof t != "object" || t === null || typeof i != "object" || i === null)
        return !1;
      var r = Object.keys(t), h = Object.keys(i);
      if (r.length !== h.length) return !1;
      for (h = 0; h < r.length; h++) {
        var g = r[h];
        if (!ja.call(i, g) || !vl(t[g], i[g]))
          return !1;
      }
      return !0;
    }
    function ug(t) {
      for (; t && t.firstChild; ) t = t.firstChild;
      return t;
    }
    function YO(t, i) {
      var r = ug(t);
      t = 0;
      for (var h; r; ) {
        if (r.nodeType === 3) {
          if (h = t + r.textContent.length, t <= i && h >= i)
            return { node: r, offset: i - t };
          t = h;
        }
        e: {
          for (; r; ) {
            if (r.nextSibling) {
              r = r.nextSibling;
              break e;
            }
            r = r.parentNode;
          }
          r = void 0;
        }
        r = ug(r);
      }
    }
    function $O(t, i) {
      return t && i ? t === i ? !0 : t && t.nodeType === 3 ? !1 : i && i.nodeType === 3 ? $O(t, i.parentNode) : "contains" in t ? t.contains(i) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(i) & 16) : !1 : !1;
    }
    function ZO(t) {
      t = t != null && t.ownerDocument != null && t.ownerDocument.defaultView != null ? t.ownerDocument.defaultView : window;
      for (var i = cf(t.document); i instanceof t.HTMLIFrameElement; ) {
        try {
          var r = typeof i.contentWindow.location.href == "string";
        } catch {
          r = !1;
        }
        if (r) t = i.contentWindow;
        else break;
        i = cf(t.document);
      }
      return i;
    }
    function cg(t) {
      var i = t && t.nodeName && t.nodeName.toLowerCase();
      return i && (i === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || i === "textarea" || t.contentEditable === "true");
    }
    function yd(t, i, r) {
      var h = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
      wS || Pp == null || Pp !== cf(h) || (h = Pp, "selectionStart" in h && cg(h) ? h = { start: h.selectionStart, end: h.selectionEnd } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(), h = {
        anchorNode: h.anchorNode,
        anchorOffset: h.anchorOffset,
        focusNode: h.focusNode,
        focusOffset: h.focusOffset
      }), cy && bf(cy, h) || (cy = h, h = mi(AS, "onSelect"), 0 < h.length && (i = new zt(
        "onSelect",
        "select",
        null,
        i,
        r
      ), t.push({ event: i, listeners: h }), i.target = Pp)));
    }
    function br(t, i) {
      var r = {};
      return r[t.toLowerCase()] = i.toLowerCase(), r["Webkit" + t] = "webkit" + i, r["Moz" + t] = "moz" + i, r;
    }
    function Sr(t) {
      if (ES[t]) return ES[t];
      if (!Wp[t]) return t;
      var i = Wp[t], r;
      for (r in i)
        if (i.hasOwnProperty(r) && r in PA)
          return ES[t] = i[r];
      return t;
    }
    function Il(t, i) {
      IA.set(t, i), xe(i, [t]);
    }
    function Bi(t, i) {
      if (typeof t == "object" && t !== null) {
        var r = RS.get(t);
        return r !== void 0 ? r : (i = {
          value: t,
          source: i,
          stack: BO(i)
        }, RS.set(t, i), i);
      }
      return {
        value: t,
        source: i,
        stack: BO(i)
      };
    }
    function Od() {
      for (var t = Fp, i = DS = Fp = 0; i < t; ) {
        var r = Wa[i];
        Wa[i++] = null;
        var h = Wa[i];
        Wa[i++] = null;
        var g = Wa[i];
        Wa[i++] = null;
        var O = Wa[i];
        if (Wa[i++] = null, h !== null && g !== null) {
          var x = h.pending;
          x === null ? g.next = g : (g.next = x.next, x.next = g), h.pending = g;
        }
        O !== 0 && PO(r, g, O);
      }
    }
    function vd(t, i, r, h) {
      Wa[Fp++] = t, Wa[Fp++] = i, Wa[Fp++] = r, Wa[Fp++] = h, DS |= h, t.lanes |= h, t = t.alternate, t !== null && (t.lanes |= h);
    }
    function fg(t, i, r, h) {
      return vd(t, i, r, h), bd(t);
    }
    function qi(t, i) {
      return vd(t, null, null, i), bd(t);
    }
    function PO(t, i, r) {
      t.lanes |= r;
      var h = t.alternate;
      h !== null && (h.lanes |= r);
      for (var g = !1, O = t.return; O !== null; )
        O.childLanes |= r, h = O.alternate, h !== null && (h.childLanes |= r), O.tag === 22 && (t = O.stateNode, t === null || t._visibility & kS || (g = !0)), t = O, O = O.return;
      return t.tag === 3 ? (O = t.stateNode, g && i !== null && (g = 31 - Vn(r), t = O.hiddenUpdates, h = t[g], h === null ? t[g] = [i] : h.push(i), i.lane = r | 536870912), O) : null;
    }
    function bd(t) {
      if (zy > s3)
        throw Hh = zy = 0, Qy = oT = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      Hh > r3 && (Hh = 0, Qy = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), t.alternate === null && (t.flags & 4098) !== 0 && v0(t);
      for (var i = t, r = i.return; r !== null; )
        i.alternate === null && (i.flags & 4098) !== 0 && v0(t), i = r, r = i.return;
      return i.tag === 3 ? i.stateNode : null;
    }
    function Tr(t) {
      if (Fa === null) return t;
      var i = Fa(t);
      return i === void 0 ? t : i.current;
    }
    function hg(t) {
      if (Fa === null) return t;
      var i = Fa(t);
      return i === void 0 ? t != null && typeof t.render == "function" && (i = Tr(t.render), t.render !== i) ? (i = { $$typeof: qs, render: i }, t.displayName !== void 0 && (i.displayName = t.displayName), i) : t : i.current;
    }
    function WO(t, i) {
      if (Fa === null) return !1;
      var r = t.elementType;
      i = i.type;
      var h = !1, g = typeof i == "object" && i !== null ? i.$$typeof : null;
      switch (t.tag) {
        case 1:
          typeof i == "function" && (h = !0);
          break;
        case 0:
          (typeof i == "function" || g === yl) && (h = !0);
          break;
        case 11:
          (g === qs || g === yl) && (h = !0);
          break;
        case 14:
        case 15:
          (g === zp || g === yl) && (h = !0);
          break;
        default:
          return !1;
      }
      return !!(h && (t = Fa(r), t !== void 0 && t === Fa(i)));
    }
    function Sd(t) {
      Fa !== null && typeof WeakSet == "function" && (Kp === null && (Kp = /* @__PURE__ */ new WeakSet()), Kp.add(t));
    }
    function xr(t, i, r) {
      var h = t.alternate, g = t.child, O = t.sibling, x = t.tag, R = t.type, Q = null;
      switch (x) {
        case 0:
        case 15:
        case 1:
          Q = R;
          break;
        case 11:
          Q = R.render;
      }
      if (Fa === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var N = !1;
      R = !1, Q !== null && (Q = Fa(Q), Q !== void 0 && (r.has(Q) ? R = !0 : i.has(Q) && (x === 1 ? R = !0 : N = !0))), Kp !== null && (Kp.has(t) || h !== null && Kp.has(h)) && (R = !0), R && (t._debugNeedsRemount = !0), (R || N) && (h = qi(t, 2), h !== null && mt(h, t, 2)), g === null || R || xr(
        g,
        i,
        r
      ), O !== null && xr(
        O,
        i,
        r
      );
    }
    function rS(t, i, r, h) {
      this.tag = t, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = h, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, tw || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function Td(t) {
      return t = t.prototype, !(!t || !t.isReactComponent);
    }
    function Na(t, i) {
      var r = t.alternate;
      switch (r === null ? (r = E(
        t.tag,
        i,
        t.key,
        t.mode
      ), r.elementType = t.elementType, r.type = t.type, r.stateNode = t.stateNode, r._debugOwner = t._debugOwner, r._debugStack = t._debugStack, r._debugTask = t._debugTask, r._debugHookTypes = t._debugHookTypes, r.alternate = t, t.alternate = r) : (r.pendingProps = i, r.type = t.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null, r.actualDuration = -0, r.actualStartTime = -1.1), r.flags = t.flags & 65011712, r.childLanes = t.childLanes, r.lanes = t.lanes, r.child = t.child, r.memoizedProps = t.memoizedProps, r.memoizedState = t.memoizedState, r.updateQueue = t.updateQueue, i = t.dependencies, r.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, r.sibling = t.sibling, r.index = t.index, r.ref = t.ref, r.refCleanup = t.refCleanup, r.selfBaseDuration = t.selfBaseDuration, r.treeBaseDuration = t.treeBaseDuration, r._debugInfo = t._debugInfo, r._debugNeedsRemount = t._debugNeedsRemount, r.tag) {
        case 0:
        case 15:
          r.type = Tr(t.type);
          break;
        case 1:
          r.type = Tr(t.type);
          break;
        case 11:
          r.type = hg(t.type);
      }
      return r;
    }
    function dg(t, i) {
      t.flags &= 65011714;
      var r = t.alternate;
      return r === null ? (t.childLanes = 0, t.lanes = i, t.child = null, t.subtreeFlags = 0, t.memoizedProps = null, t.memoizedState = null, t.updateQueue = null, t.dependencies = null, t.stateNode = null, t.selfBaseDuration = 0, t.treeBaseDuration = 0) : (t.childLanes = r.childLanes, t.lanes = r.lanes, t.child = r.child, t.subtreeFlags = 0, t.deletions = null, t.memoizedProps = r.memoizedProps, t.memoizedState = r.memoizedState, t.updateQueue = r.updateQueue, t.type = r.type, i = r.dependencies, t.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, t.selfBaseDuration = r.selfBaseDuration, t.treeBaseDuration = r.treeBaseDuration), t;
    }
    function xd(t, i, r, h, g, O) {
      var x = 0, R = t;
      if (typeof t == "function")
        Td(t) && (x = 1), R = Tr(R);
      else if (typeof t == "string")
        x = Z(), x = Sp(t, r, x) ? 26 : t === "html" || t === "head" || t === "body" ? 27 : 5;
      else
        e: switch (t) {
          case Qp:
            return i = E(31, r, i, g), i.elementType = Qp, i.lanes = O, i;
          case Bs:
            return Dl(
              r.children,
              g,
              O,
              i
            );
          case Pr:
            x = 8, g |= tl, g |= Fo;
            break;
          case fh:
            return t = r, h = g, typeof t.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof t.id
            ), i = E(12, t, i, h | Ri), i.elementType = fh, i.lanes = O, i.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, i;
          case _s:
            return i = E(13, r, i, g), i.elementType = _s, i.lanes = O, i;
          case Mp:
            return i = E(19, r, i, g), i.elementType = Mp, i.lanes = O, i;
          default:
            if (typeof t == "object" && t !== null)
              switch (t.$$typeof) {
                case Dv:
                case Ii:
                  x = 10;
                  break e;
                case hh:
                  x = 9;
                  break e;
                case qs:
                  x = 11, R = hg(R);
                  break e;
                case zp:
                  x = 14;
                  break e;
                case yl:
                  x = 16, R = null;
                  break e;
              }
            R = "", (t === void 0 || typeof t == "object" && t !== null && Object.keys(t).length === 0) && (R += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), t === null ? r = "null" : zn(t) ? r = "array" : t !== void 0 && t.$$typeof === jo ? (r = "<" + (we(t.type) || "Unknown") + " />", R = " Did you accidentally export a JSX literal instead of a component?") : r = typeof t, (x = h ? Re(h) : null) && (R += `

Check the render method of \`` + x + "`."), x = 29, r = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (r + "." + R)
            ), R = null;
        }
      return i = E(x, r, i, g), i.elementType = t, i.type = R, i.lanes = O, i._debugOwner = h, i;
    }
    function Sf(t, i, r) {
      return i = xd(
        t.type,
        t.key,
        t.props,
        t._owner,
        i,
        r
      ), i._debugOwner = t._owner, i._debugStack = t._debugStack, i._debugTask = t._debugTask, i;
    }
    function Dl(t, i, r, h) {
      return t = E(7, t, h, i), t.lanes = r, t;
    }
    function pg(t, i, r) {
      return t = E(6, t, null, i), t.lanes = r, t;
    }
    function mg(t, i, r) {
      return i = E(
        4,
        t.children !== null ? t.children : [],
        t.key,
        i
      ), i.lanes = r, i.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
      }, i;
    }
    function Ar(t, i) {
      ea(), Jp[Ip++] = Yv, Jp[Ip++] = Gv, Gv = t, Yv = i;
    }
    function gg(t, i, r) {
      ea(), Ka[Ja++] = Jr, Ka[Ja++] = Ir, Ka[Ja++] = Ch, Ch = t;
      var h = Jr;
      t = Ir;
      var g = 32 - Vn(h) - 1;
      h &= ~(1 << g), r += 1;
      var O = 32 - Vn(i) + g;
      if (30 < O) {
        var x = g - g % 5;
        O = (h & (1 << x) - 1).toString(32), h >>= x, g -= x, Jr = 1 << 32 - Vn(i) + g | r << g | h, Ir = O + t;
      } else
        Jr = 1 << O | r << g | h, Ir = t;
    }
    function Ad(t) {
      ea(), t.return !== null && (Ar(t, 1), gg(t, 1, 0));
    }
    function wr(t) {
      for (; t === Gv; )
        Gv = Jp[--Ip], Jp[Ip] = null, Yv = Jp[--Ip], Jp[Ip] = null;
      for (; t === Ch; )
        Ch = Ka[--Ja], Ka[Ja] = null, Ir = Ka[--Ja], Ka[Ja] = null, Jr = Ka[--Ja], Ka[Ja] = null;
    }
    function ea() {
      Rt || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function Er(t, i) {
      if (t.return === null) {
        if (Ia === null)
          Ia = {
            fiber: t,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: i
          };
        else {
          if (Ia.fiber !== t)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          Ia.distanceFromLeaf > i && (Ia.distanceFromLeaf = i);
        }
        return Ia;
      }
      var r = Er(
        t.return,
        i + 1
      ).children;
      return 0 < r.length && r[r.length - 1].fiber === t ? (r = r[r.length - 1], r.distanceFromLeaf > i && (r.distanceFromLeaf = i), r) : (i = {
        fiber: t,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: i
      }, r.push(i), i);
    }
    function Mu(t, i) {
      eu || (t = Er(t, 0), t.serverProps = null, i !== null && (i = gp(i), t.serverTail.push(i)));
    }
    function cs(t) {
      var i = "", r = Ia;
      throw r !== null && (Ia = null, i = rs(r)), Qu(
        Bi(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + i
          ),
          t
        )
      ), MS;
    }
    function yg(t) {
      var i = t.stateNode, r = t.type, h = t.memoizedProps;
      switch (i[gi] = t, i[el] = h, qo(r, h), r) {
        case "dialog":
          gt("cancel", i), gt("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          gt("load", i);
          break;
        case "video":
        case "audio":
          for (r = 0; r < Ny.length; r++)
            gt(Ny[r], i);
          break;
        case "source":
          gt("error", i);
          break;
        case "img":
        case "image":
        case "link":
          gt("error", i), gt("load", i);
          break;
        case "details":
          gt("toggle", i);
          break;
        case "input":
          _e("input", h), gt("invalid", i), pr(i, h), Jm(
            i,
            h.value,
            h.defaultValue,
            h.checked,
            h.defaultChecked,
            h.type,
            h.name,
            !0
          ), On(i);
          break;
        case "option":
          _O(i, h);
          break;
        case "select":
          _e("select", h), gt("invalid", i), Qa(i, h);
          break;
        case "textarea":
          _e("textarea", h), gt("invalid", i), rd(i, h), mr(
            i,
            h.value,
            h.defaultValue,
            h.children
          ), On(i);
      }
      r = h.children, typeof r != "string" && typeof r != "number" && typeof r != "bigint" || i.textContent === "" + r || h.suppressHydrationWarning === !0 || Yr(i.textContent, r) ? (h.popover != null && (gt("beforetoggle", i), gt("toggle", i)), h.onScroll != null && gt("scroll", i), h.onScrollEnd != null && gt("scrollend", i), h.onClick != null && (i.onclick = Cs), i = !0) : i = !1, i || cs(t);
    }
    function wd(t) {
      for (bl = t.return; bl; )
        switch (bl.tag) {
          case 5:
          case 13:
            js = !1;
            return;
          case 27:
          case 3:
            js = !0;
            return;
          default:
            bl = bl.return;
        }
    }
    function Cr(t) {
      if (t !== bl) return !1;
      if (!Rt)
        return wd(t), Rt = !0, !1;
      var i = t.tag, r;
      if ((r = i !== 3 && i !== 27) && ((r = i === 5) && (r = t.type, r = !(r !== "form" && r !== "button") || ks(t.type, t.memoizedProps)), r = !r), r && En) {
        for (r = En; r; ) {
          var h = Er(t, 0), g = gp(r);
          h.serverTail.push(g), r = g.type === "Suspense" ? mc(r) : Ki(r.nextSibling);
        }
        cs(t);
      }
      if (wd(t), i === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        En = mc(t);
      } else
        i === 27 ? (i = En, Mn(t.type) ? (t = OT, OT = null, En = t) : En = i) : En = bl ? Ki(t.stateNode.nextSibling) : null;
      return !0;
    }
    function zu() {
      En = bl = null, eu = Rt = !1;
    }
    function Og() {
      var t = Rh;
      return t !== null && (xl === null ? xl = t : xl.push.apply(
        xl,
        t
      ), Rh = null), t;
    }
    function Qu(t) {
      Rh === null ? Rh = [t] : Rh.push(t);
    }
    function FO() {
      var t = Ia;
      if (t !== null) {
        Ia = null;
        for (var i = rs(t); 0 < t.children.length; )
          t = t.children[0];
        Ge(t.fiber, function() {
          console.error(
            `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
            "https://react.dev/link/hydration-mismatch",
            i
          );
        });
      }
    }
    function Ed() {
      em = $v = null, tm = !1;
    }
    function fs(t, i, r) {
      Qe(zS, i._currentValue, t), i._currentValue = r, Qe(QS, i._currentRenderer, t), i._currentRenderer !== void 0 && i._currentRenderer !== null && i._currentRenderer !== aw && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), i._currentRenderer = aw;
    }
    function So(t, i) {
      t._currentValue = zS.current;
      var r = QS.current;
      fe(QS, i), t._currentRenderer = r, fe(zS, i);
    }
    function vg(t, i, r) {
      for (; t !== null; ) {
        var h = t.alternate;
        if ((t.childLanes & i) !== i ? (t.childLanes |= i, h !== null && (h.childLanes |= i)) : h !== null && (h.childLanes & i) !== i && (h.childLanes |= i), t === r) break;
        t = t.return;
      }
      t !== r && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Ai(t, i, r, h) {
      var g = t.child;
      for (g !== null && (g.return = t); g !== null; ) {
        var O = g.dependencies;
        if (O !== null) {
          var x = g.child;
          O = O.firstContext;
          e: for (; O !== null; ) {
            var R = O;
            O = g;
            for (var Q = 0; Q < i.length; Q++)
              if (R.context === i[Q]) {
                O.lanes |= r, R = O.alternate, R !== null && (R.lanes |= r), vg(
                  O.return,
                  r,
                  t
                ), h || (x = null);
                break e;
              }
            O = R.next;
          }
        } else if (g.tag === 18) {
          if (x = g.return, x === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          x.lanes |= r, O = x.alternate, O !== null && (O.lanes |= r), vg(
            x,
            r,
            t
          ), x = null;
        } else x = g.child;
        if (x !== null) x.return = g;
        else
          for (x = g; x !== null; ) {
            if (x === t) {
              x = null;
              break;
            }
            if (g = x.sibling, g !== null) {
              g.return = x.return, x = g;
              break;
            }
            x = x.return;
          }
        g = x;
      }
    }
    function To(t, i, r, h) {
      t = null;
      for (var g = i, O = !1; g !== null; ) {
        if (!O) {
          if ((g.flags & 524288) !== 0) O = !0;
          else if ((g.flags & 262144) !== 0) break;
        }
        if (g.tag === 10) {
          var x = g.alternate;
          if (x === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (x = x.memoizedProps, x !== null) {
            var R = g.type;
            vl(g.pendingProps.value, x.value) || (t !== null ? t.push(R) : t = [R]);
          }
        } else if (g === Np.current) {
          if (x = g.alternate, x === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          x.memoizedState.memoizedState !== g.memoizedState.memoizedState && (t !== null ? t.push(_y) : t = [_y]);
        }
        g = g.return;
      }
      t !== null && Ai(
        i,
        t,
        r,
        h
      ), i.flags |= 262144;
    }
    function Tf(t) {
      for (t = t.firstContext; t !== null; ) {
        if (!vl(
          t.context._currentValue,
          t.memoizedValue
        ))
          return !0;
        t = t.next;
      }
      return !1;
    }
    function hs(t) {
      $v = t, em = null, t = t.dependencies, t !== null && (t.firstContext = null);
    }
    function Wt(t) {
      return tm && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), Cd($v, t);
    }
    function xf(t, i) {
      return $v === null && hs(t), Cd(t, i);
    }
    function Cd(t, i) {
      var r = i._currentValue;
      if (i = { context: i, memoizedValue: r, next: null }, em === null) {
        if (t === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        em = i, t.dependencies = {
          lanes: 0,
          firstContext: i,
          _debugThenableState: null
        }, t.flags |= 524288;
      } else em = em.next = i;
      return r;
    }
    function bg() {
      return {
        controller: new $z(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Ml(t) {
      t.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), t.refCount++;
    }
    function Rr(t) {
      t.refCount--, 0 > t.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), t.refCount === 0 && Zz(Pz, function() {
        t.controller.abort();
      });
    }
    function ul() {
      var t = kh;
      return kh = 0, t;
    }
    function Nu(t) {
      var i = kh;
      return kh = t, i;
    }
    function Uu(t) {
      var i = kh;
      return kh += t, i;
    }
    function xo(t) {
      Vl = nm(), 0 > t.actualStartTime && (t.actualStartTime = Vl);
    }
    function ds(t) {
      if (0 <= Vl) {
        var i = nm() - Vl;
        t.actualDuration += i, t.selfBaseDuration = i, Vl = -1;
      }
    }
    function Rd(t) {
      if (0 <= Vl) {
        var i = nm() - Vl;
        t.actualDuration += i, Vl = -1;
      }
    }
    function ta() {
      if (0 <= Vl) {
        var t = nm() - Vl;
        Vl = -1, kh += t;
      }
    }
    function di() {
      Vl = nm();
    }
    function Af(t) {
      for (var i = t.child; i; )
        t.actualDuration += i.actualDuration, i = i.sibling;
    }
    function KO(t, i) {
      if (fy === null) {
        var r = fy = [];
        NS = 0, Dh = hp(), im = {
          status: "pending",
          value: void 0,
          then: function(h) {
            r.push(h);
          }
        };
      }
      return NS++, i.then(Sg, Sg), i;
    }
    function Sg() {
      if (--NS === 0 && fy !== null) {
        im !== null && (im.status = "fulfilled");
        var t = fy;
        fy = null, Dh = 0, im = null;
        for (var i = 0; i < t.length; i++) (0, t[i])();
      }
    }
    function uS(t, i) {
      var r = [], h = {
        status: "pending",
        value: null,
        reason: null,
        then: function(g) {
          r.push(g);
        }
      };
      return t.then(
        function() {
          h.status = "fulfilled", h.value = i;
          for (var g = 0; g < r.length; g++) (0, r[g])(i);
        },
        function(g) {
          for (h.status = "rejected", h.reason = g, g = 0; g < r.length; g++)
            (0, r[g])(void 0);
        }
      ), h;
    }
    function Tg() {
      var t = Mh.current;
      return t !== null ? t : It.pooledCache;
    }
    function kd(t, i) {
      i === null ? Qe(Mh, Mh.current, t) : Qe(Mh, i.pool, t);
    }
    function xg() {
      var t = Tg();
      return t === null ? null : { parent: ai._currentValue, pool: t };
    }
    function Ag() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function Dd(t) {
      return t = t.status, t === "fulfilled" || t === "rejected";
    }
    function _i() {
    }
    function wg(t, i, r) {
      I.actQueue !== null && (I.didUsePromise = !0);
      var h = t.thenables;
      switch (r = h[r], r === void 0 ? h.push(i) : r !== i && (t.didWarnAboutUncachedPromise || (t.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), i.then(_i, _i), i = r), i.status) {
        case "fulfilled":
          return i.value;
        case "rejected":
          throw t = i.reason, fl(t), t;
        default:
          if (typeof i.status == "string")
            i.then(_i, _i);
          else {
            if (t = It, t !== null && 100 < t.shellSuspendCounter)
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            t = i, t.status = "pending", t.then(
              function(g) {
                if (i.status === "pending") {
                  var O = i;
                  O.status = "fulfilled", O.value = g;
                }
              },
              function(g) {
                if (i.status === "pending") {
                  var O = i;
                  O.status = "rejected", O.reason = g;
                }
              }
            );
          }
          switch (i.status) {
            case "fulfilled":
              return i.value;
            case "rejected":
              throw t = i.reason, fl(t), t;
          }
          throw vy = i, Jv = !0, Oy;
      }
    }
    function cl() {
      if (vy === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var t = vy;
      return vy = null, Jv = !1, t;
    }
    function fl(t) {
      if (t === Oy || t === Kv)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function ps(t) {
      t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function wf(t, i) {
      t = t.updateQueue, i.updateQueue === t && (i.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        callbacks: null
      });
    }
    function na(t) {
      return {
        lane: t,
        tag: cw,
        payload: null,
        callback: null,
        next: null
      };
    }
    function ia(t, i, r) {
      var h = t.updateQueue;
      if (h === null) return null;
      if (h = h.shared, qS === h && !dw) {
        var g = Te(t);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          g
        ), dw = !0;
      }
      return (Ht & Tl) !== xa ? (g = h.pending, g === null ? i.next = i : (i.next = g.next, g.next = i), h.pending = i, i = bd(t), PO(t, null, r), i) : (vd(t, h, i, r), bd(t));
    }
    function kr(t, i, r) {
      if (i = i.updateQueue, i !== null && (i = i.shared, (r & 4194048) !== 0)) {
        var h = i.lanes;
        h &= t.pendingLanes, r |= h, i.lanes = r, ci(t, r);
      }
    }
    function Ao(t, i) {
      var r = t.updateQueue, h = t.alternate;
      if (h !== null && (h = h.updateQueue, r === h)) {
        var g = null, O = null;
        if (r = r.firstBaseUpdate, r !== null) {
          do {
            var x = {
              lane: r.lane,
              tag: r.tag,
              payload: r.payload,
              callback: null,
              next: null
            };
            O === null ? g = O = x : O = O.next = x, r = r.next;
          } while (r !== null);
          O === null ? g = O = i : O = O.next = i;
        } else g = O = i;
        r = {
          baseState: h.baseState,
          firstBaseUpdate: g,
          lastBaseUpdate: O,
          shared: h.shared,
          callbacks: h.callbacks
        }, t.updateQueue = r;
        return;
      }
      t = r.lastBaseUpdate, t === null ? r.firstBaseUpdate = i : t.next = i, r.lastBaseUpdate = i;
    }
    function Bu() {
      if (_S) {
        var t = im;
        if (t !== null) throw t;
      }
    }
    function ms(t, i, r, h) {
      _S = !1;
      var g = t.updateQueue;
      Mc = !1, qS = g.shared;
      var O = g.firstBaseUpdate, x = g.lastBaseUpdate, R = g.shared.pending;
      if (R !== null) {
        g.shared.pending = null;
        var Q = R, N = Q.next;
        Q.next = null, x === null ? O = N : x.next = N, x = Q;
        var ee = t.alternate;
        ee !== null && (ee = ee.updateQueue, R = ee.lastBaseUpdate, R !== x && (R === null ? ee.firstBaseUpdate = N : R.next = N, ee.lastBaseUpdate = Q));
      }
      if (O !== null) {
        var oe = g.baseState;
        x = 0, ee = N = Q = null, R = O;
        do {
          var J = R.lane & -536870913, re = J !== R.lane;
          if (re ? (vt & J) === J : (h & J) === J) {
            J !== 0 && J === Dh && (_S = !0), ee !== null && (ee = ee.next = {
              lane: 0,
              tag: R.tag,
              payload: R.payload,
              callback: null,
              next: null
            });
            e: {
              J = t;
              var He = R, Fe = i, en = r;
              switch (He.tag) {
                case fw:
                  if (He = He.payload, typeof He == "function") {
                    tm = !0;
                    var Tt = He.call(
                      en,
                      oe,
                      Fe
                    );
                    if (J.mode & tl) {
                      Ke(!0);
                      try {
                        He.call(en, oe, Fe);
                      } finally {
                        Ke(!1);
                      }
                    }
                    tm = !1, oe = Tt;
                    break e;
                  }
                  oe = He;
                  break e;
                case BS:
                  J.flags = J.flags & -65537 | 128;
                case cw:
                  if (Tt = He.payload, typeof Tt == "function") {
                    if (tm = !0, He = Tt.call(
                      en,
                      oe,
                      Fe
                    ), J.mode & tl) {
                      Ke(!0);
                      try {
                        Tt.call(en, oe, Fe);
                      } finally {
                        Ke(!1);
                      }
                    }
                    tm = !1;
                  } else He = Tt;
                  if (He == null) break e;
                  oe = Ie({}, oe, He);
                  break e;
                case hw:
                  Mc = !0;
              }
            }
            J = R.callback, J !== null && (t.flags |= 64, re && (t.flags |= 8192), re = g.callbacks, re === null ? g.callbacks = [J] : re.push(J));
          } else
            re = {
              lane: J,
              tag: R.tag,
              payload: R.payload,
              callback: R.callback,
              next: null
            }, ee === null ? (N = ee = re, Q = oe) : ee = ee.next = re, x |= J;
          if (R = R.next, R === null) {
            if (R = g.shared.pending, R === null)
              break;
            re = R, R = re.next, re.next = null, g.lastBaseUpdate = re, g.shared.pending = null;
          }
        } while (!0);
        ee === null && (Q = oe), g.baseState = Q, g.firstBaseUpdate = N, g.lastBaseUpdate = ee, O === null && (g.shared.lanes = 0), Uc |= x, t.lanes = x, t.memoizedState = oe;
      }
      qS = null;
    }
    function Dr(t, i) {
      if (typeof t != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + t
        );
      t.call(i);
    }
    function cS(t, i) {
      var r = t.shared.hiddenCallbacks;
      if (r !== null)
        for (t.shared.hiddenCallbacks = null, t = 0; t < r.length; t++)
          Dr(r[t], i);
    }
    function Hi(t, i) {
      var r = t.callbacks;
      if (r !== null)
        for (t.callbacks = null, t = 0; t < r.length; t++)
          Dr(r[t], i);
    }
    function Md(t, i) {
      var r = $s;
      Qe(Iv, r, t), Qe(lm, i, t), $s = r | i.baseLanes;
    }
    function la(t) {
      Qe(Iv, $s, t), Qe(
        lm,
        lm.current,
        t
      );
    }
    function zd(t) {
      $s = Iv.current, fe(lm, t), fe(Iv, t);
    }
    function rt() {
      var t = ae;
      no === null ? no = [t] : no.push(t);
    }
    function be() {
      var t = ae;
      if (no !== null && (nu++, no[nu] !== t)) {
        var i = Te(et);
        if (!pw.has(i) && (pw.add(i), no !== null)) {
          for (var r = "", h = 0; h <= nu; h++) {
            var g = no[h], O = h === nu ? t : g;
            for (g = h + 1 + ". " + g; 30 > g.length; )
              g += " ";
            g += O + `
`, r += g;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            i,
            r
          );
        }
      }
    }
    function gs(t) {
      t == null || zn(t) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        ae,
        typeof t
      );
    }
    function qu() {
      var t = Te(et);
      gw.has(t) || (gw.add(t), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        t
      ));
    }
    function Zt() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function ys(t, i) {
      if (Sy) return !1;
      if (i === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          ae
        ), !1;
      t.length !== i.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        ae,
        "[" + i.join(", ") + "]",
        "[" + t.join(", ") + "]"
      );
      for (var r = 0; r < i.length && r < t.length; r++)
        if (!vl(t[r], i[r])) return !1;
      return !0;
    }
    function _u(t, i, r, h, g, O) {
      zc = O, et = i, no = t !== null ? t._debugHookTypes : null, nu = -1, Sy = t !== null && t.type !== i.type, (Object.prototype.toString.call(r) === "[object AsyncFunction]" || Object.prototype.toString.call(r) === "[object AsyncGeneratorFunction]") && (O = Te(et), HS.has(O) || (HS.add(O), console.error(
        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
        O === null ? "An unknown Component" : "<" + O + ">"
      ))), i.memoizedState = null, i.updateQueue = null, i.lanes = 0, I.H = t !== null && t.memoizedState !== null ? VS : no !== null ? yw : LS, Qh = O = (i.mode & tl) !== on;
      var x = XS(r, h, g);
      if (Qh = !1, om && (x = Li(
        i,
        r,
        h,
        g
      )), O) {
        Ke(!0);
        try {
          x = Li(
            i,
            r,
            h,
            g
          );
        } finally {
          Ke(!1);
        }
      }
      return Ef(t, i), x;
    }
    function Ef(t, i) {
      i._debugHookTypes = no, i.dependencies === null ? tu !== null && (i.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: tu
      }) : i.dependencies._debugThenableState = tu, I.H = nb;
      var r = Pt !== null && Pt.next !== null;
      if (zc = 0, no = ae = Gn = Pt = et = null, nu = -1, t !== null && (t.flags & 65011712) !== (i.flags & 65011712) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), eb = !1, by = 0, tu = null, r)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      t === null || yi || (t = t.dependencies, t !== null && Tf(t) && (yi = !0)), Jv ? (Jv = !1, t = !0) : t = !1, t && (i = Te(i) || "Unknown", mw.has(i) || HS.has(i) || (mw.add(i), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function Li(t, i, r, h) {
      et = t;
      var g = 0;
      do {
        if (om && (tu = null), by = 0, om = !1, g >= Fz)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (g += 1, Sy = !1, Gn = Pt = null, t.updateQueue != null) {
          var O = t.updateQueue;
          O.lastEffect = null, O.events = null, O.stores = null, O.memoCache != null && (O.memoCache.index = 0);
        }
        nu = -1, I.H = Ow, O = XS(i, r, h);
      } while (om);
      return O;
    }
    function zl() {
      var t = I.H, i = t.useState()[0];
      return i = typeof i.then == "function" ? Mr(i) : i, t = t.useState()[0], (Pt !== null ? Pt.memoizedState : null) !== t && (et.flags |= 1024), i;
    }
    function wo() {
      var t = tb !== 0;
      return tb = 0, t;
    }
    function aa(t, i, r) {
      i.updateQueue = t.updateQueue, i.flags = (i.mode & Fo) !== on ? i.flags & -402655237 : i.flags & -2053, t.lanes &= ~r;
    }
    function oa(t) {
      if (eb) {
        for (t = t.memoizedState; t !== null; ) {
          var i = t.queue;
          i !== null && (i.pending = null), t = t.next;
        }
        eb = !1;
      }
      zc = 0, no = Gn = Pt = et = null, nu = -1, ae = null, om = !1, by = tb = 0, tu = null;
    }
    function Tn() {
      var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Gn === null ? et.memoizedState = Gn = t : Gn = Gn.next = t, Gn;
    }
    function Bt() {
      if (Pt === null) {
        var t = et.alternate;
        t = t !== null ? t.memoizedState : null;
      } else t = Pt.next;
      var i = Gn === null ? et.memoizedState : Gn.next;
      if (i !== null)
        Gn = i, Pt = t;
      else {
        if (t === null)
          throw et.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        Pt = t, t = {
          memoizedState: Pt.memoizedState,
          baseState: Pt.baseState,
          baseQueue: Pt.baseQueue,
          queue: Pt.queue,
          next: null
        }, Gn === null ? et.memoizedState = Gn = t : Gn = Gn.next = t;
      }
      return Gn;
    }
    function Cf() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function Mr(t) {
      var i = by;
      return by += 1, tu === null && (tu = Ag()), t = wg(tu, t, i), i = et, (Gn === null ? i.memoizedState : Gn.next) === null && (i = i.alternate, I.H = i !== null && i.memoizedState !== null ? VS : LS), t;
    }
    function hn(t) {
      if (t !== null && typeof t == "object") {
        if (typeof t.then == "function") return Mr(t);
        if (t.$$typeof === Ii) return Wt(t);
      }
      throw Error("An unsupported type was passed to use(): " + String(t));
    }
    function Lt(t) {
      var i = null, r = et.updateQueue;
      if (r !== null && (i = r.memoCache), i == null) {
        var h = et.alternate;
        h !== null && (h = h.updateQueue, h !== null && (h = h.memoCache, h != null && (i = {
          data: h.data.map(function(g) {
            return g.slice();
          }),
          index: 0
        })));
      }
      if (i == null && (i = { data: [], index: 0 }), r === null && (r = Cf(), et.updateQueue = r), r.memoCache = i, r = i.data[i.index], r === void 0 || Sy)
        for (r = i.data[i.index] = Array(t), h = 0; h < t; h++)
          r[h] = Mv;
      else
        r.length !== t && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          r.length,
          t
        );
      return i.index++, r;
    }
    function ut(t, i) {
      return typeof i == "function" ? i(t) : i;
    }
    function Eo(t, i, r) {
      var h = Tn();
      if (r !== void 0) {
        var g = r(i);
        if (Qh) {
          Ke(!0);
          try {
            r(i);
          } finally {
            Ke(!1);
          }
        }
      } else g = i;
      return h.memoizedState = h.baseState = g, t = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: g
      }, h.queue = t, t = t.dispatch = qf.bind(
        null,
        et,
        t
      ), [h.memoizedState, t];
    }
    function wi(t) {
      var i = Bt();
      return Rf(i, Pt, t);
    }
    function Rf(t, i, r) {
      var h = t.queue;
      if (h === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      h.lastRenderedReducer = r;
      var g = t.baseQueue, O = h.pending;
      if (O !== null) {
        if (g !== null) {
          var x = g.next;
          g.next = O.next, O.next = x;
        }
        i.baseQueue !== g && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), i.baseQueue = g = O, h.pending = null;
      }
      if (O = t.baseState, g === null) t.memoizedState = O;
      else {
        i = g.next;
        var R = x = null, Q = null, N = i, ee = !1;
        do {
          var oe = N.lane & -536870913;
          if (oe !== N.lane ? (vt & oe) === oe : (zc & oe) === oe) {
            var J = N.revertLane;
            if (J === 0)
              Q !== null && (Q = Q.next = {
                lane: 0,
                revertLane: 0,
                action: N.action,
                hasEagerState: N.hasEagerState,
                eagerState: N.eagerState,
                next: null
              }), oe === Dh && (ee = !0);
            else if ((zc & J) === J) {
              N = N.next, J === Dh && (ee = !0);
              continue;
            } else
              oe = {
                lane: 0,
                revertLane: N.revertLane,
                action: N.action,
                hasEagerState: N.hasEagerState,
                eagerState: N.eagerState,
                next: null
              }, Q === null ? (R = Q = oe, x = O) : Q = Q.next = oe, et.lanes |= J, Uc |= J;
            oe = N.action, Qh && r(O, oe), O = N.hasEagerState ? N.eagerState : r(O, oe);
          } else
            J = {
              lane: oe,
              revertLane: N.revertLane,
              action: N.action,
              hasEagerState: N.hasEagerState,
              eagerState: N.eagerState,
              next: null
            }, Q === null ? (R = Q = J, x = O) : Q = Q.next = J, et.lanes |= oe, Uc |= oe;
          N = N.next;
        } while (N !== null && N !== i);
        if (Q === null ? x = O : Q.next = R, !vl(O, t.memoizedState) && (yi = !0, ee && (r = im, r !== null)))
          throw r;
        t.memoizedState = O, t.baseState = x, t.baseQueue = Q, h.lastRenderedState = O;
      }
      return g === null && (h.lanes = 0), [t.memoizedState, h.dispatch];
    }
    function sa(t) {
      var i = Bt(), r = i.queue;
      if (r === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      r.lastRenderedReducer = t;
      var h = r.dispatch, g = r.pending, O = i.memoizedState;
      if (g !== null) {
        r.pending = null;
        var x = g = g.next;
        do
          O = t(O, x.action), x = x.next;
        while (x !== g);
        vl(O, i.memoizedState) || (yi = !0), i.memoizedState = O, i.baseQueue === null && (i.baseState = O), r.lastRenderedState = O;
      }
      return [O, h];
    }
    function Qd(t, i, r) {
      var h = et, g = Tn();
      if (Rt) {
        if (r === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var O = r();
        am || O === r() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), am = !0);
      } else {
        if (O = i(), am || (r = i(), vl(O, r) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), am = !0)), It === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        (vt & 124) !== 0 || Hu(h, i, O);
      }
      return g.memoizedState = O, r = { value: O, getSnapshot: i }, g.queue = r, zf(
        Eg.bind(null, h, r, t),
        [t]
      ), h.flags |= 2048, qa(
        to | oi,
        Gu(),
        Lu.bind(
          null,
          h,
          r,
          O,
          i
        ),
        null
      ), O;
    }
    function kf(t, i, r) {
      var h = et, g = Bt(), O = Rt;
      if (O) {
        if (r === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        r = r();
      } else if (r = i(), !am) {
        var x = i();
        vl(r, x) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), am = !0);
      }
      (x = !vl(
        (Pt || g).memoizedState,
        r
      )) && (g.memoizedState = r, yi = !0), g = g.queue;
      var R = Eg.bind(null, h, g, t);
      if (Vi(2048, oi, R, [t]), g.getSnapshot !== i || x || Gn !== null && Gn.memoizedState.tag & to) {
        if (h.flags |= 2048, qa(
          to | oi,
          Gu(),
          Lu.bind(
            null,
            h,
            g,
            r,
            i
          ),
          null
        ), It === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        O || (zc & 124) !== 0 || Hu(h, i, r);
      }
      return r;
    }
    function Hu(t, i, r) {
      t.flags |= 16384, t = { getSnapshot: i, value: r }, i = et.updateQueue, i === null ? (i = Cf(), et.updateQueue = i, i.stores = [t]) : (r = i.stores, r === null ? i.stores = [t] : r.push(t));
    }
    function Lu(t, i, r, h) {
      i.value = r, i.getSnapshot = h, Vu(i) && Nd(t);
    }
    function Eg(t, i, r) {
      return r(function() {
        Vu(i) && Nd(t);
      });
    }
    function Vu(t) {
      var i = t.getSnapshot;
      t = t.value;
      try {
        var r = i();
        return !vl(t, r);
      } catch {
        return !0;
      }
    }
    function Nd(t) {
      var i = qi(t, 2);
      i !== null && mt(i, t, 2);
    }
    function Co(t) {
      var i = Tn();
      if (typeof t == "function") {
        var r = t;
        if (t = r(), Qh) {
          Ke(!0);
          try {
            r();
          } finally {
            Ke(!1);
          }
        }
      }
      return i.memoizedState = i.baseState = t, i.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ut,
        lastRenderedState: t
      }, i;
    }
    function ra(t) {
      t = Co(t);
      var i = t.queue, r = Fu.bind(null, et, i);
      return i.dispatch = r, [t.memoizedState, r];
    }
    function Ua(t) {
      var i = Tn();
      i.memoizedState = i.baseState = t;
      var r = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = r, i = Vd.bind(
        null,
        et,
        !0,
        r
      ), r.dispatch = i, [t, i];
    }
    function Ba(t, i) {
      var r = Bt();
      return Ud(r, Pt, t, i);
    }
    function Ud(t, i, r, h) {
      return t.baseState = r, Rf(
        t,
        Pt,
        typeof h == "function" ? h : ut
      );
    }
    function Bd(t, i) {
      var r = Bt();
      return Pt !== null ? Ud(r, Pt, t, i) : (r.baseState = t, [t, r.queue.dispatch]);
    }
    function Df(t, i, r, h, g) {
      if (Mo(t))
        throw Error("Cannot update form state while rendering.");
      if (t = i.action, t !== null) {
        var O = {
          payload: g,
          action: t,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(x) {
            O.listeners.push(x);
          }
        };
        I.T !== null ? r(!0) : O.isTransition = !1, h(O), r = i.pending, r === null ? (O.next = i.pending = O, Mf(i, O)) : (O.next = r.next, i.pending = r.next = O);
      }
    }
    function Mf(t, i) {
      var r = i.action, h = i.payload, g = t.state;
      if (i.isTransition) {
        var O = I.T, x = {};
        I.T = x, I.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var R = r(g, h), Q = I.S;
          Q !== null && Q(x, R), Os(t, i, R);
        } catch (N) {
          Xu(t, i, N);
        } finally {
          I.T = O, O === null && x._updatedFibers && (t = x._updatedFibers.size, x._updatedFibers.clear(), 10 < t && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          x = r(g, h), Os(t, i, x);
        } catch (N) {
          Xu(t, i, N);
        }
    }
    function Os(t, i, r) {
      r !== null && typeof r == "object" && typeof r.then == "function" ? (r.then(
        function(h) {
          ei(t, i, h);
        },
        function(h) {
          return Xu(t, i, h);
        }
      ), i.isTransition || console.error(
        "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
      )) : ei(t, i, r);
    }
    function ei(t, i, r) {
      i.status = "fulfilled", i.value = r, Cg(i), t.state = r, i = t.pending, i !== null && (r = i.next, r === i ? t.pending = null : (r = r.next, i.next = r, Mf(t, r)));
    }
    function Xu(t, i, r) {
      var h = t.pending;
      if (t.pending = null, h !== null) {
        h = h.next;
        do
          i.status = "rejected", i.reason = r, Cg(i), i = i.next;
        while (i !== h);
      }
      t.action = null;
    }
    function Cg(t) {
      t = t.listeners;
      for (var i = 0; i < t.length; i++) (0, t[i])();
    }
    function JO(t, i) {
      return i;
    }
    function ju(t, i) {
      if (Rt) {
        var r = It.formState;
        if (r !== null) {
          e: {
            var h = et;
            if (Rt) {
              if (En) {
                t: {
                  for (var g = En, O = js; g.nodeType !== 8; ) {
                    if (!O) {
                      g = null;
                      break t;
                    }
                    if (g = Ki(
                      g.nextSibling
                    ), g === null) {
                      g = null;
                      break t;
                    }
                  }
                  O = g.data, g = O === pT || O === gE ? g : null;
                }
                if (g) {
                  En = Ki(
                    g.nextSibling
                  ), h = g.data === pT;
                  break e;
                }
              }
              cs(h);
            }
            h = !1;
          }
          h && (i = r[0]);
        }
      }
      return r = Tn(), r.memoizedState = r.baseState = i, h = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: JO,
        lastRenderedState: i
      }, r.queue = h, r = Fu.bind(
        null,
        et,
        h
      ), h.dispatch = r, h = Co(!1), O = Vd.bind(
        null,
        et,
        !1,
        h.queue
      ), h = Tn(), g = {
        state: i,
        dispatch: null,
        action: t,
        pending: null
      }, h.queue = g, r = Df.bind(
        null,
        et,
        g,
        O,
        r
      ), g.dispatch = r, h.memoizedState = t, [i, r, !1];
    }
    function qd(t) {
      var i = Bt();
      return xn(i, Pt, t);
    }
    function xn(t, i, r) {
      if (i = Rf(
        t,
        i,
        JO
      )[0], t = wi(ut)[0], typeof i == "object" && i !== null && typeof i.then == "function")
        try {
          var h = Mr(i);
        } catch (x) {
          throw x === Oy ? Kv : x;
        }
      else h = i;
      i = Bt();
      var g = i.queue, O = g.dispatch;
      return r !== i.memoizedState && (et.flags |= 2048, qa(
        to | oi,
        Gu(),
        Rg.bind(null, g, r),
        null
      )), [h, O, t];
    }
    function Rg(t, i) {
      t.action = i;
    }
    function vs(t) {
      var i = Bt(), r = Pt;
      if (r !== null)
        return xn(i, r, t);
      Bt(), i = i.memoizedState, r = Bt();
      var h = r.queue.dispatch;
      return r.memoizedState = t, [i, h, !1];
    }
    function qa(t, i, r, h) {
      return t = {
        tag: t,
        create: r,
        deps: h,
        inst: i,
        next: null
      }, i = et.updateQueue, i === null && (i = Cf(), et.updateQueue = i), r = i.lastEffect, r === null ? i.lastEffect = t.next = t : (h = r.next, r.next = t, t.next = h, i.lastEffect = t), t;
    }
    function Gu() {
      return { destroy: void 0, resource: void 0 };
    }
    function bs(t) {
      var i = Tn();
      return t = { current: t }, i.memoizedState = t;
    }
    function Ql(t, i, r, h) {
      var g = Tn();
      h = h === void 0 ? null : h, et.flags |= t, g.memoizedState = qa(
        to | i,
        Gu(),
        r,
        h
      );
    }
    function Vi(t, i, r, h) {
      var g = Bt();
      h = h === void 0 ? null : h;
      var O = g.memoizedState.inst;
      Pt !== null && h !== null && ys(h, Pt.memoizedState.deps) ? g.memoizedState = qa(i, O, r, h) : (et.flags |= t, g.memoizedState = qa(
        to | i,
        O,
        r,
        h
      ));
    }
    function zf(t, i) {
      (et.mode & Fo) !== on && (et.mode & ew) === on ? Ql(276826112, oi, t, i) : Ql(8390656, oi, t, i);
    }
    function kg(t, i) {
      var r = 4194308;
      return (et.mode & Fo) !== on && (r |= 134217728), Ql(r, ki, t, i);
    }
    function Dg(t, i) {
      if (typeof i == "function") {
        t = t();
        var r = i(t);
        return function() {
          typeof r == "function" ? r() : i(null);
        };
      }
      if (i != null)
        return i.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(i).join(", ") + "}"
        ), t = t(), i.current = t, function() {
          i.current = null;
        };
    }
    function Ro(t, i, r) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), r = r != null ? r.concat([t]) : null;
      var h = 4194308;
      (et.mode & Fo) !== on && (h |= 134217728), Ql(
        h,
        ki,
        Dg.bind(null, i, t),
        r
      );
    }
    function Yu(t, i, r) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), r = r != null ? r.concat([t]) : null, Vi(
        4,
        ki,
        Dg.bind(null, i, t),
        r
      );
    }
    function $u(t, i) {
      return Tn().memoizedState = [
        t,
        i === void 0 ? null : i
      ], t;
    }
    function Qf(t, i) {
      var r = Bt();
      i = i === void 0 ? null : i;
      var h = r.memoizedState;
      return i !== null && ys(i, h[1]) ? h[0] : (r.memoizedState = [t, i], t);
    }
    function zr(t, i) {
      var r = Tn();
      i = i === void 0 ? null : i;
      var h = t();
      if (Qh) {
        Ke(!0);
        try {
          t();
        } finally {
          Ke(!1);
        }
      }
      return r.memoizedState = [h, i], h;
    }
    function Nf(t, i) {
      var r = Bt();
      i = i === void 0 ? null : i;
      var h = r.memoizedState;
      if (i !== null && ys(i, h[1]))
        return h[0];
      if (h = t(), Qh) {
        Ke(!0);
        try {
          t();
        } finally {
          Ke(!1);
        }
      }
      return r.memoizedState = [h, i], h;
    }
    function Zu(t, i) {
      var r = Tn();
      return Pu(r, t, i);
    }
    function _d(t, i) {
      var r = Bt();
      return zg(
        r,
        Pt.memoizedState,
        t,
        i
      );
    }
    function Mg(t, i) {
      var r = Bt();
      return Pt === null ? Pu(r, t, i) : zg(
        r,
        Pt.memoizedState,
        t,
        i
      );
    }
    function Pu(t, i, r) {
      return r === void 0 || (zc & 1073741824) !== 0 ? t.memoizedState = i : (t.memoizedState = r, t = u0(), et.lanes |= t, Uc |= t, r);
    }
    function zg(t, i, r, h) {
      return vl(r, i) ? r : lm.current !== null ? (t = Pu(t, r, h), vl(t, i) || (yi = !0), t) : (zc & 42) === 0 ? (yi = !0, t.memoizedState = r) : (t = u0(), et.lanes |= t, Uc |= t, i);
    }
    function Wu(t, i, r, h, g) {
      var O = Mt.p;
      Mt.p = O !== 0 && O < Ga ? O : Ga;
      var x = I.T, R = {};
      I.T = R, Vd(t, !1, i, r), R._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var Q = g(), N = I.S;
        if (N !== null && N(R, Q), Q !== null && typeof Q == "object" && typeof Q.then == "function") {
          var ee = uS(
            Q,
            h
          );
          Ku(
            t,
            i,
            ee,
            dl(t)
          );
        } else
          Ku(
            t,
            i,
            h,
            dl(t)
          );
      } catch (oe) {
        Ku(
          t,
          i,
          { then: function() {
          }, status: "rejected", reason: oe },
          dl(t)
        );
      } finally {
        Mt.p = O, I.T = x, x === null && R._updatedFibers && (t = R._updatedFibers.size, R._updatedFibers.clear(), 10 < t && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function Hd(t, i, r, h) {
      if (t.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var g = Qg(t).queue;
      Wu(
        t,
        g,
        i,
        Gh,
        r === null ? A : function() {
          return ko(t), r(h);
        }
      );
    }
    function Qg(t) {
      var i = t.memoizedState;
      if (i !== null) return i;
      i = {
        memoizedState: Gh,
        baseState: Gh,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ut,
          lastRenderedState: Gh
        },
        next: null
      };
      var r = {};
      return i.next = {
        memoizedState: r,
        baseState: r,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ut,
          lastRenderedState: r
        },
        next: null
      }, t.memoizedState = i, t = t.alternate, t !== null && (t.memoizedState = i), i;
    }
    function ko(t) {
      I.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var i = Qg(t).next.queue;
      Ku(
        t,
        i,
        {},
        dl(t)
      );
    }
    function Uf() {
      var t = Co(!1);
      return t = Wu.bind(
        null,
        et,
        t.queue,
        !0,
        !1
      ), Tn().memoizedState = t, [!1, t];
    }
    function Ld() {
      var t = wi(ut)[0], i = Bt().memoizedState;
      return [
        typeof t == "boolean" ? t : Mr(t),
        i
      ];
    }
    function Do() {
      var t = sa(ut)[0], i = Bt().memoizedState;
      return [
        typeof t == "boolean" ? t : Mr(t),
        i
      ];
    }
    function Xi() {
      return Wt(_y);
    }
    function Qr() {
      var t = Tn(), i = It.identifierPrefix;
      if (Rt) {
        var r = Ir, h = Jr;
        r = (h & ~(1 << 32 - Vn(h) - 1)).toString(32) + r, i = "" + i + "R" + r, r = tb++, 0 < r && (i += "H" + r.toString(32)), i += "";
      } else
        r = Wz++, i = "" + i + "r" + r.toString(32) + "";
      return t.memoizedState = i;
    }
    function Bf() {
      return Tn().memoizedState = Ng.bind(
        null,
        et
      );
    }
    function Ng(t, i) {
      for (var r = t.return; r !== null; ) {
        switch (r.tag) {
          case 24:
          case 3:
            var h = dl(r);
            t = na(h);
            var g = ia(r, t, h);
            g !== null && (mt(g, r, h), kr(g, r, h)), r = bg(), i != null && g !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), t.payload = { cache: r };
            return;
        }
        r = r.return;
      }
    }
    function qf(t, i, r) {
      var h = arguments;
      typeof h[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), h = dl(t);
      var g = {
        lane: h,
        revertLane: 0,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      Mo(t) ? _f(i, g) : (g = fg(t, i, g, h), g !== null && (mt(g, t, h), Ug(g, i, h))), Da(t, h);
    }
    function Fu(t, i, r) {
      var h = arguments;
      typeof h[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), h = dl(t), Ku(t, i, r, h), Da(t, h);
    }
    function Ku(t, i, r, h) {
      var g = {
        lane: h,
        revertLane: 0,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Mo(t)) _f(i, g);
      else {
        var O = t.alternate;
        if (t.lanes === 0 && (O === null || O.lanes === 0) && (O = i.lastRenderedReducer, O !== null)) {
          var x = I.H;
          I.H = Jo;
          try {
            var R = i.lastRenderedState, Q = O(R, r);
            if (g.hasEagerState = !0, g.eagerState = Q, vl(Q, R))
              return vd(t, i, g, 0), It === null && Od(), !1;
          } catch {
          } finally {
            I.H = x;
          }
        }
        if (r = fg(t, i, g, h), r !== null)
          return mt(r, t, h), Ug(r, i, h), !0;
      }
      return !1;
    }
    function Vd(t, i, r, h) {
      if (I.T === null && Dh === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), h = {
        lane: 2,
        revertLane: hp(),
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Mo(t)) {
        if (i)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        i = fg(
          t,
          r,
          h,
          2
        ), i !== null && mt(i, t, 2);
      Da(t, 2);
    }
    function Mo(t) {
      var i = t.alternate;
      return t === et || i !== null && i === et;
    }
    function _f(t, i) {
      om = eb = !0;
      var r = t.pending;
      r === null ? i.next = i : (i.next = r.next, r.next = i), t.pending = i;
    }
    function Ug(t, i, r) {
      if ((r & 4194048) !== 0) {
        var h = i.lanes;
        h &= t.pendingLanes, r |= h, i.lanes = r, ci(t, r);
      }
    }
    function kn(t) {
      var i = dt;
      return t != null && (dt = i === null ? t : i.concat(t)), i;
    }
    function Ju(t, i, r) {
      for (var h = Object.keys(t.props), g = 0; g < h.length; g++) {
        var O = h[g];
        if (O !== "children" && O !== "key") {
          i === null && (i = Sf(t, r.mode, 0), i._debugInfo = dt, i.return = r), Ge(
            i,
            function(x) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                x
              );
            },
            O
          );
          break;
        }
      }
    }
    function ua(t) {
      var i = Ty;
      return Ty += 1, sm === null && (sm = Ag()), wg(sm, t, i);
    }
    function nt(t, i) {
      i = i.props.ref, t.ref = i !== void 0 ? i : null;
    }
    function Dt(t, i) {
      throw i.$$typeof === yS ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (t = Object.prototype.toString.call(i), Error(
        "Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function rn(t, i) {
      var r = Te(t) || "Component";
      Qw[r] || (Qw[r] = !0, i = i.displayName || i.name || "Component", t.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        i,
        i,
        i
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        i,
        i,
        r,
        i,
        r
      ));
    }
    function Nr(t, i) {
      var r = Te(t) || "Component";
      Nw[r] || (Nw[r] = !0, i = String(i), t.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        i
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        r,
        i,
        r
      ));
    }
    function Ur(t) {
      function i(_, H) {
        if (t) {
          var X = _.deletions;
          X === null ? (_.deletions = [H], _.flags |= 16) : X.push(H);
        }
      }
      function r(_, H) {
        if (!t) return null;
        for (; H !== null; )
          i(_, H), H = H.sibling;
        return null;
      }
      function h(_) {
        for (var H = /* @__PURE__ */ new Map(); _ !== null; )
          _.key !== null ? H.set(_.key, _) : H.set(_.index, _), _ = _.sibling;
        return H;
      }
      function g(_, H) {
        return _ = Na(_, H), _.index = 0, _.sibling = null, _;
      }
      function O(_, H, X) {
        return _.index = X, t ? (X = _.alternate, X !== null ? (X = X.index, X < H ? (_.flags |= 67108866, H) : X) : (_.flags |= 67108866, H)) : (_.flags |= 1048576, H);
      }
      function x(_) {
        return t && _.alternate === null && (_.flags |= 67108866), _;
      }
      function R(_, H, X, ue) {
        return H === null || H.tag !== 6 ? (H = pg(
          X,
          _.mode,
          ue
        ), H.return = _, H._debugOwner = _, H._debugTask = _._debugTask, H._debugInfo = dt, H) : (H = g(H, X), H.return = _, H._debugInfo = dt, H);
      }
      function Q(_, H, X, ue) {
        var Ce = X.type;
        return Ce === Bs ? (H = ee(
          _,
          H,
          X.props.children,
          ue,
          X.key
        ), Ju(X, H, _), H) : H !== null && (H.elementType === Ce || WO(H, X) || typeof Ce == "object" && Ce !== null && Ce.$$typeof === yl && Qc(Ce) === H.type) ? (H = g(H, X.props), nt(H, X), H.return = _, H._debugOwner = X._owner, H._debugInfo = dt, H) : (H = Sf(X, _.mode, ue), nt(H, X), H.return = _, H._debugInfo = dt, H);
      }
      function N(_, H, X, ue) {
        return H === null || H.tag !== 4 || H.stateNode.containerInfo !== X.containerInfo || H.stateNode.implementation !== X.implementation ? (H = mg(X, _.mode, ue), H.return = _, H._debugInfo = dt, H) : (H = g(H, X.children || []), H.return = _, H._debugInfo = dt, H);
      }
      function ee(_, H, X, ue, Ce) {
        return H === null || H.tag !== 7 ? (H = Dl(
          X,
          _.mode,
          ue,
          Ce
        ), H.return = _, H._debugOwner = _, H._debugTask = _._debugTask, H._debugInfo = dt, H) : (H = g(H, X), H.return = _, H._debugInfo = dt, H);
      }
      function oe(_, H, X) {
        if (typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint")
          return H = pg(
            "" + H,
            _.mode,
            X
          ), H.return = _, H._debugOwner = _, H._debugTask = _._debugTask, H._debugInfo = dt, H;
        if (typeof H == "object" && H !== null) {
          switch (H.$$typeof) {
            case jo:
              return X = Sf(
                H,
                _.mode,
                X
              ), nt(X, H), X.return = _, _ = kn(H._debugInfo), X._debugInfo = dt, dt = _, X;
            case at:
              return H = mg(
                H,
                _.mode,
                X
              ), H.return = _, H._debugInfo = dt, H;
            case yl:
              var ue = kn(H._debugInfo);
              return H = Qc(H), _ = oe(_, H, X), dt = ue, _;
          }
          if (zn(H) || Oe(H))
            return X = Dl(
              H,
              _.mode,
              X,
              null
            ), X.return = _, X._debugOwner = _, X._debugTask = _._debugTask, _ = kn(H._debugInfo), X._debugInfo = dt, dt = _, X;
          if (typeof H.then == "function")
            return ue = kn(H._debugInfo), _ = oe(
              _,
              ua(H),
              X
            ), dt = ue, _;
          if (H.$$typeof === Ii)
            return oe(
              _,
              xf(_, H),
              X
            );
          Dt(_, H);
        }
        return typeof H == "function" && rn(_, H), typeof H == "symbol" && Nr(_, H), null;
      }
      function J(_, H, X, ue) {
        var Ce = H !== null ? H.key : null;
        if (typeof X == "string" && X !== "" || typeof X == "number" || typeof X == "bigint")
          return Ce !== null ? null : R(_, H, "" + X, ue);
        if (typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case jo:
              return X.key === Ce ? (Ce = kn(X._debugInfo), _ = Q(
                _,
                H,
                X,
                ue
              ), dt = Ce, _) : null;
            case at:
              return X.key === Ce ? N(_, H, X, ue) : null;
            case yl:
              return Ce = kn(X._debugInfo), X = Qc(X), _ = J(
                _,
                H,
                X,
                ue
              ), dt = Ce, _;
          }
          if (zn(X) || Oe(X))
            return Ce !== null ? null : (Ce = kn(X._debugInfo), _ = ee(
              _,
              H,
              X,
              ue,
              null
            ), dt = Ce, _);
          if (typeof X.then == "function")
            return Ce = kn(X._debugInfo), _ = J(
              _,
              H,
              ua(X),
              ue
            ), dt = Ce, _;
          if (X.$$typeof === Ii)
            return J(
              _,
              H,
              xf(_, X),
              ue
            );
          Dt(_, X);
        }
        return typeof X == "function" && rn(_, X), typeof X == "symbol" && Nr(_, X), null;
      }
      function re(_, H, X, ue, Ce) {
        if (typeof ue == "string" && ue !== "" || typeof ue == "number" || typeof ue == "bigint")
          return _ = _.get(X) || null, R(H, _, "" + ue, Ce);
        if (typeof ue == "object" && ue !== null) {
          switch (ue.$$typeof) {
            case jo:
              return X = _.get(
                ue.key === null ? X : ue.key
              ) || null, _ = kn(ue._debugInfo), H = Q(
                H,
                X,
                ue,
                Ce
              ), dt = _, H;
            case at:
              return _ = _.get(
                ue.key === null ? X : ue.key
              ) || null, N(H, _, ue, Ce);
            case yl:
              var ot = kn(ue._debugInfo);
              return ue = Qc(ue), H = re(
                _,
                H,
                X,
                ue,
                Ce
              ), dt = ot, H;
          }
          if (zn(ue) || Oe(ue))
            return X = _.get(X) || null, _ = kn(ue._debugInfo), H = ee(
              H,
              X,
              ue,
              Ce,
              null
            ), dt = _, H;
          if (typeof ue.then == "function")
            return ot = kn(ue._debugInfo), H = re(
              _,
              H,
              X,
              ua(ue),
              Ce
            ), dt = ot, H;
          if (ue.$$typeof === Ii)
            return re(
              _,
              H,
              X,
              xf(H, ue),
              Ce
            );
          Dt(H, ue);
        }
        return typeof ue == "function" && rn(H, ue), typeof ue == "symbol" && Nr(H, ue), null;
      }
      function He(_, H, X, ue) {
        if (typeof X != "object" || X === null) return ue;
        switch (X.$$typeof) {
          case jo:
          case at:
            y(_, H, X);
            var Ce = X.key;
            if (typeof Ce != "string") break;
            if (ue === null) {
              ue = /* @__PURE__ */ new Set(), ue.add(Ce);
              break;
            }
            if (!ue.has(Ce)) {
              ue.add(Ce);
              break;
            }
            Ge(H, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
                Ce
              );
            });
            break;
          case yl:
            X = Qc(X), He(_, H, X, ue);
        }
        return ue;
      }
      function Fe(_, H, X, ue) {
        for (var Ce = null, ot = null, Le = null, st = H, ft = H = 0, sn = null; st !== null && ft < X.length; ft++) {
          st.index > ft ? (sn = st, st = null) : sn = st.sibling;
          var Nn = J(
            _,
            st,
            X[ft],
            ue
          );
          if (Nn === null) {
            st === null && (st = sn);
            break;
          }
          Ce = He(
            _,
            Nn,
            X[ft],
            Ce
          ), t && st && Nn.alternate === null && i(_, st), H = O(Nn, H, ft), Le === null ? ot = Nn : Le.sibling = Nn, Le = Nn, st = sn;
        }
        if (ft === X.length)
          return r(_, st), Rt && Ar(_, ft), ot;
        if (st === null) {
          for (; ft < X.length; ft++)
            st = oe(_, X[ft], ue), st !== null && (Ce = He(
              _,
              st,
              X[ft],
              Ce
            ), H = O(
              st,
              H,
              ft
            ), Le === null ? ot = st : Le.sibling = st, Le = st);
          return Rt && Ar(_, ft), ot;
        }
        for (st = h(st); ft < X.length; ft++)
          sn = re(
            st,
            _,
            ft,
            X[ft],
            ue
          ), sn !== null && (Ce = He(
            _,
            sn,
            X[ft],
            Ce
          ), t && sn.alternate !== null && st.delete(
            sn.key === null ? ft : sn.key
          ), H = O(
            sn,
            H,
            ft
          ), Le === null ? ot = sn : Le.sibling = sn, Le = sn);
        return t && st.forEach(function(ru) {
          return i(_, ru);
        }), Rt && Ar(_, ft), ot;
      }
      function en(_, H, X, ue) {
        if (X == null)
          throw Error("An iterable object provided no iterator.");
        for (var Ce = null, ot = null, Le = H, st = H = 0, ft = null, sn = null, Nn = X.next(); Le !== null && !Nn.done; st++, Nn = X.next()) {
          Le.index > st ? (ft = Le, Le = null) : ft = Le.sibling;
          var ru = J(_, Le, Nn.value, ue);
          if (ru === null) {
            Le === null && (Le = ft);
            break;
          }
          sn = He(
            _,
            ru,
            Nn.value,
            sn
          ), t && Le && ru.alternate === null && i(_, Le), H = O(ru, H, st), ot === null ? Ce = ru : ot.sibling = ru, ot = ru, Le = ft;
        }
        if (Nn.done)
          return r(_, Le), Rt && Ar(_, st), Ce;
        if (Le === null) {
          for (; !Nn.done; st++, Nn = X.next())
            Le = oe(_, Nn.value, ue), Le !== null && (sn = He(
              _,
              Le,
              Nn.value,
              sn
            ), H = O(
              Le,
              H,
              st
            ), ot === null ? Ce = Le : ot.sibling = Le, ot = Le);
          return Rt && Ar(_, st), Ce;
        }
        for (Le = h(Le); !Nn.done; st++, Nn = X.next())
          ft = re(
            Le,
            _,
            st,
            Nn.value,
            ue
          ), ft !== null && (sn = He(
            _,
            ft,
            Nn.value,
            sn
          ), t && ft.alternate !== null && Le.delete(
            ft.key === null ? st : ft.key
          ), H = O(
            ft,
            H,
            st
          ), ot === null ? Ce = ft : ot.sibling = ft, ot = ft);
        return t && Le.forEach(function(T3) {
          return i(_, T3);
        }), Rt && Ar(_, st), Ce;
      }
      function Tt(_, H, X, ue) {
        if (typeof X == "object" && X !== null && X.type === Bs && X.key === null && (Ju(X, null, _), X = X.props.children), typeof X == "object" && X !== null) {
          switch (X.$$typeof) {
            case jo:
              var Ce = kn(X._debugInfo);
              e: {
                for (var ot = X.key; H !== null; ) {
                  if (H.key === ot) {
                    if (ot = X.type, ot === Bs) {
                      if (H.tag === 7) {
                        r(
                          _,
                          H.sibling
                        ), ue = g(
                          H,
                          X.props.children
                        ), ue.return = _, ue._debugOwner = X._owner, ue._debugInfo = dt, Ju(X, ue, _), _ = ue;
                        break e;
                      }
                    } else if (H.elementType === ot || WO(
                      H,
                      X
                    ) || typeof ot == "object" && ot !== null && ot.$$typeof === yl && Qc(ot) === H.type) {
                      r(
                        _,
                        H.sibling
                      ), ue = g(H, X.props), nt(ue, X), ue.return = _, ue._debugOwner = X._owner, ue._debugInfo = dt, _ = ue;
                      break e;
                    }
                    r(_, H);
                    break;
                  } else i(_, H);
                  H = H.sibling;
                }
                X.type === Bs ? (ue = Dl(
                  X.props.children,
                  _.mode,
                  ue,
                  X.key
                ), ue.return = _, ue._debugOwner = _, ue._debugTask = _._debugTask, ue._debugInfo = dt, Ju(X, ue, _), _ = ue) : (ue = Sf(
                  X,
                  _.mode,
                  ue
                ), nt(ue, X), ue.return = _, ue._debugInfo = dt, _ = ue);
              }
              return _ = x(_), dt = Ce, _;
            case at:
              e: {
                for (Ce = X, X = Ce.key; H !== null; ) {
                  if (H.key === X)
                    if (H.tag === 4 && H.stateNode.containerInfo === Ce.containerInfo && H.stateNode.implementation === Ce.implementation) {
                      r(
                        _,
                        H.sibling
                      ), ue = g(
                        H,
                        Ce.children || []
                      ), ue.return = _, _ = ue;
                      break e;
                    } else {
                      r(_, H);
                      break;
                    }
                  else i(_, H);
                  H = H.sibling;
                }
                ue = mg(
                  Ce,
                  _.mode,
                  ue
                ), ue.return = _, _ = ue;
              }
              return x(_);
            case yl:
              return Ce = kn(X._debugInfo), X = Qc(X), _ = Tt(
                _,
                H,
                X,
                ue
              ), dt = Ce, _;
          }
          if (zn(X))
            return Ce = kn(X._debugInfo), _ = Fe(
              _,
              H,
              X,
              ue
            ), dt = Ce, _;
          if (Oe(X)) {
            if (Ce = kn(X._debugInfo), ot = Oe(X), typeof ot != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var Le = ot.call(X);
            return Le === X ? (_.tag !== 0 || Object.prototype.toString.call(_.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(Le) !== "[object Generator]") && (Mw || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), Mw = !0) : X.entries !== ot || GS || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), GS = !0), _ = en(
              _,
              H,
              Le,
              ue
            ), dt = Ce, _;
          }
          if (typeof X.then == "function")
            return Ce = kn(X._debugInfo), _ = Tt(
              _,
              H,
              ua(X),
              ue
            ), dt = Ce, _;
          if (X.$$typeof === Ii)
            return Tt(
              _,
              H,
              xf(_, X),
              ue
            );
          Dt(_, X);
        }
        return typeof X == "string" && X !== "" || typeof X == "number" || typeof X == "bigint" ? (Ce = "" + X, H !== null && H.tag === 6 ? (r(
          _,
          H.sibling
        ), ue = g(H, Ce), ue.return = _, _ = ue) : (r(_, H), ue = pg(
          Ce,
          _.mode,
          ue
        ), ue.return = _, ue._debugOwner = _, ue._debugTask = _._debugTask, ue._debugInfo = dt, _ = ue), x(_)) : (typeof X == "function" && rn(_, X), typeof X == "symbol" && Nr(_, X), r(_, H));
      }
      return function(_, H, X, ue) {
        var Ce = dt;
        dt = null;
        try {
          Ty = 0;
          var ot = Tt(
            _,
            H,
            X,
            ue
          );
          return sm = null, ot;
        } catch (sn) {
          if (sn === Oy || sn === Kv) throw sn;
          var Le = E(29, sn, null, _.mode);
          Le.lanes = ue, Le.return = _;
          var st = Le._debugInfo = dt;
          if (Le._debugOwner = _._debugOwner, Le._debugTask = _._debugTask, st != null) {
            for (var ft = st.length - 1; 0 <= ft; ft--)
              if (typeof st[ft].stack == "string") {
                Le._debugOwner = st[ft], Le._debugTask = st[ft].debugTask;
                break;
              }
          }
          return Le;
        } finally {
          dt = Ce;
        }
      };
    }
    function ji(t) {
      var i = t.alternate;
      Qe(
        si,
        si.current & um,
        t
      ), Qe(io, t, t), Ys === null && (i === null || lm.current !== null || i.memoizedState !== null) && (Ys = t);
    }
    function Hf(t) {
      if (t.tag === 22) {
        if (Qe(si, si.current, t), Qe(io, t, t), Ys === null) {
          var i = t.alternate;
          i !== null && i.memoizedState !== null && (Ys = t);
        }
      } else Nl(t);
    }
    function Nl(t) {
      Qe(si, si.current, t), Qe(
        io,
        io.current,
        t
      );
    }
    function Gi(t) {
      fe(io, t), Ys === t && (Ys = null), fe(si, t);
    }
    function Xd(t) {
      for (var i = t; i !== null; ) {
        if (i.tag === 13) {
          var r = i.memoizedState;
          if (r !== null && (r = r.dehydrated, r === null || r.data === au || Qs(r)))
            return i;
        } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
          if ((i.flags & 128) !== 0) return i;
        } else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === t) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === t) return null;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return null;
    }
    function un(t) {
      if (t !== null && typeof t != "function") {
        var i = String(t);
        $w.has(i) || ($w.add(i), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          t
        ));
      }
    }
    function Lf(t, i, r, h) {
      var g = t.memoizedState, O = r(h, g);
      if (t.mode & tl) {
        Ke(!0);
        try {
          O = r(h, g);
        } finally {
          Ke(!1);
        }
      }
      O === void 0 && (i = we(i) || "Component", Xw.has(i) || (Xw.add(i), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        i
      ))), g = O == null ? g : Ie({}, g, O), t.memoizedState = g, t.lanes === 0 && (t.updateQueue.baseState = g);
    }
    function jd(t, i, r, h, g, O, x) {
      var R = t.stateNode;
      if (typeof R.shouldComponentUpdate == "function") {
        if (r = R.shouldComponentUpdate(
          h,
          O,
          x
        ), t.mode & tl) {
          Ke(!0);
          try {
            r = R.shouldComponentUpdate(
              h,
              O,
              x
            );
          } finally {
            Ke(!1);
          }
        }
        return r === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          we(i) || "Component"
        ), r;
      }
      return i.prototype && i.prototype.isPureReactComponent ? !bf(r, h) || !bf(g, O) : !0;
    }
    function Bg(t, i, r, h) {
      var g = i.state;
      typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(r, h), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(r, h), i.state !== g && (t = Te(t) || "Component", qw.has(t) || (qw.add(t), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        t
      )), YS.enqueueReplaceState(
        i,
        i.state,
        null
      ));
    }
    function Ss(t, i) {
      var r = i;
      if ("ref" in i) {
        r = {};
        for (var h in i)
          h !== "ref" && (r[h] = i[h]);
      }
      if (t = t.defaultProps) {
        r === i && (r = Ie({}, r));
        for (var g in t)
          r[g] === void 0 && (r[g] = t[g]);
      }
      return r;
    }
    function IO(t) {
      $S(t), console.warn(
        `%s

%s
`,
        cm ? "An error occurred in the <" + cm + "> component." : "An error occurred in one of your React components.",
        `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
      );
    }
    function Gd(t) {
      var i = cm ? "The above error occurred in the <" + cm + "> component." : "The above error occurred in one of your React components.", r = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((ZS || "Anonymous") + ".");
      if (typeof t == "object" && t !== null && typeof t.environmentName == "string") {
        var h = t.environmentName;
        t = [
          `%o

%s

%s
`,
          t,
          i,
          r
        ].slice(0), typeof t[0] == "string" ? t.splice(
          0,
          1,
          AE + t[0],
          wE,
          Sb + h + Sb,
          EE
        ) : t.splice(
          0,
          0,
          AE,
          wE,
          Sb + h + Sb,
          EE
        ), t.unshift(console), h = b3.apply(console.error, t), h();
      } else
        console.error(
          `%o

%s

%s
`,
          t,
          i,
          r
        );
    }
    function Yd(t) {
      $S(t);
    }
    function Iu(t, i) {
      try {
        cm = i.source ? Te(i.source) : null, ZS = null;
        var r = i.value;
        if (I.actQueue !== null)
          I.thrownErrors.push(r);
        else {
          var h = t.onUncaughtError;
          h(r, { componentStack: i.stack });
        }
      } catch (g) {
        setTimeout(function() {
          throw g;
        });
      }
    }
    function Ei(t, i, r) {
      try {
        cm = r.source ? Te(r.source) : null, ZS = Te(i);
        var h = t.onCaughtError;
        h(r.value, {
          componentStack: r.stack,
          errorBoundary: i.tag === 1 ? i.stateNode : null
        });
      } catch (g) {
        setTimeout(function() {
          throw g;
        });
      }
    }
    function dn(t, i, r) {
      return r = na(r), r.tag = BS, r.payload = { element: null }, r.callback = function() {
        Ge(i.source, Iu, t, i);
      }, r;
    }
    function Vf(t) {
      return t = na(t), t.tag = BS, t;
    }
    function Br(t, i, r, h) {
      var g = r.type.getDerivedStateFromError;
      if (typeof g == "function") {
        var O = h.value;
        t.payload = function() {
          return g(O);
        }, t.callback = function() {
          Sd(r), Ge(
            h.source,
            Ei,
            i,
            r,
            h
          );
        };
      }
      var x = r.stateNode;
      x !== null && typeof x.componentDidCatch == "function" && (t.callback = function() {
        Sd(r), Ge(
          h.source,
          Ei,
          i,
          r,
          h
        ), typeof g != "function" && (qc === null ? qc = /* @__PURE__ */ new Set([this]) : qc.add(this)), Kz(this, h), typeof g == "function" || (r.lanes & 2) === 0 && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          Te(r) || "Unknown"
        );
      });
    }
    function $d(t, i, r, h, g) {
      if (r.flags |= 32768, Ll && jr(t, g), h !== null && typeof h == "object" && typeof h.then == "function") {
        if (i = r.alternate, i !== null && To(
          i,
          r,
          g,
          !0
        ), Rt && (eu = !0), r = io.current, r !== null) {
          switch (r.tag) {
            case 13:
              return Ys === null ? op() : r.alternate === null && Cn === lu && (Cn = KS), r.flags &= -257, r.flags |= 65536, r.lanes = g, h === US ? r.flags |= 16384 : (i = r.updateQueue, i === null ? r.updateQueue = /* @__PURE__ */ new Set([h]) : i.add(h), O0(t, h, g)), !1;
            case 22:
              return r.flags |= 65536, h === US ? r.flags |= 16384 : (i = r.updateQueue, i === null ? (i = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([h])
              }, r.updateQueue = i) : (r = i.retryQueue, r === null ? i.retryQueue = /* @__PURE__ */ new Set([h]) : r.add(h)), O0(t, h, g)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + r.tag + "). This is a bug in React."
          );
        }
        return O0(t, h, g), op(), !1;
      }
      if (Rt)
        return eu = !0, i = io.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = g, h !== MS && Qu(
          Bi(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: h }
            ),
            r
          )
        )) : (h !== MS && Qu(
          Bi(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: h }
            ),
            r
          )
        ), t = t.current.alternate, t.flags |= 65536, g &= -g, t.lanes |= g, h = Bi(h, r), g = dn(
          t.stateNode,
          h,
          g
        ), Ao(t, g), Cn !== Nh && (Cn = pm)), !1;
      var O = Bi(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: h }
        ),
        r
      );
      if (Dy === null ? Dy = [O] : Dy.push(O), Cn !== Nh && (Cn = pm), i === null) return !0;
      h = Bi(h, r), r = i;
      do {
        switch (r.tag) {
          case 3:
            return r.flags |= 65536, t = g & -g, r.lanes |= t, t = dn(
              r.stateNode,
              h,
              t
            ), Ao(r, t), !1;
          case 1:
            if (i = r.type, O = r.stateNode, (r.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || O !== null && typeof O.componentDidCatch == "function" && (qc === null || !qc.has(O))))
              return r.flags |= 65536, g &= -g, r.lanes |= g, g = Vf(g), Br(
                g,
                t,
                r,
                h
              ), Ao(r, g), !1;
        }
        r = r.return;
      } while (r !== null);
      return !1;
    }
    function Dn(t, i, r, h) {
      i.child = t === null ? Uw(i, null, r, h) : rm(
        i,
        t.child,
        r,
        h
      );
    }
    function _a(t, i, r, h, g) {
      r = r.render;
      var O = i.ref;
      if ("ref" in h) {
        var x = {};
        for (var R in h)
          R !== "ref" && (x[R] = h[R]);
      } else x = h;
      return hs(i), Rn(i), h = _u(
        t,
        i,
        r,
        x,
        O,
        g
      ), R = wo(), Ti(), t !== null && !yi ? (aa(t, i, g), Ha(t, i, g)) : (Rt && R && Ad(i), i.flags |= 1, Dn(t, i, h, g), i.child);
    }
    function Xf(t, i, r, h, g) {
      if (t === null) {
        var O = r.type;
        return typeof O == "function" && !Td(O) && O.defaultProps === void 0 && r.compare === null ? (r = Tr(O), i.tag = 15, i.type = r, Gf(i, O), Zd(
          t,
          i,
          r,
          h,
          g
        )) : (t = xd(
          r.type,
          null,
          h,
          i,
          i.mode,
          g
        ), t.ref = i.ref, t.return = i, i.child = t);
      }
      if (O = t.child, !$g(t, g)) {
        var x = O.memoizedProps;
        if (r = r.compare, r = r !== null ? r : bf, r(x, h) && t.ref === i.ref)
          return Ha(
            t,
            i,
            g
          );
      }
      return i.flags |= 1, t = Na(O, h), t.ref = i.ref, t.return = i, i.child = t;
    }
    function Zd(t, i, r, h, g) {
      if (t !== null) {
        var O = t.memoizedProps;
        if (bf(O, h) && t.ref === i.ref && i.type === t.type)
          if (yi = !1, i.pendingProps = h = O, $g(t, g))
            (t.flags & 131072) !== 0 && (yi = !0);
          else
            return i.lanes = t.lanes, Ha(t, i, g);
      }
      return Wd(
        t,
        i,
        r,
        h,
        g
      );
    }
    function Pd(t, i, r) {
      var h = i.pendingProps, g = h.children, O = t !== null ? t.memoizedState : null;
      if (h.mode === "hidden") {
        if ((i.flags & 128) !== 0) {
          if (h = O !== null ? O.baseLanes | r : r, t !== null) {
            for (g = i.child = t.child, O = 0; g !== null; )
              O = O | g.lanes | g.childLanes, g = g.sibling;
            i.childLanes = O & ~h;
          } else i.childLanes = 0, i.child = null;
          return qg(
            t,
            i,
            h,
            r
          );
        }
        if ((r & 536870912) !== 0)
          i.memoizedState = { baseLanes: 0, cachePool: null }, t !== null && kd(
            i,
            O !== null ? O.cachePool : null
          ), O !== null ? Md(i, O) : la(i), Hf(i);
        else
          return i.lanes = i.childLanes = 536870912, qg(
            t,
            i,
            O !== null ? O.baseLanes | r : r,
            r
          );
      } else
        O !== null ? (kd(i, O.cachePool), Md(i, O), Nl(i), i.memoizedState = null) : (t !== null && kd(i, null), la(i), Nl(i));
      return Dn(t, i, g, r), i.child;
    }
    function qg(t, i, r, h) {
      var g = Tg();
      return g = g === null ? null : {
        parent: ai._currentValue,
        pool: g
      }, i.memoizedState = {
        baseLanes: r,
        cachePool: g
      }, t !== null && kd(i, null), la(i), Hf(i), t !== null && To(t, i, h, !0), null;
    }
    function jf(t, i) {
      var r = i.ref;
      if (r === null)
        t !== null && t.ref !== null && (i.flags |= 4194816);
      else {
        if (typeof r != "function" && typeof r != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (t === null || t.ref !== r) && (i.flags |= 4194816);
      }
    }
    function Wd(t, i, r, h, g) {
      if (r.prototype && typeof r.prototype.render == "function") {
        var O = we(r) || "Unknown";
        Pw[O] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          O,
          O
        ), Pw[O] = !0);
      }
      return i.mode & tl && Ko.recordLegacyContextWarning(
        i,
        null
      ), t === null && (Gf(i, i.type), r.contextTypes && (O = we(r) || "Unknown", Fw[O] || (Fw[O] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        O
      )))), hs(i), Rn(i), r = _u(
        t,
        i,
        r,
        h,
        void 0,
        g
      ), h = wo(), Ti(), t !== null && !yi ? (aa(t, i, g), Ha(t, i, g)) : (Rt && h && Ad(i), i.flags |= 1, Dn(t, i, r, g), i.child);
    }
    function _g(t, i, r, h, g, O) {
      return hs(i), Rn(i), nu = -1, Sy = t !== null && t.type !== i.type, i.updateQueue = null, r = Li(
        i,
        h,
        r,
        g
      ), Ef(t, i), h = wo(), Ti(), t !== null && !yi ? (aa(t, i, O), Ha(t, i, O)) : (Rt && h && Ad(i), i.flags |= 1, Dn(t, i, r, O), i.child);
    }
    function Hg(t, i, r, h, g) {
      switch (m(i)) {
        case !1:
          var O = i.stateNode, x = new i.type(
            i.memoizedProps,
            O.context
          ).state;
          O.updater.enqueueSetState(O, x, null);
          break;
        case !0:
          i.flags |= 128, i.flags |= 65536, O = Error("Simulated error coming from DevTools");
          var R = g & -g;
          if (i.lanes |= R, x = It, x === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          R = Vf(R), Br(
            R,
            x,
            i,
            Bi(O, i)
          ), Ao(i, R);
      }
      if (hs(i), i.stateNode === null) {
        if (x = Dc, O = r.contextType, "contextType" in r && O !== null && (O === void 0 || O.$$typeof !== Ii) && !Yw.has(r) && (Yw.add(r), R = O === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof O != "object" ? " However, it is set to a " + typeof O + "." : O.$$typeof === hh ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(O).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          we(r) || "Component",
          R
        )), typeof O == "object" && O !== null && (x = Wt(O)), O = new r(h, x), i.mode & tl) {
          Ke(!0);
          try {
            O = new r(h, x);
          } finally {
            Ke(!1);
          }
        }
        if (x = i.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null, O.updater = YS, i.stateNode = O, O._reactInternals = i, O._reactInternalInstance = Bw, typeof r.getDerivedStateFromProps == "function" && x === null && (x = we(r) || "Component", _w.has(x) || (_w.add(x), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          x,
          O.state === null ? "null" : "undefined",
          x
        ))), typeof r.getDerivedStateFromProps == "function" || typeof O.getSnapshotBeforeUpdate == "function") {
          var Q = R = x = null;
          if (typeof O.componentWillMount == "function" && O.componentWillMount.__suppressDeprecationWarning !== !0 ? x = "componentWillMount" : typeof O.UNSAFE_componentWillMount == "function" && (x = "UNSAFE_componentWillMount"), typeof O.componentWillReceiveProps == "function" && O.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? R = "componentWillReceiveProps" : typeof O.UNSAFE_componentWillReceiveProps == "function" && (R = "UNSAFE_componentWillReceiveProps"), typeof O.componentWillUpdate == "function" && O.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Q = "componentWillUpdate" : typeof O.UNSAFE_componentWillUpdate == "function" && (Q = "UNSAFE_componentWillUpdate"), x !== null || R !== null || Q !== null) {
            O = we(r) || "Component";
            var N = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Lw.has(O) || (Lw.add(O), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              O,
              N,
              x !== null ? `
  ` + x : "",
              R !== null ? `
  ` + R : "",
              Q !== null ? `
  ` + Q : ""
            ));
          }
        }
        O = i.stateNode, x = we(r) || "Component", O.render || (r.prototype && typeof r.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          x
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          x
        )), !O.getInitialState || O.getInitialState.isReactClassApproved || O.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          x
        ), O.getDefaultProps && !O.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          x
        ), O.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          x
        ), r.childContextTypes && !Gw.has(r) && (Gw.add(r), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          x
        )), r.contextTypes && !jw.has(r) && (jw.add(r), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          x
        )), typeof O.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          x
        ), r.prototype && r.prototype.isPureReactComponent && typeof O.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          we(r) || "A pure component"
        ), typeof O.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          x
        ), typeof O.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          x
        ), typeof O.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          x
        ), typeof O.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          x
        ), R = O.props !== h, O.props !== void 0 && R && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          x
        ), O.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          x,
          x
        ), typeof O.getSnapshotBeforeUpdate != "function" || typeof O.componentDidUpdate == "function" || Hw.has(r) || (Hw.add(r), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          we(r)
        )), typeof O.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          x
        ), typeof O.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          x
        ), typeof r.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          x
        ), (R = O.state) && (typeof R != "object" || zn(R)) && console.error("%s.state: must be set to an object or null", x), typeof O.getChildContext == "function" && typeof r.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          x
        ), O = i.stateNode, O.props = h, O.state = i.memoizedState, O.refs = {}, ps(i), x = r.contextType, O.context = typeof x == "object" && x !== null ? Wt(x) : Dc, O.state === h && (x = we(r) || "Component", Vw.has(x) || (Vw.add(x), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          x
        ))), i.mode & tl && Ko.recordLegacyContextWarning(
          i,
          O
        ), Ko.recordUnsafeLifecycleWarnings(
          i,
          O
        ), O.state = i.memoizedState, x = r.getDerivedStateFromProps, typeof x == "function" && (Lf(
          i,
          r,
          x,
          h
        ), O.state = i.memoizedState), typeof r.getDerivedStateFromProps == "function" || typeof O.getSnapshotBeforeUpdate == "function" || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (x = O.state, typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount(), x !== O.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          Te(i) || "Component"
        ), YS.enqueueReplaceState(
          O,
          O.state,
          null
        )), ms(i, h, O, g), Bu(), O.state = i.memoizedState), typeof O.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Fo) !== on && (i.flags |= 134217728), O = !0;
      } else if (t === null) {
        O = i.stateNode;
        var ee = i.memoizedProps;
        R = Ss(r, ee), O.props = R;
        var oe = O.context;
        Q = r.contextType, x = Dc, typeof Q == "object" && Q !== null && (x = Wt(Q)), N = r.getDerivedStateFromProps, Q = typeof N == "function" || typeof O.getSnapshotBeforeUpdate == "function", ee = i.pendingProps !== ee, Q || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (ee || oe !== x) && Bg(
          i,
          O,
          h,
          x
        ), Mc = !1;
        var J = i.memoizedState;
        O.state = J, ms(i, h, O, g), Bu(), oe = i.memoizedState, ee || J !== oe || Mc ? (typeof N == "function" && (Lf(
          i,
          r,
          N,
          h
        ), oe = i.memoizedState), (R = Mc || jd(
          i,
          r,
          R,
          h,
          J,
          oe,
          x
        )) ? (Q || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()), typeof O.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Fo) !== on && (i.flags |= 134217728)) : (typeof O.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Fo) !== on && (i.flags |= 134217728), i.memoizedProps = h, i.memoizedState = oe), O.props = h, O.state = oe, O.context = x, O = R) : (typeof O.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Fo) !== on && (i.flags |= 134217728), O = !1);
      } else {
        O = i.stateNode, wf(t, i), x = i.memoizedProps, Q = Ss(r, x), O.props = Q, N = i.pendingProps, J = O.context, oe = r.contextType, R = Dc, typeof oe == "object" && oe !== null && (R = Wt(oe)), ee = r.getDerivedStateFromProps, (oe = typeof ee == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (x !== N || J !== R) && Bg(
          i,
          O,
          h,
          R
        ), Mc = !1, J = i.memoizedState, O.state = J, ms(i, h, O, g), Bu();
        var re = i.memoizedState;
        x !== N || J !== re || Mc || t !== null && t.dependencies !== null && Tf(t.dependencies) ? (typeof ee == "function" && (Lf(
          i,
          r,
          ee,
          h
        ), re = i.memoizedState), (Q = Mc || jd(
          i,
          r,
          Q,
          h,
          J,
          re,
          R
        ) || t !== null && t.dependencies !== null && Tf(t.dependencies)) ? (oe || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(h, re, R), typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(
          h,
          re,
          R
        )), typeof O.componentDidUpdate == "function" && (i.flags |= 4), typeof O.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || x === t.memoizedProps && J === t.memoizedState || (i.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || x === t.memoizedProps && J === t.memoizedState || (i.flags |= 1024), i.memoizedProps = h, i.memoizedState = re), O.props = h, O.state = re, O.context = R, O = Q) : (typeof O.componentDidUpdate != "function" || x === t.memoizedProps && J === t.memoizedState || (i.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || x === t.memoizedProps && J === t.memoizedState || (i.flags |= 1024), O = !1);
      }
      if (R = O, jf(t, i), x = (i.flags & 128) !== 0, R || x) {
        if (R = i.stateNode, os(i), x && typeof r.getDerivedStateFromError != "function")
          r = null, Vl = -1;
        else {
          if (Rn(i), r = Sw(R), i.mode & tl) {
            Ke(!0);
            try {
              Sw(R);
            } finally {
              Ke(!1);
            }
          }
          Ti();
        }
        i.flags |= 1, t !== null && x ? (i.child = rm(
          i,
          t.child,
          null,
          g
        ), i.child = rm(
          i,
          null,
          r,
          g
        )) : Dn(t, i, r, g), i.memoizedState = R.state, t = i.child;
      } else
        t = Ha(
          t,
          i,
          g
        );
      return g = i.stateNode, O && g.props !== h && (fm || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        Te(i) || "a component"
      ), fm = !0), t;
    }
    function Lg(t, i, r, h) {
      return zu(), i.flags |= 256, Dn(t, i, r, h), i.child;
    }
    function Gf(t, i) {
      i && i.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        i.displayName || i.name || "Component"
      ), typeof i.getDerivedStateFromProps == "function" && (t = we(i) || "Unknown", Kw[t] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        t
      ), Kw[t] = !0)), typeof i.contextType == "object" && i.contextType !== null && (i = we(i) || "Unknown", Ww[i] || (console.error(
        "%s: Function components do not support contextType.",
        i
      ), Ww[i] = !0));
    }
    function Fd(t) {
      return { baseLanes: t, cachePool: xg() };
    }
    function Vg(t, i, r) {
      return t = t !== null ? t.childLanes & ~r : 0, i && (t |= wa), t;
    }
    function Xg(t, i, r) {
      var h, g = i.pendingProps;
      d(i) && (i.flags |= 128);
      var O = !1, x = (i.flags & 128) !== 0;
      if ((h = x) || (h = t !== null && t.memoizedState === null ? !1 : (si.current & xy) !== 0), h && (O = !0, i.flags &= -129), h = (i.flags & 32) !== 0, i.flags &= -33, t === null) {
        if (Rt) {
          if (O ? ji(i) : Nl(i), Rt) {
            var R = En, Q;
            if (!(Q = !R)) {
              e: {
                var N = R;
                for (Q = js; N.nodeType !== 8; ) {
                  if (!Q) {
                    Q = null;
                    break e;
                  }
                  if (N = Ki(N.nextSibling), N === null) {
                    Q = null;
                    break e;
                  }
                }
                Q = N;
              }
              Q !== null ? (ea(), i.memoizedState = {
                dehydrated: Q,
                treeContext: Ch !== null ? { id: Jr, overflow: Ir } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, N = E(18, null, null, on), N.stateNode = Q, N.return = i, i.child = N, bl = i, En = null, Q = !0) : Q = !1, Q = !Q;
            }
            Q && (Mu(
              i,
              R
            ), cs(i));
          }
          if (R = i.memoizedState, R !== null && (R = R.dehydrated, R !== null))
            return Qs(R) ? i.lanes = 32 : i.lanes = 536870912, null;
          Gi(i);
        }
        return R = g.children, g = g.fallback, O ? (Nl(i), O = i.mode, R = Yf(
          {
            mode: "hidden",
            children: R
          },
          O
        ), g = Dl(
          g,
          O,
          r,
          null
        ), R.return = i, g.return = i, R.sibling = g, i.child = R, O = i.child, O.memoizedState = Fd(r), O.childLanes = Vg(
          t,
          h,
          r
        ), i.memoizedState = WS, g) : (ji(i), Kd(
          i,
          R
        ));
      }
      var ee = t.memoizedState;
      if (ee !== null && (R = ee.dehydrated, R !== null)) {
        if (x)
          i.flags & 256 ? (ji(i), i.flags &= -257, i = $f(
            t,
            i,
            r
          )) : i.memoizedState !== null ? (Nl(i), i.child = t.child, i.flags |= 128, i = null) : (Nl(i), O = g.fallback, R = i.mode, g = Yf(
            {
              mode: "visible",
              children: g.children
            },
            R
          ), O = Dl(
            O,
            R,
            r,
            null
          ), O.flags |= 2, g.return = i, O.return = i, g.sibling = O, i.child = g, rm(
            i,
            t.child,
            null,
            r
          ), g = i.child, g.memoizedState = Fd(r), g.childLanes = Vg(
            t,
            h,
            r
          ), i.memoizedState = WS, i = O);
        else if (ji(i), Rt && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), Qs(R)) {
          if (h = R.nextSibling && R.nextSibling.dataset, h) {
            Q = h.dgst;
            var oe = h.msg;
            N = h.stck;
            var J = h.cstck;
          }
          R = oe, h = Q, g = N, Q = O = J, O = Error(R || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), O.stack = g || "", O.digest = h, h = Q === void 0 ? null : Q, g = {
            value: O,
            source: null,
            stack: h
          }, typeof h == "string" && RS.set(
            O,
            g
          ), Qu(g), i = $f(
            t,
            i,
            r
          );
        } else if (yi || To(
          t,
          i,
          r,
          !1
        ), h = (r & t.childLanes) !== 0, yi || h) {
          if (h = It, h !== null && (g = r & -r, g = (g & 42) !== 0 ? 1 : El(
            g
          ), g = (g & (h.suspendedLanes | r)) !== 0 ? 0 : g, g !== 0 && g !== ee.retryLane))
            throw ee.retryLane = g, qi(
              t,
              g
            ), mt(
              h,
              t,
              g
            ), Zw;
          R.data === au || op(), i = $f(
            t,
            i,
            r
          );
        } else
          R.data === au ? (i.flags |= 192, i.child = t.child, i = null) : (t = ee.treeContext, En = Ki(
            R.nextSibling
          ), bl = i, Rt = !0, Rh = null, eu = !1, Ia = null, js = !1, t !== null && (ea(), Ka[Ja++] = Jr, Ka[Ja++] = Ir, Ka[Ja++] = Ch, Jr = t.id, Ir = t.overflow, Ch = i), i = Kd(
            i,
            g.children
          ), i.flags |= 4096);
        return i;
      }
      return O ? (Nl(i), O = g.fallback, R = i.mode, Q = t.child, N = Q.sibling, g = Na(
        Q,
        {
          mode: "hidden",
          children: g.children
        }
      ), g.subtreeFlags = Q.subtreeFlags & 65011712, N !== null ? O = Na(
        N,
        O
      ) : (O = Dl(
        O,
        R,
        r,
        null
      ), O.flags |= 2), O.return = i, g.return = i, g.sibling = O, i.child = g, g = O, O = i.child, R = t.child.memoizedState, R === null ? R = Fd(r) : (Q = R.cachePool, Q !== null ? (N = ai._currentValue, Q = Q.parent !== N ? { parent: N, pool: N } : Q) : Q = xg(), R = {
        baseLanes: R.baseLanes | r,
        cachePool: Q
      }), O.memoizedState = R, O.childLanes = Vg(
        t,
        h,
        r
      ), i.memoizedState = WS, g) : (ji(i), r = t.child, t = r.sibling, r = Na(r, {
        mode: "visible",
        children: g.children
      }), r.return = i, r.sibling = null, t !== null && (h = i.deletions, h === null ? (i.deletions = [t], i.flags |= 16) : h.push(t)), i.child = r, i.memoizedState = null, r);
    }
    function Kd(t, i) {
      return i = Yf(
        { mode: "visible", children: i },
        t.mode
      ), i.return = t, t.child = i;
    }
    function Yf(t, i) {
      return t = E(22, t, null, i), t.lanes = 0, t.stateNode = {
        _visibility: kS,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, t;
    }
    function $f(t, i, r) {
      return rm(i, t.child, null, r), t = Kd(
        i,
        i.pendingProps.children
      ), t.flags |= 2, i.memoizedState = null, t;
    }
    function jg(t, i, r) {
      t.lanes |= i;
      var h = t.alternate;
      h !== null && (h.lanes |= i), vg(
        t.return,
        i,
        r
      );
    }
    function Gg(t, i) {
      var r = zn(t);
      return t = !r && typeof Oe(t) == "function", r || t ? (r = r ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        r,
        i,
        r
      ), !1) : !0;
    }
    function Jd(t, i, r, h, g) {
      var O = t.memoizedState;
      O === null ? t.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: h,
        tail: r,
        tailMode: g
      } : (O.isBackwards = i, O.rendering = null, O.renderingStartTime = 0, O.last = h, O.tail = r, O.tailMode = g);
    }
    function Yg(t, i, r) {
      var h = i.pendingProps, g = h.revealOrder, O = h.tail;
      if (h = h.children, g !== void 0 && g !== "forwards" && g !== "backwards" && g !== "together" && !Jw[g])
        if (Jw[g] = !0, typeof g == "string")
          switch (g.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                g,
                g.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                g,
                g.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                g
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            g
          );
      O === void 0 || PS[O] || (O !== "collapsed" && O !== "hidden" ? (PS[O] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        O
      )) : g !== "forwards" && g !== "backwards" && (PS[O] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        O
      )));
      e: if ((g === "forwards" || g === "backwards") && h !== void 0 && h !== null && h !== !1)
        if (zn(h)) {
          for (var x = 0; x < h.length; x++)
            if (!Gg(h[x], x)) break e;
        } else if (x = Oe(h), typeof x == "function") {
          if (x = x.call(h))
            for (var R = x.next(), Q = 0; !R.done; R = x.next()) {
              if (!Gg(R.value, Q)) break e;
              Q++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            g
          );
      if (Dn(t, i, h, r), h = si.current, (h & xy) !== 0)
        h = h & um | xy, i.flags |= 128;
      else {
        if (t !== null && (t.flags & 128) !== 0)
          e: for (t = i.child; t !== null; ) {
            if (t.tag === 13)
              t.memoizedState !== null && jg(
                t,
                r,
                i
              );
            else if (t.tag === 19)
              jg(t, r, i);
            else if (t.child !== null) {
              t.child.return = t, t = t.child;
              continue;
            }
            if (t === i) break e;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === i)
                break e;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
        h &= um;
      }
      switch (Qe(si, h, i), g) {
        case "forwards":
          for (r = i.child, g = null; r !== null; )
            t = r.alternate, t !== null && Xd(t) === null && (g = r), r = r.sibling;
          r = g, r === null ? (g = i.child, i.child = null) : (g = r.sibling, r.sibling = null), Jd(
            i,
            !1,
            g,
            r,
            O
          );
          break;
        case "backwards":
          for (r = null, g = i.child, i.child = null; g !== null; ) {
            if (t = g.alternate, t !== null && Xd(t) === null) {
              i.child = g;
              break;
            }
            t = g.sibling, g.sibling = r, r = g, g = t;
          }
          Jd(
            i,
            !0,
            r,
            null,
            O
          );
          break;
        case "together":
          Jd(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
      return i.child;
    }
    function Ha(t, i, r) {
      if (t !== null && (i.dependencies = t.dependencies), Vl = -1, Uc |= i.lanes, (r & i.childLanes) === 0)
        if (t !== null) {
          if (To(
            t,
            i,
            r,
            !1
          ), (r & i.childLanes) === 0)
            return null;
        } else return null;
      if (t !== null && i.child !== t.child)
        throw Error("Resuming work not yet implemented.");
      if (i.child !== null) {
        for (t = i.child, r = Na(t, t.pendingProps), i.child = r, r.return = i; t.sibling !== null; )
          t = t.sibling, r = r.sibling = Na(t, t.pendingProps), r.return = i;
        r.sibling = null;
      }
      return i.child;
    }
    function $g(t, i) {
      return (t.lanes & i) !== 0 ? !0 : (t = t.dependencies, !!(t !== null && Tf(t)));
    }
    function ev(t, i, r) {
      switch (i.tag) {
        case 3:
          Xe(
            i,
            i.stateNode.containerInfo
          ), fs(
            i,
            ai,
            t.memoizedState.cache
          ), zu();
          break;
        case 27:
        case 5:
          ge(i);
          break;
        case 4:
          Xe(
            i,
            i.stateNode.containerInfo
          );
          break;
        case 10:
          fs(
            i,
            i.type,
            i.memoizedProps.value
          );
          break;
        case 12:
          (r & i.childLanes) !== 0 && (i.flags |= 4), i.flags |= 2048;
          var h = i.stateNode;
          h.effectDuration = -0, h.passiveEffectDuration = -0;
          break;
        case 13:
          if (h = i.memoizedState, h !== null)
            return h.dehydrated !== null ? (ji(i), i.flags |= 128, null) : (r & i.child.childLanes) !== 0 ? Xg(
              t,
              i,
              r
            ) : (ji(i), t = Ha(
              t,
              i,
              r
            ), t !== null ? t.sibling : null);
          ji(i);
          break;
        case 19:
          var g = (t.flags & 128) !== 0;
          if (h = (r & i.childLanes) !== 0, h || (To(
            t,
            i,
            r,
            !1
          ), h = (r & i.childLanes) !== 0), g) {
            if (h)
              return Yg(
                t,
                i,
                r
              );
            i.flags |= 128;
          }
          if (g = i.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), Qe(
            si,
            si.current,
            i
          ), h) break;
          return null;
        case 22:
        case 23:
          return i.lanes = 0, Pd(t, i, r);
        case 24:
          fs(
            i,
            ai,
            t.memoizedState.cache
          );
      }
      return Ha(t, i, r);
    }
    function Ts(t, i, r) {
      if (i._debugNeedsRemount && t !== null) {
        r = xd(
          i.type,
          i.key,
          i.pendingProps,
          i._debugOwner || null,
          i.mode,
          i.lanes
        ), r._debugStack = i._debugStack, r._debugTask = i._debugTask;
        var h = i.return;
        if (h === null) throw Error("Cannot swap the root fiber.");
        if (t.alternate = null, i.alternate = null, r.index = i.index, r.sibling = i.sibling, r.return = i.return, r.ref = i.ref, r._debugInfo = i._debugInfo, i === h.child)
          h.child = r;
        else {
          var g = h.child;
          if (g === null)
            throw Error("Expected parent to have a child.");
          for (; g.sibling !== i; )
            if (g = g.sibling, g === null)
              throw Error("Expected to find the previous sibling.");
          g.sibling = r;
        }
        return i = h.deletions, i === null ? (h.deletions = [t], h.flags |= 16) : i.push(t), r.flags |= 2, r;
      }
      if (t !== null)
        if (t.memoizedProps !== i.pendingProps || i.type !== t.type)
          yi = !0;
        else {
          if (!$g(t, r) && (i.flags & 128) === 0)
            return yi = !1, ev(
              t,
              i,
              r
            );
          yi = (t.flags & 131072) !== 0;
        }
      else
        yi = !1, (h = Rt) && (ea(), h = (i.flags & 1048576) !== 0), h && (h = i.index, ea(), gg(i, Yv, h));
      switch (i.lanes = 0, i.tag) {
        case 16:
          e: if (h = i.pendingProps, t = Qc(i.elementType), i.type = t, typeof t == "function")
            Td(t) ? (h = Ss(
              t,
              h
            ), i.tag = 1, i.type = t = Tr(t), i = Hg(
              null,
              i,
              t,
              h,
              r
            )) : (i.tag = 0, Gf(i, t), i.type = t = Tr(t), i = Wd(
              null,
              i,
              t,
              h,
              r
            ));
          else {
            if (t != null) {
              if (g = t.$$typeof, g === qs) {
                i.tag = 11, i.type = t = hg(t), i = _a(
                  null,
                  i,
                  t,
                  h,
                  r
                );
                break e;
              } else if (g === zp) {
                i.tag = 14, i = Xf(
                  null,
                  i,
                  t,
                  h,
                  r
                );
                break e;
              }
            }
            throw i = "", t !== null && typeof t == "object" && t.$$typeof === yl && (i = " Did you wrap a component in React.lazy() more than once?"), t = we(t) || t, Error(
              "Element type is invalid. Received a promise that resolves to: " + t + ". Lazy element type must resolve to a class or function." + i
            );
          }
          return i;
        case 0:
          return Wd(
            t,
            i,
            i.type,
            i.pendingProps,
            r
          );
        case 1:
          return h = i.type, g = Ss(
            h,
            i.pendingProps
          ), Hg(
            t,
            i,
            h,
            g,
            r
          );
        case 3:
          e: {
            if (Xe(
              i,
              i.stateNode.containerInfo
            ), t === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            h = i.pendingProps;
            var O = i.memoizedState;
            g = O.element, wf(t, i), ms(i, h, null, r);
            var x = i.memoizedState;
            if (h = x.cache, fs(i, ai, h), h !== O.cache && Ai(
              i,
              [ai],
              r,
              !0
            ), Bu(), h = x.element, O.isDehydrated)
              if (O = {
                element: h,
                isDehydrated: !1,
                cache: x.cache
              }, i.updateQueue.baseState = O, i.memoizedState = O, i.flags & 256) {
                i = Lg(
                  t,
                  i,
                  h,
                  r
                );
                break e;
              } else if (h !== g) {
                g = Bi(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  i
                ), Qu(g), i = Lg(
                  t,
                  i,
                  h,
                  r
                );
                break e;
              } else {
                switch (t = i.stateNode.containerInfo, t.nodeType) {
                  case 9:
                    t = t.body;
                    break;
                  default:
                    t = t.nodeName === "HTML" ? t.ownerDocument.body : t;
                }
                for (En = Ki(t.firstChild), bl = i, Rt = !0, Rh = null, eu = !1, Ia = null, js = !0, t = Uw(
                  i,
                  null,
                  h,
                  r
                ), i.child = t; t; )
                  t.flags = t.flags & -3 | 4096, t = t.sibling;
              }
            else {
              if (zu(), h === g) {
                i = Ha(
                  t,
                  i,
                  r
                );
                break e;
              }
              Dn(
                t,
                i,
                h,
                r
              );
            }
            i = i.child;
          }
          return i;
        case 26:
          return jf(t, i), t === null ? (t = ah(
            i.type,
            null,
            i.pendingProps,
            null
          )) ? i.memoizedState = t : Rt || (t = i.type, r = i.pendingProps, h = Ve(
            Xa.current
          ), h = Et(
            h
          ).createElement(t), h[gi] = i, h[el] = r, Ln(h, t, r), Y(h), i.stateNode = h) : i.memoizedState = ah(
            i.type,
            t.memoizedProps,
            i.pendingProps,
            t.memoizedState
          ), null;
        case 27:
          return ge(i), t === null && Rt && (h = Ve(Xa.current), g = Z(), h = i.stateNode = Ji(
            i.type,
            i.pendingProps,
            h,
            g,
            !1
          ), eu || (g = yt(
            h,
            i.type,
            i.pendingProps,
            g
          ), g !== null && (Er(i, 0).serverProps = g)), bl = i, js = !0, g = En, Mn(i.type) ? (OT = g, En = Ki(
            h.firstChild
          )) : En = g), Dn(
            t,
            i,
            i.pendingProps.children,
            r
          ), jf(t, i), t === null && (i.flags |= 4194304), i.child;
        case 5:
          return t === null && Rt && (O = Z(), h = fd(
            i.type,
            O.ancestorInfo
          ), g = En, (x = !g) || (x = ti(
            g,
            i.type,
            i.pendingProps,
            js
          ), x !== null ? (i.stateNode = x, eu || (O = yt(
            x,
            i.type,
            i.pendingProps,
            O
          ), O !== null && (Er(i, 0).serverProps = O)), bl = i, En = Ki(
            x.firstChild
          ), js = !1, O = !0) : O = !1, x = !O), x && (h && Mu(i, g), cs(i))), ge(i), g = i.type, O = i.pendingProps, x = t !== null ? t.memoizedProps : null, h = O.children, ks(g, O) ? h = null : x !== null && ks(g, x) && (i.flags |= 32), i.memoizedState !== null && (g = _u(
            t,
            i,
            zl,
            null,
            null,
            r
          ), _y._currentValue = g), jf(t, i), Dn(
            t,
            i,
            h,
            r
          ), i.child;
        case 6:
          return t === null && Rt && (t = i.pendingProps, r = Z(), h = r.ancestorInfo.current, t = h != null ? Cu(
            t,
            h.tag,
            r.ancestorInfo.implicitRootScope
          ) : !0, r = En, (h = !r) || (h = zs(
            r,
            i.pendingProps,
            js
          ), h !== null ? (i.stateNode = h, bl = i, En = null, h = !0) : h = !1, h = !h), h && (t && Mu(i, r), cs(i))), null;
        case 13:
          return Xg(t, i, r);
        case 4:
          return Xe(
            i,
            i.stateNode.containerInfo
          ), h = i.pendingProps, t === null ? i.child = rm(
            i,
            null,
            h,
            r
          ) : Dn(
            t,
            i,
            h,
            r
          ), i.child;
        case 11:
          return _a(
            t,
            i,
            i.type,
            i.pendingProps,
            r
          );
        case 7:
          return Dn(
            t,
            i,
            i.pendingProps,
            r
          ), i.child;
        case 8:
          return Dn(
            t,
            i,
            i.pendingProps.children,
            r
          ), i.child;
        case 12:
          return i.flags |= 4, i.flags |= 2048, h = i.stateNode, h.effectDuration = -0, h.passiveEffectDuration = -0, Dn(
            t,
            i,
            i.pendingProps.children,
            r
          ), i.child;
        case 10:
          return h = i.type, g = i.pendingProps, O = g.value, "value" in g || Iw || (Iw = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), fs(i, h, O), Dn(
            t,
            i,
            g.children,
            r
          ), i.child;
        case 9:
          return g = i.type._context, h = i.pendingProps.children, typeof h != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), hs(i), g = Wt(g), Rn(i), h = XS(
            h,
            g,
            void 0
          ), Ti(), i.flags |= 1, Dn(
            t,
            i,
            h,
            r
          ), i.child;
        case 14:
          return Xf(
            t,
            i,
            i.type,
            i.pendingProps,
            r
          );
        case 15:
          return Zd(
            t,
            i,
            i.type,
            i.pendingProps,
            r
          );
        case 19:
          return Yg(
            t,
            i,
            r
          );
        case 31:
          return h = i.pendingProps, r = i.mode, h = {
            mode: h.mode,
            children: h.children
          }, t === null ? (t = Yf(
            h,
            r
          ), t.ref = i.ref, i.child = t, t.return = i, i = t) : (t = Na(t.child, h), t.ref = i.ref, i.child = t, t.return = i, i = t), i;
        case 22:
          return Pd(t, i, r);
        case 24:
          return hs(i), h = Wt(ai), t === null ? (g = Tg(), g === null && (g = It, O = bg(), g.pooledCache = O, Ml(O), O !== null && (g.pooledCacheLanes |= r), g = O), i.memoizedState = {
            parent: h,
            cache: g
          }, ps(i), fs(i, ai, g)) : ((t.lanes & r) !== 0 && (wf(t, i), ms(i, null, null, r), Bu()), g = t.memoizedState, O = i.memoizedState, g.parent !== h ? (g = {
            parent: h,
            cache: h
          }, i.memoizedState = g, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = g), fs(i, ai, h)) : (h = O.cache, fs(i, ai, h), h !== g.cache && Ai(
            i,
            [ai],
            r,
            !0
          ))), Dn(
            t,
            i,
            i.pendingProps.children,
            r
          ), i.child;
        case 29:
          throw i.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Ul(t) {
      t.flags |= 4;
    }
    function Zg(t, i) {
      if (i.type !== "stylesheet" || (i.state.loading & lo) !== jh)
        t.flags &= -16777217;
      else if (t.flags |= 16777216, !U0(i)) {
        if (i = io.current, i !== null && ((vt & 4194048) === vt ? Ys !== null : (vt & 62914560) !== vt && (vt & 536870912) === 0 || i !== Ys))
          throw vy = US, uw;
        t.flags |= 8192;
      }
    }
    function qr(t, i) {
      i !== null && (t.flags |= 4), t.flags & 16384 && (i = t.tag !== 22 ? fr() : 536870912, t.lanes |= i, qh |= i);
    }
    function zo(t, i) {
      if (!Rt)
        switch (t.tailMode) {
          case "hidden":
            i = t.tail;
            for (var r = null; i !== null; )
              i.alternate !== null && (r = i), i = i.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
          case "collapsed":
            r = t.tail;
            for (var h = null; r !== null; )
              r.alternate !== null && (h = r), r = r.sibling;
            h === null ? i || t.tail === null ? t.tail = null : t.tail.sibling = null : h.sibling = null;
        }
    }
    function Ft(t) {
      var i = t.alternate !== null && t.alternate.child === t.child, r = 0, h = 0;
      if (i)
        if ((t.mode & Ri) !== on) {
          for (var g = t.selfBaseDuration, O = t.child; O !== null; )
            r |= O.lanes | O.childLanes, h |= O.subtreeFlags & 65011712, h |= O.flags & 65011712, g += O.treeBaseDuration, O = O.sibling;
          t.treeBaseDuration = g;
        } else
          for (g = t.child; g !== null; )
            r |= g.lanes | g.childLanes, h |= g.subtreeFlags & 65011712, h |= g.flags & 65011712, g.return = t, g = g.sibling;
      else if ((t.mode & Ri) !== on) {
        g = t.actualDuration, O = t.selfBaseDuration;
        for (var x = t.child; x !== null; )
          r |= x.lanes | x.childLanes, h |= x.subtreeFlags, h |= x.flags, g += x.actualDuration, O += x.treeBaseDuration, x = x.sibling;
        t.actualDuration = g, t.treeBaseDuration = O;
      } else
        for (g = t.child; g !== null; )
          r |= g.lanes | g.childLanes, h |= g.subtreeFlags, h |= g.flags, g.return = t, g = g.sibling;
      return t.subtreeFlags |= h, t.childLanes = r, i;
    }
    function tv(t, i, r) {
      var h = i.pendingProps;
      switch (wr(i), i.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Ft(i), null;
        case 1:
          return Ft(i), null;
        case 3:
          return r = i.stateNode, h = null, t !== null && (h = t.memoizedState.cache), i.memoizedState.cache !== h && (i.flags |= 2048), So(ai, i), F(i), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (Cr(i) ? (FO(), Ul(i)) : t === null || t.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, Og())), Ft(i), null;
        case 26:
          return r = i.memoizedState, t === null ? (Ul(i), r !== null ? (Ft(i), Zg(
            i,
            r
          )) : (Ft(i), i.flags &= -16777217)) : r ? r !== t.memoizedState ? (Ul(i), Ft(i), Zg(
            i,
            r
          )) : (Ft(i), i.flags &= -16777217) : (t.memoizedProps !== h && Ul(i), Ft(i), i.flags &= -16777217), null;
        case 27:
          Se(i), r = Ve(Xa.current);
          var g = i.type;
          if (t !== null && i.stateNode != null)
            t.memoizedProps !== h && Ul(i);
          else {
            if (!h) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return Ft(i), null;
            }
            t = Z(), Cr(i) ? yg(i) : (t = Ji(
              g,
              h,
              r,
              t,
              !0
            ), i.stateNode = t, Ul(i));
          }
          return Ft(i), null;
        case 5:
          if (Se(i), r = i.type, t !== null && i.stateNode != null)
            t.memoizedProps !== h && Ul(i);
          else {
            if (!h) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return Ft(i), null;
            }
            if (g = Z(), Cr(i))
              yg(i);
            else {
              switch (t = Ve(Xa.current), fd(r, g.ancestorInfo), g = g.context, t = Et(t), g) {
                case bm:
                  t = t.createElementNS(Wo, r);
                  break;
                case Ob:
                  t = t.createElementNS(
                    Gp,
                    r
                  );
                  break;
                default:
                  switch (r) {
                    case "svg":
                      t = t.createElementNS(
                        Wo,
                        r
                      );
                      break;
                    case "math":
                      t = t.createElementNS(
                        Gp,
                        r
                      );
                      break;
                    case "script":
                      t = t.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild);
                      break;
                    case "select":
                      t = typeof h.is == "string" ? t.createElement("select", { is: h.is }) : t.createElement("select"), h.multiple ? t.multiple = !0 : h.size && (t.size = h.size);
                      break;
                    default:
                      t = typeof h.is == "string" ? t.createElement(r, {
                        is: h.is
                      }) : t.createElement(r), r.indexOf("-") === -1 && (r !== r.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        r
                      ), Object.prototype.toString.call(t) !== "[object HTMLUnknownElement]" || ja.call(
                        OE,
                        r
                      ) || (OE[r] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        r
                      )));
                  }
              }
              t[gi] = i, t[el] = h;
              e: for (g = i.child; g !== null; ) {
                if (g.tag === 5 || g.tag === 6)
                  t.appendChild(g.stateNode);
                else if (g.tag !== 4 && g.tag !== 27 && g.child !== null) {
                  g.child.return = g, g = g.child;
                  continue;
                }
                if (g === i) break e;
                for (; g.sibling === null; ) {
                  if (g.return === null || g.return === i)
                    break e;
                  g = g.return;
                }
                g.sibling.return = g.return, g = g.sibling;
              }
              i.stateNode = t;
              e: switch (Ln(t, r, h), r) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  t = !!h.autoFocus;
                  break e;
                case "img":
                  t = !0;
                  break e;
                default:
                  t = !1;
              }
              t && Ul(i);
            }
          }
          return Ft(i), i.flags &= -16777217, null;
        case 6:
          if (t && i.stateNode != null)
            t.memoizedProps !== h && Ul(i);
          else {
            if (typeof h != "string" && i.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (t = Ve(Xa.current), r = Z(), Cr(i)) {
              t = i.stateNode, r = i.memoizedProps, g = !eu, h = null;
              var O = bl;
              if (O !== null)
                switch (O.tag) {
                  case 3:
                    g && (g = M0(
                      t,
                      r,
                      h
                    ), g !== null && (Er(i, 0).serverProps = g));
                    break;
                  case 27:
                  case 5:
                    h = O.memoizedProps, g && (g = M0(
                      t,
                      r,
                      h
                    ), g !== null && (Er(
                      i,
                      0
                    ).serverProps = g));
                }
              t[gi] = i, t = !!(t.nodeValue === r || h !== null && h.suppressHydrationWarning === !0 || Yr(t.nodeValue, r)), t || cs(i);
            } else
              g = r.ancestorInfo.current, g != null && Cu(
                h,
                g.tag,
                r.ancestorInfo.implicitRootScope
              ), t = Et(t).createTextNode(
                h
              ), t[gi] = i, i.stateNode = t;
          }
          return Ft(i), null;
        case 13:
          if (h = i.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (g = Cr(i), h !== null && h.dehydrated !== null) {
              if (t === null) {
                if (!g)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (g = i.memoizedState, g = g !== null ? g.dehydrated : null, !g)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                g[gi] = i, Ft(i), (i.mode & Ri) !== on && h !== null && (g = i.child, g !== null && (i.treeBaseDuration -= g.treeBaseDuration));
              } else
                FO(), zu(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4, Ft(i), (i.mode & Ri) !== on && h !== null && (g = i.child, g !== null && (i.treeBaseDuration -= g.treeBaseDuration));
              g = !1;
            } else
              g = Og(), t !== null && t.memoizedState !== null && (t.memoizedState.hydrationErrors = g), g = !0;
            if (!g)
              return i.flags & 256 ? (Gi(i), i) : (Gi(i), null);
          }
          return Gi(i), (i.flags & 128) !== 0 ? (i.lanes = r, (i.mode & Ri) !== on && Af(i), i) : (r = h !== null, t = t !== null && t.memoizedState !== null, r && (h = i.child, g = null, h.alternate !== null && h.alternate.memoizedState !== null && h.alternate.memoizedState.cachePool !== null && (g = h.alternate.memoizedState.cachePool.pool), O = null, h.memoizedState !== null && h.memoizedState.cachePool !== null && (O = h.memoizedState.cachePool.pool), O !== g && (h.flags |= 2048)), r !== t && r && (i.child.flags |= 8192), qr(i, i.updateQueue), Ft(i), (i.mode & Ri) !== on && r && (t = i.child, t !== null && (i.treeBaseDuration -= t.treeBaseDuration)), null);
        case 4:
          return F(i), t === null && nh(
            i.stateNode.containerInfo
          ), Ft(i), null;
        case 10:
          return So(i.type, i), Ft(i), null;
        case 19:
          if (fe(si, i), g = i.memoizedState, g === null) return Ft(i), null;
          if (h = (i.flags & 128) !== 0, O = g.rendering, O === null)
            if (h) zo(g, !1);
            else {
              if (Cn !== lu || t !== null && (t.flags & 128) !== 0)
                for (t = i.child; t !== null; ) {
                  if (O = Xd(t), O !== null) {
                    for (i.flags |= 128, zo(g, !1), t = O.updateQueue, i.updateQueue = t, qr(i, t), i.subtreeFlags = 0, t = r, r = i.child; r !== null; )
                      dg(r, t), r = r.sibling;
                    return Qe(
                      si,
                      si.current & um | xy,
                      i
                    ), i.child;
                  }
                  t = t.sibling;
                }
              g.tail !== null && ni() > ob && (i.flags |= 128, h = !0, zo(g, !1), i.lanes = 4194304);
            }
          else {
            if (!h)
              if (t = Xd(O), t !== null) {
                if (i.flags |= 128, h = !0, t = t.updateQueue, i.updateQueue = t, qr(i, t), zo(g, !0), g.tail === null && g.tailMode === "hidden" && !O.alternate && !Rt)
                  return Ft(i), null;
              } else
                2 * ni() - g.renderingStartTime > ob && r !== 536870912 && (i.flags |= 128, h = !0, zo(g, !1), i.lanes = 4194304);
            g.isBackwards ? (O.sibling = i.child, i.child = O) : (t = g.last, t !== null ? t.sibling = O : i.child = O, g.last = O);
          }
          return g.tail !== null ? (t = g.tail, g.rendering = t, g.tail = t.sibling, g.renderingStartTime = ni(), t.sibling = null, r = si.current, r = h ? r & um | xy : r & um, Qe(si, r, i), t) : (Ft(i), null);
        case 22:
        case 23:
          return Gi(i), zd(i), h = i.memoizedState !== null, t !== null ? t.memoizedState !== null !== h && (i.flags |= 8192) : h && (i.flags |= 8192), h ? (r & 536870912) !== 0 && (i.flags & 128) === 0 && (Ft(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : Ft(i), r = i.updateQueue, r !== null && qr(i, r.retryQueue), r = null, t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (r = t.memoizedState.cachePool.pool), h = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (h = i.memoizedState.cachePool.pool), h !== r && (i.flags |= 2048), t !== null && fe(Mh, i), null;
        case 24:
          return r = null, t !== null && (r = t.memoizedState.cache), i.memoizedState.cache !== r && (i.flags |= 2048), So(ai, i), Ft(i), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function nv(t, i) {
      switch (wr(i), i.tag) {
        case 1:
          return t = i.flags, t & 65536 ? (i.flags = t & -65537 | 128, (i.mode & Ri) !== on && Af(i), i) : null;
        case 3:
          return So(ai, i), F(i), t = i.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (i.flags = t & -65537 | 128, i) : null;
        case 26:
        case 27:
        case 5:
          return Se(i), null;
        case 13:
          if (Gi(i), t = i.memoizedState, t !== null && t.dehydrated !== null) {
            if (i.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            zu();
          }
          return t = i.flags, t & 65536 ? (i.flags = t & -65537 | 128, (i.mode & Ri) !== on && Af(i), i) : null;
        case 19:
          return fe(si, i), null;
        case 4:
          return F(i), null;
        case 10:
          return So(i.type, i), null;
        case 22:
        case 23:
          return Gi(i), zd(i), t !== null && fe(Mh, i), t = i.flags, t & 65536 ? (i.flags = t & -65537 | 128, (i.mode & Ri) !== on && Af(i), i) : null;
        case 24:
          return So(ai, i), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function Pg(t, i) {
      switch (wr(i), i.tag) {
        case 3:
          So(ai, i), F(i);
          break;
        case 26:
        case 27:
        case 5:
          Se(i);
          break;
        case 4:
          F(i);
          break;
        case 13:
          Gi(i);
          break;
        case 19:
          fe(si, i);
          break;
        case 10:
          So(i.type, i);
          break;
        case 22:
        case 23:
          Gi(i), zd(i), t !== null && fe(Mh, i);
          break;
        case 24:
          So(ai, i);
      }
    }
    function ca(t) {
      return (t.mode & Ri) !== on;
    }
    function Wg(t, i) {
      ca(t) ? (di(), ec(i, t), ta()) : ec(i, t);
    }
    function Zf(t, i, r) {
      ca(t) ? (di(), _r(
        r,
        t,
        i
      ), ta()) : _r(
        r,
        t,
        i
      );
    }
    function ec(t, i) {
      try {
        var r = i.updateQueue, h = r !== null ? r.lastEffect : null;
        if (h !== null) {
          var g = h.next;
          r = g;
          do {
            if ((r.tag & t) === t && ((t & oi) !== eo ? ke !== null && typeof ke.markComponentPassiveEffectMountStarted == "function" && ke.markComponentPassiveEffectMountStarted(
              i
            ) : (t & ki) !== eo && ke !== null && typeof ke.markComponentLayoutEffectMountStarted == "function" && ke.markComponentLayoutEffectMountStarted(
              i
            ), h = void 0, (t & Sl) !== eo && (Om = !0), h = Ge(
              i,
              Jz,
              r
            ), (t & Sl) !== eo && (Om = !1), (t & oi) !== eo ? ke !== null && typeof ke.markComponentPassiveEffectMountStopped == "function" && ke.markComponentPassiveEffectMountStopped() : (t & ki) !== eo && ke !== null && typeof ke.markComponentLayoutEffectMountStopped == "function" && ke.markComponentLayoutEffectMountStopped(), h !== void 0 && typeof h != "function")) {
              var O = void 0;
              O = (r.tag & ki) !== 0 ? "useLayoutEffect" : (r.tag & Sl) !== 0 ? "useInsertionEffect" : "useEffect";
              var x = void 0;
              x = h === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof h.then == "function" ? `

It looks like you wrote ` + O + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + O + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + h, Ge(
                i,
                function(R, Q) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    R,
                    Q
                  );
                },
                O,
                x
              );
            }
            r = r.next;
          } while (r !== g);
        }
      } catch (R) {
        Vt(i, i.return, R);
      }
    }
    function _r(t, i, r) {
      try {
        var h = i.updateQueue, g = h !== null ? h.lastEffect : null;
        if (g !== null) {
          var O = g.next;
          h = O;
          do {
            if ((h.tag & t) === t) {
              var x = h.inst, R = x.destroy;
              R !== void 0 && (x.destroy = void 0, (t & oi) !== eo ? ke !== null && typeof ke.markComponentPassiveEffectUnmountStarted == "function" && ke.markComponentPassiveEffectUnmountStarted(
                i
              ) : (t & ki) !== eo && ke !== null && typeof ke.markComponentLayoutEffectUnmountStarted == "function" && ke.markComponentLayoutEffectUnmountStarted(
                i
              ), (t & Sl) !== eo && (Om = !0), g = i, Ge(
                g,
                Iz,
                g,
                r,
                R
              ), (t & Sl) !== eo && (Om = !1), (t & oi) !== eo ? ke !== null && typeof ke.markComponentPassiveEffectUnmountStopped == "function" && ke.markComponentPassiveEffectUnmountStopped() : (t & ki) !== eo && ke !== null && typeof ke.markComponentLayoutEffectUnmountStopped == "function" && ke.markComponentLayoutEffectUnmountStopped());
            }
            h = h.next;
          } while (h !== O);
        }
      } catch (Q) {
        Vt(i, i.return, Q);
      }
    }
    function Id(t, i) {
      ca(t) ? (di(), ec(i, t), ta()) : ec(i, t);
    }
    function ep(t, i, r) {
      ca(t) ? (di(), _r(
        r,
        t,
        i
      ), ta()) : _r(
        r,
        t,
        i
      );
    }
    function Fg(t) {
      var i = t.updateQueue;
      if (i !== null) {
        var r = t.stateNode;
        t.type.defaultProps || "ref" in t.memoizedProps || fm || (r.props !== t.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          Te(t) || "instance"
        ), r.state !== t.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          Te(t) || "instance"
        ));
        try {
          Ge(
            t,
            Hi,
            i,
            r
          );
        } catch (h) {
          Vt(t, t.return, h);
        }
      }
    }
    function fS(t, i, r) {
      return t.getSnapshotBeforeUpdate(i, r);
    }
    function Kg(t, i) {
      var r = i.memoizedProps, h = i.memoizedState;
      i = t.stateNode, t.type.defaultProps || "ref" in t.memoizedProps || fm || (i.props !== t.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        Te(t) || "instance"
      ), i.state !== t.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        Te(t) || "instance"
      ));
      try {
        var g = Ss(
          t.type,
          r,
          t.elementType === t.type
        ), O = Ge(
          t,
          fS,
          i,
          g,
          h
        );
        r = eE, O !== void 0 || r.has(t.type) || (r.add(t.type), Ge(t, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            Te(t)
          );
        })), i.__reactInternalSnapshotBeforeUpdate = O;
      } catch (x) {
        Vt(t, t.return, x);
      }
    }
    function Jg(t, i, r) {
      r.props = Ss(
        t.type,
        t.memoizedProps
      ), r.state = t.memoizedState, ca(t) ? (di(), Ge(
        t,
        Cw,
        t,
        i,
        r
      ), ta()) : Ge(
        t,
        Cw,
        t,
        i,
        r
      );
    }
    function iv(t) {
      var i = t.ref;
      if (i !== null) {
        switch (t.tag) {
          case 26:
          case 27:
          case 5:
            var r = t.stateNode;
            break;
          case 30:
            r = t.stateNode;
            break;
          default:
            r = t.stateNode;
        }
        if (typeof i == "function")
          if (ca(t))
            try {
              di(), t.refCleanup = i(r);
            } finally {
              ta();
            }
          else t.refCleanup = i(r);
        else
          typeof i == "string" ? console.error("String refs are no longer supported.") : i.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            Te(t)
          ), i.current = r;
      }
    }
    function Hr(t, i) {
      try {
        Ge(t, iv, t);
      } catch (r) {
        Vt(t, i, r);
      }
    }
    function fa(t, i) {
      var r = t.ref, h = t.refCleanup;
      if (r !== null)
        if (typeof h == "function")
          try {
            if (ca(t))
              try {
                di(), Ge(t, h);
              } finally {
                ta(t);
              }
            else Ge(t, h);
          } catch (g) {
            Vt(t, i, g);
          } finally {
            t.refCleanup = null, t = t.alternate, t != null && (t.refCleanup = null);
          }
        else if (typeof r == "function")
          try {
            if (ca(t))
              try {
                di(), Ge(t, r, null);
              } finally {
                ta(t);
              }
            else Ge(t, r, null);
          } catch (g) {
            Vt(t, i, g);
          }
        else r.current = null;
    }
    function Ig(t, i, r, h) {
      var g = t.memoizedProps, O = g.id, x = g.onCommit;
      g = g.onRender, i = i === null ? "mount" : "update", Pv && (i = "nested-update"), typeof g == "function" && g(
        O,
        i,
        t.actualDuration,
        t.treeBaseDuration,
        t.actualStartTime,
        r
      ), typeof x == "function" && x(
        t.memoizedProps.id,
        i,
        h,
        r
      );
    }
    function hS(t, i, r, h) {
      var g = t.memoizedProps;
      t = g.id, g = g.onPostCommit, i = i === null ? "mount" : "update", Pv && (i = "nested-update"), typeof g == "function" && g(
        t,
        i,
        h,
        r
      );
    }
    function lv(t) {
      var i = t.type, r = t.memoizedProps, h = t.stateNode;
      try {
        Ge(
          t,
          mn,
          h,
          i,
          r,
          t
        );
      } catch (g) {
        Vt(t, t.return, g);
      }
    }
    function tp(t, i, r) {
      try {
        Ge(
          t,
          Ds,
          t.stateNode,
          t.type,
          r,
          i,
          t
        );
      } catch (h) {
        Vt(t, t.return, h);
      }
    }
    function tc(t) {
      return t.tag === 5 || t.tag === 3 || t.tag === 26 || t.tag === 27 && Mn(t.type) || t.tag === 4;
    }
    function Pf(t) {
      e: for (; ; ) {
        for (; t.sibling === null; ) {
          if (t.return === null || tc(t.return)) return null;
          t = t.return;
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
          if (t.tag === 27 && Mn(t.type) || t.flags & 2 || t.child === null || t.tag === 4) continue e;
          t.child.return = t, t = t.child;
        }
        if (!(t.flags & 2)) return t.stateNode;
      }
    }
    function nc(t, i, r) {
      var h = t.tag;
      if (h === 5 || h === 6)
        t = t.stateNode, i ? (r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r).insertBefore(t, i) : (i = r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r, i.appendChild(t), r = r._reactRootContainer, r != null || i.onclick !== null || (i.onclick = Cs));
      else if (h !== 4 && (h === 27 && Mn(t.type) && (r = t.stateNode, i = null), t = t.child, t !== null))
        for (nc(t, i, r), t = t.sibling; t !== null; )
          nc(t, i, r), t = t.sibling;
    }
    function Wf(t, i, r) {
      var h = t.tag;
      if (h === 5 || h === 6)
        t = t.stateNode, i ? r.insertBefore(t, i) : r.appendChild(t);
      else if (h !== 4 && (h === 27 && Mn(t.type) && (r = t.stateNode), t = t.child, t !== null))
        for (Wf(t, i, r), t = t.sibling; t !== null; )
          Wf(t, i, r), t = t.sibling;
    }
    function av(t) {
      for (var i, r = t.return; r !== null; ) {
        if (tc(r)) {
          i = r;
          break;
        }
        r = r.return;
      }
      if (i == null)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (i.tag) {
        case 27:
          i = i.stateNode, r = Pf(t), Wf(
            t,
            r,
            i
          );
          break;
        case 5:
          r = i.stateNode, i.flags & 32 && (Ms(r), i.flags &= -33), i = Pf(t), Wf(
            t,
            i,
            r
          );
          break;
        case 3:
        case 4:
          i = i.stateNode.containerInfo, r = Pf(t), nc(
            t,
            r,
            i
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function Ff(t) {
      var i = t.stateNode, r = t.memoizedProps;
      try {
        Ge(
          t,
          bv,
          t.type,
          r,
          i,
          t
        );
      } catch (h) {
        Vt(t, t.return, h);
      }
    }
    function ov(t, i) {
      if (t = t.containerInfo, mT = Tb, t = ZO(t), cg(t)) {
        if ("selectionStart" in t)
          var r = {
            start: t.selectionStart,
            end: t.selectionEnd
          };
        else
          e: {
            r = (r = t.ownerDocument) && r.defaultView || window;
            var h = r.getSelection && r.getSelection();
            if (h && h.rangeCount !== 0) {
              r = h.anchorNode;
              var g = h.anchorOffset, O = h.focusNode;
              h = h.focusOffset;
              try {
                r.nodeType, O.nodeType;
              } catch {
                r = null;
                break e;
              }
              var x = 0, R = -1, Q = -1, N = 0, ee = 0, oe = t, J = null;
              t: for (; ; ) {
                for (var re; oe !== r || g !== 0 && oe.nodeType !== 3 || (R = x + g), oe !== O || h !== 0 && oe.nodeType !== 3 || (Q = x + h), oe.nodeType === 3 && (x += oe.nodeValue.length), (re = oe.firstChild) !== null; )
                  J = oe, oe = re;
                for (; ; ) {
                  if (oe === t) break t;
                  if (J === r && ++N === g && (R = x), J === O && ++ee === h && (Q = x), (re = oe.nextSibling) !== null) break;
                  oe = J, J = oe.parentNode;
                }
                oe = re;
              }
              r = R === -1 || Q === -1 ? null : { start: R, end: Q };
            } else r = null;
          }
        r = r || { start: 0, end: 0 };
      } else r = null;
      for (gT = {
        focusedElem: t,
        selectionRange: r
      }, Tb = !1, Oi = i; Oi !== null; )
        if (i = Oi, t = i.child, (i.subtreeFlags & 1024) !== 0 && t !== null)
          t.return = i, Oi = t;
        else
          for (; Oi !== null; ) {
            switch (t = i = Oi, r = t.alternate, g = t.flags, t.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                (g & 1024) !== 0 && r !== null && Kg(t, r);
                break;
              case 3:
                if ((g & 1024) !== 0) {
                  if (t = t.stateNode.containerInfo, r = t.nodeType, r === 9)
                    La(t);
                  else if (r === 1)
                    switch (t.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        La(t);
                        break;
                      default:
                        t.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((g & 1024) !== 0)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (t = i.sibling, t !== null) {
              t.return = i.return, Oi = t;
              break;
            }
            Oi = i.return;
          }
    }
    function e0(t, i, r) {
      var h = r.flags;
      switch (r.tag) {
        case 0:
        case 11:
        case 15:
          An(t, r), h & 4 && Wg(r, ki | to);
          break;
        case 1:
          if (An(t, r), h & 4)
            if (t = r.stateNode, i === null)
              r.type.defaultProps || "ref" in r.memoizedProps || fm || (t.props !== r.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Te(r) || "instance"
              ), t.state !== r.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Te(r) || "instance"
              )), ca(r) ? (di(), Ge(
                r,
                jS,
                r,
                t
              ), ta()) : Ge(
                r,
                jS,
                r,
                t
              );
            else {
              var g = Ss(
                r.type,
                i.memoizedProps
              );
              i = i.memoizedState, r.type.defaultProps || "ref" in r.memoizedProps || fm || (t.props !== r.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Te(r) || "instance"
              ), t.state !== r.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Te(r) || "instance"
              )), ca(r) ? (di(), Ge(
                r,
                Aw,
                r,
                t,
                g,
                i,
                t.__reactInternalSnapshotBeforeUpdate
              ), ta()) : Ge(
                r,
                Aw,
                r,
                t,
                g,
                i,
                t.__reactInternalSnapshotBeforeUpdate
              );
            }
          h & 64 && Fg(r), h & 512 && Hr(r, r.return);
          break;
        case 3:
          if (i = ul(), An(t, r), h & 64 && (h = r.updateQueue, h !== null)) {
            if (g = null, r.child !== null)
              switch (r.child.tag) {
                case 27:
                case 5:
                  g = r.child.stateNode;
                  break;
                case 1:
                  g = r.child.stateNode;
              }
            try {
              Ge(
                r,
                Hi,
                h,
                g
              );
            } catch (x) {
              Vt(r, r.return, x);
            }
          }
          t.effectDuration += Nu(i);
          break;
        case 27:
          i === null && h & 4 && Ff(r);
        case 26:
        case 5:
          An(t, r), i === null && h & 4 && lv(r), h & 512 && Hr(r, r.return);
          break;
        case 12:
          if (h & 4) {
            h = ul(), An(t, r), t = r.stateNode, t.effectDuration += Uu(h);
            try {
              Ge(
                r,
                Ig,
                r,
                i,
                Zv,
                t.effectDuration
              );
            } catch (x) {
              Vt(r, r.return, x);
            }
          } else An(t, r);
          break;
        case 13:
          An(t, r), h & 4 && Kf(t, r), h & 64 && (t = r.memoizedState, t !== null && (t = t.dehydrated, t !== null && (r = ws.bind(
            null,
            r
          ), pc(t, r))));
          break;
        case 22:
          if (h = r.memoizedState !== null || iu, !h) {
            i = i !== null && i.memoizedState !== null || Qn, g = iu;
            var O = Qn;
            iu = h, (Qn = i) && !O ? pi(
              t,
              r,
              (r.subtreeFlags & 8772) !== 0
            ) : An(t, r), iu = g, Qn = O;
          }
          break;
        case 30:
          break;
        default:
          An(t, r);
      }
    }
    function sv(t) {
      var i = t.alternate;
      i !== null && (t.alternate = null, sv(i)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (i = t.stateNode, i !== null && Kl(i)), t.stateNode = null, t._debugOwner = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
    }
    function Yi(t, i, r) {
      for (r = r.child; r !== null; )
        ic(
          t,
          i,
          r
        ), r = r.sibling;
    }
    function ic(t, i, r) {
      if (ii && typeof ii.onCommitFiberUnmount == "function")
        try {
          ii.onCommitFiberUnmount(Fr, r);
        } catch (O) {
          bn || (bn = !0, console.error(
            "React instrumentation encountered an error: %s",
            O
          ));
        }
      switch (r.tag) {
        case 26:
          Qn || fa(r, i), Yi(
            t,
            i,
            r
          ), r.memoizedState ? r.memoizedState.count-- : r.stateNode && (r = r.stateNode, r.parentNode.removeChild(r));
          break;
        case 27:
          Qn || fa(r, i);
          var h = Yn, g = Xl;
          Mn(r.type) && (Yn = r.stateNode, Xl = !1), Yi(
            t,
            i,
            r
          ), Ge(
            r,
            gc,
            r.stateNode
          ), Yn = h, Xl = g;
          break;
        case 5:
          Qn || fa(r, i);
        case 6:
          if (h = Yn, g = Xl, Yn = null, Yi(
            t,
            i,
            r
          ), Yn = h, Xl = g, Yn !== null)
            if (Xl)
              try {
                Ge(
                  r,
                  lh,
                  Yn,
                  r.stateNode
                );
              } catch (O) {
                Vt(
                  r,
                  i,
                  O
                );
              }
            else
              try {
                Ge(
                  r,
                  dc,
                  Yn,
                  r.stateNode
                );
              } catch (O) {
                Vt(
                  r,
                  i,
                  O
                );
              }
          break;
        case 18:
          Yn !== null && (Xl ? (t = Yn, Ci(
            t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t,
            r.stateNode
          ), Sc(t)) : Ci(Yn, r.stateNode));
          break;
        case 4:
          h = Yn, g = Xl, Yn = r.stateNode.containerInfo, Xl = !0, Yi(
            t,
            i,
            r
          ), Yn = h, Xl = g;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Qn || _r(
            Sl,
            r,
            i
          ), Qn || Zf(
            r,
            i,
            ki
          ), Yi(
            t,
            i,
            r
          );
          break;
        case 1:
          Qn || (fa(r, i), h = r.stateNode, typeof h.componentWillUnmount == "function" && Jg(
            r,
            i,
            h
          )), Yi(
            t,
            i,
            r
          );
          break;
        case 21:
          Yi(
            t,
            i,
            r
          );
          break;
        case 22:
          Qn = (h = Qn) || r.memoizedState !== null, Yi(
            t,
            i,
            r
          ), Qn = h;
          break;
        default:
          Yi(
            t,
            i,
            r
          );
      }
    }
    function Kf(t, i) {
      if (i.memoizedState === null && (t = i.alternate, t !== null && (t = t.memoizedState, t !== null && (t = t.dehydrated, t !== null))))
        try {
          Ge(
            i,
            vv,
            t
          );
        } catch (r) {
          Vt(i, i.return, r);
        }
    }
    function Jf(t) {
      switch (t.tag) {
        case 13:
        case 19:
          var i = t.stateNode;
          return i === null && (i = t.stateNode = new tE()), i;
        case 22:
          return t = t.stateNode, i = t._retryCache, i === null && (i = t._retryCache = new tE()), i;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + t.tag + "). This is a bug in React."
          );
      }
    }
    function lc(t, i) {
      var r = Jf(t);
      i.forEach(function(h) {
        var g = dv.bind(null, t, h);
        if (!r.has(h)) {
          if (r.add(h), Ll)
            if (hm !== null && dm !== null)
              jr(dm, hm);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          h.then(g, g);
        }
      });
    }
    function $i(t, i) {
      var r = i.deletions;
      if (r !== null)
        for (var h = 0; h < r.length; h++) {
          var g = t, O = i, x = r[h], R = O;
          e: for (; R !== null; ) {
            switch (R.tag) {
              case 27:
                if (Mn(R.type)) {
                  Yn = R.stateNode, Xl = !1;
                  break e;
                }
                break;
              case 5:
                Yn = R.stateNode, Xl = !1;
                break e;
              case 3:
              case 4:
                Yn = R.stateNode.containerInfo, Xl = !0;
                break e;
            }
            R = R.return;
          }
          if (Yn === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          ic(g, O, x), Yn = null, Xl = !1, g = x, O = g.alternate, O !== null && (O.return = null), g.return = null;
        }
      if (i.subtreeFlags & 13878)
        for (i = i.child; i !== null; )
          t0(i, t), i = i.sibling;
    }
    function t0(t, i) {
      var r = t.alternate, h = t.flags;
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          $i(i, t), _n(t), h & 4 && (_r(
            Sl | to,
            t,
            t.return
          ), ec(Sl | to, t), Zf(
            t,
            t.return,
            ki | to
          ));
          break;
        case 1:
          $i(i, t), _n(t), h & 512 && (Qn || r === null || fa(r, r.return)), h & 64 && iu && (t = t.updateQueue, t !== null && (h = t.callbacks, h !== null && (r = t.shared.hiddenCallbacks, t.shared.hiddenCallbacks = r === null ? h : r.concat(h))));
          break;
        case 26:
          var g = Io;
          if ($i(i, t), _n(t), h & 512 && (Qn || r === null || fa(r, r.return)), h & 4)
            if (i = r !== null ? r.memoizedState : null, h = t.memoizedState, r === null)
              if (h === null)
                if (t.stateNode === null) {
                  e: {
                    h = t.type, r = t.memoizedProps, i = g.ownerDocument || g;
                    t: switch (h) {
                      case "title":
                        g = i.getElementsByTagName("title")[0], (!g || g[yh] || g[gi] || g.namespaceURI === Wo || g.hasAttribute("itemprop")) && (g = i.createElement(h), i.head.insertBefore(
                          g,
                          i.querySelector("head > title")
                        )), Ln(g, h, r), g[gi] = t, Y(g), h = g;
                        break e;
                      case "link":
                        var O = N0(
                          "link",
                          "href",
                          i
                        ).get(h + (r.href || ""));
                        if (O) {
                          for (var x = 0; x < O.length; x++)
                            if (g = O[x], g.getAttribute("href") === (r.href == null || r.href === "" ? null : r.href) && g.getAttribute("rel") === (r.rel == null ? null : r.rel) && g.getAttribute("title") === (r.title == null ? null : r.title) && g.getAttribute("crossorigin") === (r.crossOrigin == null ? null : r.crossOrigin)) {
                              O.splice(x, 1);
                              break t;
                            }
                        }
                        g = i.createElement(h), Ln(g, h, r), i.head.appendChild(g);
                        break;
                      case "meta":
                        if (O = N0(
                          "meta",
                          "content",
                          i
                        ).get(h + (r.content || ""))) {
                          for (x = 0; x < O.length; x++)
                            if (g = O[x], le(
                              r.content,
                              "content"
                            ), g.getAttribute("content") === (r.content == null ? null : "" + r.content) && g.getAttribute("name") === (r.name == null ? null : r.name) && g.getAttribute("property") === (r.property == null ? null : r.property) && g.getAttribute("http-equiv") === (r.httpEquiv == null ? null : r.httpEquiv) && g.getAttribute("charset") === (r.charSet == null ? null : r.charSet)) {
                              O.splice(x, 1);
                              break t;
                            }
                        }
                        g = i.createElement(h), Ln(g, h, r), i.head.appendChild(g);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + h + '". This is a bug in React.'
                        );
                    }
                    g[gi] = t, Y(g), h = g;
                  }
                  t.stateNode = h;
                } else
                  Zr(
                    g,
                    t.type,
                    t.stateNode
                  );
              else
                t.stateNode = Tv(
                  g,
                  h,
                  t.memoizedProps
                );
            else
              i !== h ? (i === null ? r.stateNode !== null && (r = r.stateNode, r.parentNode.removeChild(r)) : i.count--, h === null ? Zr(
                g,
                t.type,
                t.stateNode
              ) : Tv(
                g,
                h,
                t.memoizedProps
              )) : h === null && t.stateNode !== null && tp(
                t,
                t.memoizedProps,
                r.memoizedProps
              );
          break;
        case 27:
          $i(i, t), _n(t), h & 512 && (Qn || r === null || fa(r, r.return)), r !== null && h & 4 && tp(
            t,
            t.memoizedProps,
            r.memoizedProps
          );
          break;
        case 5:
          if ($i(i, t), _n(t), h & 512 && (Qn || r === null || fa(r, r.return)), t.flags & 32) {
            i = t.stateNode;
            try {
              Ge(t, Ms, i);
            } catch (ee) {
              Vt(t, t.return, ee);
            }
          }
          h & 4 && t.stateNode != null && (i = t.memoizedProps, tp(
            t,
            i,
            r !== null ? r.memoizedProps : i
          )), h & 1024 && (FS = !0, t.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if ($i(i, t), _n(t), h & 4) {
            if (t.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            h = t.memoizedProps, r = r !== null ? r.memoizedProps : h, i = t.stateNode;
            try {
              Ge(
                t,
                R0,
                i,
                r,
                h
              );
            } catch (ee) {
              Vt(t, t.return, ee);
            }
          }
          break;
        case 3:
          if (g = ul(), vb = null, O = Io, Io = Op(i.containerInfo), $i(i, t), Io = O, _n(t), h & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
              Ge(
                t,
                gl,
                i.containerInfo
              );
            } catch (ee) {
              Vt(t, t.return, ee);
            }
          FS && (FS = !1, n0(t)), i.effectDuration += Nu(g);
          break;
        case 4:
          h = Io, Io = Op(
            t.stateNode.containerInfo
          ), $i(i, t), _n(t), Io = h;
          break;
        case 12:
          h = ul(), $i(i, t), _n(t), t.stateNode.effectDuration += Uu(h);
          break;
        case 13:
          $i(i, t), _n(t), t.child.flags & 8192 && t.memoizedState !== null != (r !== null && r.memoizedState !== null) && (nT = ni()), h & 4 && (h = t.updateQueue, h !== null && (t.updateQueue = null, lc(t, h)));
          break;
        case 22:
          g = t.memoizedState !== null;
          var R = r !== null && r.memoizedState !== null, Q = iu, N = Qn;
          if (iu = Q || g, Qn = N || R, $i(i, t), Qn = N, iu = Q, _n(t), h & 8192)
            e: for (i = t.stateNode, i._visibility = g ? i._visibility & -2 : i._visibility | kS, g && (r === null || R || iu || Qn || Zi(t)), r = null, i = t; ; ) {
              if (i.tag === 5 || i.tag === 26) {
                if (r === null) {
                  R = r = i;
                  try {
                    O = R.stateNode, g ? Ge(R, k0, O) : Ge(
                      R,
                      pp,
                      R.stateNode,
                      R.memoizedProps
                    );
                  } catch (ee) {
                    Vt(R, R.return, ee);
                  }
                }
              } else if (i.tag === 6) {
                if (r === null) {
                  R = i;
                  try {
                    x = R.stateNode, g ? Ge(R, D0, x) : Ge(
                      R,
                      mp,
                      x,
                      R.memoizedProps
                    );
                  } catch (ee) {
                    Vt(R, R.return, ee);
                  }
                }
              } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === t) && i.child !== null) {
                i.child.return = i, i = i.child;
                continue;
              }
              if (i === t) break e;
              for (; i.sibling === null; ) {
                if (i.return === null || i.return === t)
                  break e;
                r === i && (r = null), i = i.return;
              }
              r === i && (r = null), i.sibling.return = i.return, i = i.sibling;
            }
          h & 4 && (h = t.updateQueue, h !== null && (r = h.retryQueue, r !== null && (h.retryQueue = null, lc(t, r))));
          break;
        case 19:
          $i(i, t), _n(t), h & 4 && (h = t.updateQueue, h !== null && (t.updateQueue = null, lc(t, h)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          $i(i, t), _n(t);
      }
    }
    function _n(t) {
      var i = t.flags;
      if (i & 2) {
        try {
          Ge(t, av, t);
        } catch (r) {
          Vt(t, t.return, r);
        }
        t.flags &= -3;
      }
      i & 4096 && (t.flags &= -4097);
    }
    function n0(t) {
      if (t.subtreeFlags & 1024)
        for (t = t.child; t !== null; ) {
          var i = t;
          n0(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), t = t.sibling;
        }
    }
    function An(t, i) {
      if (i.subtreeFlags & 8772)
        for (i = i.child; i !== null; )
          e0(t, i.alternate, i), i = i.sibling;
    }
    function ha(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Zf(
            t,
            t.return,
            ki
          ), Zi(t);
          break;
        case 1:
          fa(t, t.return);
          var i = t.stateNode;
          typeof i.componentWillUnmount == "function" && Jg(
            t,
            t.return,
            i
          ), Zi(t);
          break;
        case 27:
          Ge(
            t,
            gc,
            t.stateNode
          );
        case 26:
        case 5:
          fa(t, t.return), Zi(t);
          break;
        case 22:
          t.memoizedState === null && Zi(t);
          break;
        case 30:
          Zi(t);
          break;
        default:
          Zi(t);
      }
    }
    function Zi(t) {
      for (t = t.child; t !== null; )
        ha(t), t = t.sibling;
    }
    function i0(t, i, r, h) {
      var g = r.flags;
      switch (r.tag) {
        case 0:
        case 11:
        case 15:
          pi(
            t,
            r,
            h
          ), Wg(r, ki);
          break;
        case 1:
          if (pi(
            t,
            r,
            h
          ), i = r.stateNode, typeof i.componentDidMount == "function" && Ge(
            r,
            jS,
            r,
            i
          ), i = r.updateQueue, i !== null) {
            t = r.stateNode;
            try {
              Ge(
                r,
                cS,
                i,
                t
              );
            } catch (O) {
              Vt(r, r.return, O);
            }
          }
          h && g & 64 && Fg(r), Hr(r, r.return);
          break;
        case 27:
          Ff(r);
        case 26:
        case 5:
          pi(
            t,
            r,
            h
          ), h && i === null && g & 4 && lv(r), Hr(r, r.return);
          break;
        case 12:
          if (h && g & 4) {
            g = ul(), pi(
              t,
              r,
              h
            ), h = r.stateNode, h.effectDuration += Uu(g);
            try {
              Ge(
                r,
                Ig,
                r,
                i,
                Zv,
                h.effectDuration
              );
            } catch (O) {
              Vt(r, r.return, O);
            }
          } else
            pi(
              t,
              r,
              h
            );
          break;
        case 13:
          pi(
            t,
            r,
            h
          ), h && g & 4 && Kf(t, r);
          break;
        case 22:
          r.memoizedState === null && pi(
            t,
            r,
            h
          ), Hr(r, r.return);
          break;
        case 30:
          break;
        default:
          pi(
            t,
            r,
            h
          );
      }
    }
    function pi(t, i, r) {
      for (r = r && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; )
        i0(
          t,
          i.alternate,
          i,
          r
        ), i = i.sibling;
    }
    function da(t, i) {
      var r = null;
      t !== null && t.memoizedState !== null && t.memoizedState.cachePool !== null && (r = t.memoizedState.cachePool.pool), t = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (t = i.memoizedState.cachePool.pool), t !== r && (t != null && Ml(t), r != null && Rr(r));
    }
    function vn(t, i) {
      t = null, i.alternate !== null && (t = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== t && (Ml(i), t != null && Rr(t));
    }
    function hl(t, i, r, h) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; )
          np(
            t,
            i,
            r,
            h
          ), i = i.sibling;
    }
    function np(t, i, r, h) {
      var g = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          hl(
            t,
            i,
            r,
            h
          ), g & 2048 && Id(i, oi | to);
          break;
        case 1:
          hl(
            t,
            i,
            r,
            h
          );
          break;
        case 3:
          var O = ul();
          hl(
            t,
            i,
            r,
            h
          ), g & 2048 && (r = null, i.alternate !== null && (r = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== r && (Ml(i), r != null && Rr(r))), t.passiveEffectDuration += Nu(O);
          break;
        case 12:
          if (g & 2048) {
            g = ul(), hl(
              t,
              i,
              r,
              h
            ), t = i.stateNode, t.passiveEffectDuration += Uu(g);
            try {
              Ge(
                i,
                hS,
                i,
                i.alternate,
                Zv,
                t.passiveEffectDuration
              );
            } catch (R) {
              Vt(i, i.return, R);
            }
          } else
            hl(
              t,
              i,
              r,
              h
            );
          break;
        case 13:
          hl(
            t,
            i,
            r,
            h
          );
          break;
        case 23:
          break;
        case 22:
          O = i.stateNode;
          var x = i.alternate;
          i.memoizedState !== null ? O._visibility & Eh ? hl(
            t,
            i,
            r,
            h
          ) : ac(
            t,
            i
          ) : O._visibility & Eh ? hl(
            t,
            i,
            r,
            h
          ) : (O._visibility |= Eh, xs(
            t,
            i,
            r,
            h,
            (i.subtreeFlags & 10256) !== 0
          )), g & 2048 && da(x, i);
          break;
        case 24:
          hl(
            t,
            i,
            r,
            h
          ), g & 2048 && vn(i.alternate, i);
          break;
        default:
          hl(
            t,
            i,
            r,
            h
          );
      }
    }
    function xs(t, i, r, h, g) {
      for (g = g && (i.subtreeFlags & 10256) !== 0, i = i.child; i !== null; )
        l0(
          t,
          i,
          r,
          h,
          g
        ), i = i.sibling;
    }
    function l0(t, i, r, h, g) {
      var O = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          xs(
            t,
            i,
            r,
            h,
            g
          ), Id(i, oi);
          break;
        case 23:
          break;
        case 22:
          var x = i.stateNode;
          i.memoizedState !== null ? x._visibility & Eh ? xs(
            t,
            i,
            r,
            h,
            g
          ) : ac(
            t,
            i
          ) : (x._visibility |= Eh, xs(
            t,
            i,
            r,
            h,
            g
          )), g && O & 2048 && da(
            i.alternate,
            i
          );
          break;
        case 24:
          xs(
            t,
            i,
            r,
            h,
            g
          ), g && O & 2048 && vn(i.alternate, i);
          break;
        default:
          xs(
            t,
            i,
            r,
            h,
            g
          );
      }
    }
    function ac(t, i) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; ) {
          var r = t, h = i, g = h.flags;
          switch (h.tag) {
            case 22:
              ac(
                r,
                h
              ), g & 2048 && da(
                h.alternate,
                h
              );
              break;
            case 24:
              ac(
                r,
                h
              ), g & 2048 && vn(
                h.alternate,
                h
              );
              break;
            default:
              ac(
                r,
                h
              );
          }
          i = i.sibling;
        }
    }
    function Bl(t) {
      if (t.subtreeFlags & Ay)
        for (t = t.child; t !== null; )
          If(t), t = t.sibling;
    }
    function If(t) {
      switch (t.tag) {
        case 26:
          Bl(t), t.flags & Ay && t.memoizedState !== null && Av(
            Io,
            t.memoizedState,
            t.memoizedProps
          );
          break;
        case 5:
          Bl(t);
          break;
        case 3:
        case 4:
          var i = Io;
          Io = Op(
            t.stateNode.containerInfo
          ), Bl(t), Io = i;
          break;
        case 22:
          t.memoizedState === null && (i = t.alternate, i !== null && i.memoizedState !== null ? (i = Ay, Ay = 16777216, Bl(t), Ay = i) : Bl(t));
          break;
        default:
          Bl(t);
      }
    }
    function a0(t) {
      var i = t.alternate;
      if (i !== null && (t = i.child, t !== null)) {
        i.child = null;
        do
          i = t.sibling, t.sibling = null, t = i;
        while (t !== null);
      }
    }
    function oc(t) {
      var i = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (i !== null)
          for (var r = 0; r < i.length; r++) {
            var h = i[r];
            Oi = h, ip(
              h,
              t
            );
          }
        a0(t);
      }
      if (t.subtreeFlags & 10256)
        for (t = t.child; t !== null; )
          o0(t), t = t.sibling;
    }
    function o0(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          oc(t), t.flags & 2048 && ep(
            t,
            t.return,
            oi | to
          );
          break;
        case 3:
          var i = ul();
          oc(t), t.stateNode.passiveEffectDuration += Nu(i);
          break;
        case 12:
          i = ul(), oc(t), t.stateNode.passiveEffectDuration += Uu(i);
          break;
        case 22:
          i = t.stateNode, t.memoizedState !== null && i._visibility & Eh && (t.return === null || t.return.tag !== 13) ? (i._visibility &= -3, Lr(t)) : oc(t);
          break;
        default:
          oc(t);
      }
    }
    function Lr(t) {
      var i = t.deletions;
      if ((t.flags & 16) !== 0) {
        if (i !== null)
          for (var r = 0; r < i.length; r++) {
            var h = i[r];
            Oi = h, ip(
              h,
              t
            );
          }
        a0(t);
      }
      for (t = t.child; t !== null; )
        s0(t), t = t.sibling;
    }
    function s0(t) {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          ep(
            t,
            t.return,
            oi
          ), Lr(t);
          break;
        case 22:
          var i = t.stateNode;
          i._visibility & Eh && (i._visibility &= -3, Lr(t));
          break;
        default:
          Lr(t);
      }
    }
    function ip(t, i) {
      for (; Oi !== null; ) {
        var r = Oi, h = r;
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            ep(
              h,
              i,
              oi
            );
            break;
          case 23:
          case 22:
            h.memoizedState !== null && h.memoizedState.cachePool !== null && (h = h.memoizedState.cachePool.pool, h != null && Ml(h));
            break;
          case 24:
            Rr(h.memoizedState.cache);
        }
        if (h = r.child, h !== null) h.return = r, Oi = h;
        else
          e: for (r = t; Oi !== null; ) {
            h = Oi;
            var g = h.sibling, O = h.return;
            if (sv(h), h === r) {
              Oi = null;
              break e;
            }
            if (g !== null) {
              g.return = O, Oi = g;
              break e;
            }
            Oi = O;
          }
      }
    }
    function rv() {
      t3.forEach(function(t) {
        return t();
      });
    }
    function r0() {
      var t = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return t || I.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), t;
    }
    function dl(t) {
      if ((Ht & Tl) !== xa && vt !== 0)
        return vt & -vt;
      var i = I.T;
      return i !== null ? (i._updatedFibers || (i._updatedFibers = /* @__PURE__ */ new Set()), i._updatedFibers.add(t), t = Dh, t !== 0 ? t : hp()) : sf();
    }
    function u0() {
      wa === 0 && (wa = (vt & 536870912) === 0 || Rt ? lt() : 536870912);
      var t = io.current;
      return t !== null && (t.flags |= 32), wa;
    }
    function mt(t, i, r) {
      if (Om && console.error("useInsertionEffect must not schedule updates."), sT && (sb = !0), (t === It && (Yt === Uh || Yt === Bh) || t.cancelPendingCommit !== null) && (No(t, 0), Qo(
        t,
        vt,
        wa,
        !1
      )), as(t, r), (Ht & Tl) !== 0 && t === It) {
        if (Ya)
          switch (i.tag) {
            case 0:
            case 11:
            case 15:
              t = Ot && Te(Ot) || "Unknown", fE.has(t) || (fE.add(t), i = Te(i) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                i,
                t,
                t
              ));
              break;
            case 1:
              cE || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), cE = !0);
          }
      } else
        Ll && Fn(t, i, r), b0(i), t === It && ((Ht & Tl) === xa && (Bc |= r), Cn === Nh && Qo(
          t,
          vt,
          wa,
          !1
        )), ql(t);
    }
    function Hn(t, i, r) {
      if ((Ht & (Tl | es)) !== xa)
        throw Error("Should not already be working.");
      var h = !r && (i & 124) === 0 && (i & t.expiredLanes) === 0 || mo(t, i), g = h ? d0(t, i) : eh(t, i, !0), O = h;
      do {
        if (g === lu) {
          gm && !h && Qo(t, i, 0, !1);
          break;
        } else {
          if (r = t.current.alternate, O && !uv(r)) {
            g = eh(t, i, !1), O = !1;
            continue;
          }
          if (g === pm) {
            if (O = i, t.errorRecoveryDisabledLanes & O)
              var x = 0;
            else
              x = t.pendingLanes & -536870913, x = x !== 0 ? x : x & 536870912 ? 536870912 : 0;
            if (x !== 0) {
              i = x;
              e: {
                g = t;
                var R = x;
                x = Dy;
                var Q = g.current.memoizedState.isDehydrated;
                if (Q && (No(
                  g,
                  R
                ).flags |= 256), R = eh(
                  g,
                  R,
                  !1
                ), R !== pm) {
                  if (eT && !Q) {
                    g.errorRecoveryDisabledLanes |= O, Bc |= O, g = Nh;
                    break e;
                  }
                  g = xl, xl = x, g !== null && (xl === null ? xl = g : xl.push.apply(
                    xl,
                    g
                  ));
                }
                g = R;
              }
              if (O = !1, g !== pm) continue;
            }
          }
          if (g === Ey) {
            No(t, 0), Qo(t, i, 0, !0);
            break;
          }
          e: {
            switch (h = t, g) {
              case lu:
              case Ey:
                throw Error("Root did not complete. This is a bug in React.");
              case Nh:
                if ((i & 4194048) !== i) break;
              case lb:
                Qo(
                  h,
                  i,
                  wa,
                  !Nc
                );
                break e;
              case pm:
                xl = null;
                break;
              case KS:
              case nE:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (I.actQueue !== null)
              pa(
                h,
                r,
                i,
                xl,
                My,
                ab,
                wa,
                Bc,
                qh
              );
            else {
              if ((i & 62914560) === i && (O = nT + lE - ni(), 10 < O)) {
                if (Qo(
                  h,
                  i,
                  wa,
                  !Nc
                ), po(h, 0, !0) !== 0) break e;
                h.timeoutHandle = vE(
                  c0.bind(
                    null,
                    h,
                    r,
                    xl,
                    My,
                    ab,
                    i,
                    wa,
                    Bc,
                    qh,
                    Nc,
                    g,
                    a3,
                    ow,
                    0
                  ),
                  O
                );
                break e;
              }
              c0(
                h,
                r,
                xl,
                My,
                ab,
                i,
                wa,
                Bc,
                qh,
                Nc,
                g,
                i3,
                ow,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      ql(t);
    }
    function c0(t, i, r, h, g, O, x, R, Q, N, ee, oe, J, re) {
      if (t.timeoutHandle = Xh, oe = i.subtreeFlags, (oe & 8192 || (oe & 16785408) === 16785408) && (qy = { stylesheets: null, count: 0, unsuspend: xv }, If(i), oe = wv(), oe !== null)) {
        t.cancelPendingCommit = oe(
          pa.bind(
            null,
            t,
            i,
            O,
            r,
            h,
            g,
            x,
            R,
            Q,
            ee,
            l3,
            J,
            re
          )
        ), Qo(
          t,
          O,
          x,
          !N
        );
        return;
      }
      pa(
        t,
        i,
        O,
        r,
        h,
        g,
        x,
        R,
        Q
      );
    }
    function uv(t) {
      for (var i = t; ; ) {
        var r = i.tag;
        if ((r === 0 || r === 11 || r === 15) && i.flags & 16384 && (r = i.updateQueue, r !== null && (r = r.stores, r !== null)))
          for (var h = 0; h < r.length; h++) {
            var g = r[h], O = g.getSnapshot;
            g = g.value;
            try {
              if (!vl(O(), g)) return !1;
            } catch {
              return !1;
            }
          }
        if (r = i.child, i.subtreeFlags & 16384 && r !== null)
          r.return = i, i = r;
        else {
          if (i === t) break;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === t) return !0;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      }
      return !0;
    }
    function Qo(t, i, r, h) {
      i &= ~tT, i &= ~Bc, t.suspendedLanes |= i, t.pingedLanes &= ~i, h && (t.warmLanes |= i), h = t.expirationTimes;
      for (var g = i; 0 < g; ) {
        var O = 31 - Vn(g), x = 1 << O;
        h[O] = -1, g &= ~x;
      }
      r !== 0 && go(t, r, i);
    }
    function Vr() {
      return (Ht & (Tl | es)) === xa ? (Es(0), !1) : !0;
    }
    function lp() {
      if (Ot !== null) {
        if (Yt === jl)
          var t = Ot.return;
        else
          t = Ot, Ed(), oa(t), sm = null, Ty = 0, t = Ot;
        for (; t !== null; )
          Pg(t.alternate, t), t = t.return;
        Ot = null;
      }
    }
    function No(t, i) {
      var r = t.timeoutHandle;
      r !== Xh && (t.timeoutHandle = Xh, O3(r)), r = t.cancelPendingCommit, r !== null && (t.cancelPendingCommit = null, r()), lp(), It = t, Ot = r = Na(t.current, null), vt = i, Yt = jl, Aa = null, Nc = !1, gm = mo(t, i), eT = !1, Cn = lu, qh = wa = tT = Bc = Uc = 0, xl = Dy = null, ab = !1, (i & 8) !== 0 && (i |= i & 32);
      var h = t.entangledLanes;
      if (h !== 0)
        for (t = t.entanglements, h &= i; 0 < h; ) {
          var g = 31 - Vn(h), O = 1 << g;
          i |= t[g], h &= ~O;
        }
      return $s = i, Od(), i = lw(), 1e3 < i - iw && (I.recentlyCreatedOwnerStacks = 0, iw = i), Ko.discardPendingWarnings(), r;
    }
    function ap(t, i) {
      et = null, I.H = nb, I.getCurrentStack = null, Ya = !1, li = null, i === Oy || i === Kv ? (i = cl(), Yt = Ry) : i === uw ? (i = cl(), Yt = iE) : Yt = i === Zw ? IS : i !== null && typeof i == "object" && typeof i.then == "function" ? mm : Cy, Aa = i;
      var r = Ot;
      if (r === null)
        Cn = Ey, Iu(
          t,
          Bi(i, t.current)
        );
      else
        switch (r.mode & Ri && ds(r), Ti(), Yt) {
          case Cy:
            ke !== null && typeof ke.markComponentErrored == "function" && ke.markComponentErrored(
              r,
              i,
              vt
            );
            break;
          case Uh:
          case Bh:
          case Ry:
          case mm:
          case ky:
            ke !== null && typeof ke.markComponentSuspended == "function" && ke.markComponentSuspended(
              r,
              i,
              vt
            );
        }
    }
    function f0() {
      var t = I.H;
      return I.H = nb, t === null ? nb : t;
    }
    function h0() {
      var t = I.A;
      return I.A = e3, t;
    }
    function op() {
      Cn = Nh, Nc || (vt & 4194048) !== vt && io.current !== null || (gm = !0), (Uc & 134217727) === 0 && (Bc & 134217727) === 0 || It === null || Qo(
        It,
        vt,
        wa,
        !1
      );
    }
    function eh(t, i, r) {
      var h = Ht;
      Ht |= Tl;
      var g = f0(), O = h0();
      if (It !== t || vt !== i) {
        if (Ll) {
          var x = t.memoizedUpdaters;
          0 < x.size && (jr(t, vt), x.clear()), of(t, i);
        }
        My = null, No(t, i);
      }
      ho(i), i = !1, x = Cn;
      e: do
        try {
          if (Yt !== jl && Ot !== null) {
            var R = Ot, Q = Aa;
            switch (Yt) {
              case IS:
                lp(), x = lb;
                break e;
              case Ry:
              case Uh:
              case Bh:
              case mm:
                io.current === null && (i = !0);
                var N = Yt;
                if (Yt = jl, Aa = null, Xr(t, R, Q, N), r && gm) {
                  x = lu;
                  break e;
                }
                break;
              default:
                N = Yt, Yt = jl, Aa = null, Xr(t, R, Q, N);
            }
          }
          sp(), x = Cn;
          break;
        } catch (ee) {
          ap(t, ee);
        }
      while (!0);
      return i && t.shellSuspendCounter++, Ed(), Ht = h, I.H = g, I.A = O, cr(), Ot === null && (It = null, vt = 0, Od()), x;
    }
    function sp() {
      for (; Ot !== null; ) rp(Ot);
    }
    function d0(t, i) {
      var r = Ht;
      Ht |= Tl;
      var h = f0(), g = h0();
      if (It !== t || vt !== i) {
        if (Ll) {
          var O = t.memoizedUpdaters;
          0 < O.size && (jr(t, vt), O.clear()), of(t, i);
        }
        My = null, ob = ni() + aE, No(t, i);
      } else
        gm = mo(
          t,
          i
        );
      ho(i);
      e: do
        try {
          if (Yt !== jl && Ot !== null)
            t: switch (i = Ot, O = Aa, Yt) {
              case Cy:
                Yt = jl, Aa = null, Xr(
                  t,
                  i,
                  O,
                  Cy
                );
                break;
              case Uh:
              case Bh:
                if (Dd(O)) {
                  Yt = jl, Aa = null, th(i);
                  break;
                }
                i = function() {
                  Yt !== Uh && Yt !== Bh || It !== t || (Yt = ky), ql(t);
                }, O.then(i, i);
                break e;
              case Ry:
                Yt = ky;
                break e;
              case iE:
                Yt = JS;
                break e;
              case ky:
                Dd(O) ? (Yt = jl, Aa = null, th(i)) : (Yt = jl, Aa = null, Xr(
                  t,
                  i,
                  O,
                  ky
                ));
                break;
              case JS:
                var x = null;
                switch (Ot.tag) {
                  case 26:
                    x = Ot.memoizedState;
                  case 5:
                  case 27:
                    var R = Ot;
                    if (!x || U0(x)) {
                      Yt = jl, Aa = null;
                      var Q = R.sibling;
                      if (Q !== null) Ot = Q;
                      else {
                        var N = R.return;
                        N !== null ? (Ot = N, sc(N)) : Ot = null;
                      }
                      break t;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                Yt = jl, Aa = null, Xr(
                  t,
                  i,
                  O,
                  JS
                );
                break;
              case mm:
                Yt = jl, Aa = null, Xr(
                  t,
                  i,
                  O,
                  mm
                );
                break;
              case IS:
                lp(), Cn = lb;
                break e;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          I.actQueue !== null ? sp() : cv();
          break;
        } catch (ee) {
          ap(t, ee);
        }
      while (!0);
      return Ed(), I.H = h, I.A = g, Ht = r, Ot !== null ? (ke !== null && typeof ke.markRenderYielded == "function" && ke.markRenderYielded(), lu) : (cr(), It = null, vt = 0, Od(), Cn);
    }
    function cv() {
      for (; Ot !== null && !OS(); )
        rp(Ot);
    }
    function rp(t) {
      var i = t.alternate;
      (t.mode & Ri) !== on ? (xo(t), i = Ge(
        t,
        Ts,
        i,
        t,
        $s
      ), ds(t)) : i = Ge(
        t,
        Ts,
        i,
        t,
        $s
      ), t.memoizedProps = t.pendingProps, i === null ? sc(t) : Ot = i;
    }
    function th(t) {
      var i = Ge(t, p0, t);
      t.memoizedProps = t.pendingProps, i === null ? sc(t) : Ot = i;
    }
    function p0(t) {
      var i = t.alternate, r = (t.mode & Ri) !== on;
      switch (r && xo(t), t.tag) {
        case 15:
        case 0:
          i = _g(
            i,
            t,
            t.pendingProps,
            t.type,
            void 0,
            vt
          );
          break;
        case 11:
          i = _g(
            i,
            t,
            t.pendingProps,
            t.type.render,
            t.ref,
            vt
          );
          break;
        case 5:
          oa(t);
        default:
          Pg(i, t), t = Ot = dg(t, $s), i = Ts(i, t, $s);
      }
      return r && ds(t), i;
    }
    function Xr(t, i, r, h) {
      Ed(), oa(i), sm = null, Ty = 0;
      var g = i.return;
      try {
        if ($d(
          t,
          g,
          i,
          r,
          vt
        )) {
          Cn = Ey, Iu(
            t,
            Bi(r, t.current)
          ), Ot = null;
          return;
        }
      } catch (O) {
        if (g !== null) throw Ot = g, O;
        Cn = Ey, Iu(
          t,
          Bi(r, t.current)
        ), Ot = null;
        return;
      }
      i.flags & 32768 ? (Rt || h === Cy ? t = !0 : gm || (vt & 536870912) !== 0 ? t = !1 : (Nc = t = !0, (h === Uh || h === Bh || h === Ry || h === mm) && (h = io.current, h !== null && h.tag === 13 && (h.flags |= 16384))), m0(i, t)) : sc(i);
    }
    function sc(t) {
      var i = t;
      do {
        if ((i.flags & 32768) !== 0) {
          m0(
            i,
            Nc
          );
          return;
        }
        var r = i.alternate;
        if (t = i.return, xo(i), r = Ge(
          i,
          tv,
          r,
          i,
          $s
        ), (i.mode & Ri) !== on && Rd(i), r !== null) {
          Ot = r;
          return;
        }
        if (i = i.sibling, i !== null) {
          Ot = i;
          return;
        }
        Ot = i = t;
      } while (i !== null);
      Cn === lu && (Cn = nE);
    }
    function m0(t, i) {
      do {
        var r = nv(t.alternate, t);
        if (r !== null) {
          r.flags &= 32767, Ot = r;
          return;
        }
        if ((t.mode & Ri) !== on) {
          Rd(t), r = t.actualDuration;
          for (var h = t.child; h !== null; )
            r += h.actualDuration, h = h.sibling;
          t.actualDuration = r;
        }
        if (r = t.return, r !== null && (r.flags |= 32768, r.subtreeFlags = 0, r.deletions = null), !i && (t = t.sibling, t !== null)) {
          Ot = t;
          return;
        }
        Ot = t = r;
      } while (t !== null);
      Cn = lb, Ot = null;
    }
    function pa(t, i, r, h, g, O, x, R, Q) {
      t.cancelPendingCommit = null;
      do
        As();
      while (Di !== _h);
      if (Ko.flushLegacyContextWarning(), Ko.flushPendingUnsafeLifecycleWarnings(), (Ht & (Tl | es)) !== xa)
        throw Error("Should not already be working.");
      if (ke !== null && typeof ke.markCommitStarted == "function" && ke.markCommitStarted(r), i === null) Ut();
      else {
        if (r === 0 && console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        ), i === t.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        if (O = i.lanes | i.childLanes, O |= DS, od(
          t,
          r,
          O,
          x,
          R,
          Q
        ), t === It && (Ot = It = null, vt = 0), ym = i, _c = t, Hc = r, lT = O, aT = g, uE = h, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (t.callbackNode = null, t.callbackPriority = 0, pv(xc, function() {
          return rc(), null;
        })) : (t.callbackNode = null, t.callbackPriority = 0), Zv = nm(), h = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || h) {
          h = I.T, I.T = null, g = Mt.p, Mt.p = Ol, x = Ht, Ht |= es;
          try {
            ov(t, i, r);
          } finally {
            Ht = x, Mt.p = g, I.T = h;
          }
        }
        Di = oE, up(), fv(), g0();
      }
    }
    function up() {
      if (Di === oE) {
        Di = _h;
        var t = _c, i = ym, r = Hc, h = (i.flags & 13878) !== 0;
        if ((i.subtreeFlags & 13878) !== 0 || h) {
          h = I.T, I.T = null;
          var g = Mt.p;
          Mt.p = Ol;
          var O = Ht;
          Ht |= es;
          try {
            hm = r, dm = t, t0(i, t), dm = hm = null, r = gT;
            var x = ZO(t.containerInfo), R = r.focusedElem, Q = r.selectionRange;
            if (x !== R && R && R.ownerDocument && $O(
              R.ownerDocument.documentElement,
              R
            )) {
              if (Q !== null && cg(R)) {
                var N = Q.start, ee = Q.end;
                if (ee === void 0 && (ee = N), "selectionStart" in R)
                  R.selectionStart = N, R.selectionEnd = Math.min(
                    ee,
                    R.value.length
                  );
                else {
                  var oe = R.ownerDocument || document, J = oe && oe.defaultView || window;
                  if (J.getSelection) {
                    var re = J.getSelection(), He = R.textContent.length, Fe = Math.min(
                      Q.start,
                      He
                    ), en = Q.end === void 0 ? Fe : Math.min(Q.end, He);
                    !re.extend && Fe > en && (x = en, en = Fe, Fe = x);
                    var Tt = YO(
                      R,
                      Fe
                    ), _ = YO(
                      R,
                      en
                    );
                    if (Tt && _ && (re.rangeCount !== 1 || re.anchorNode !== Tt.node || re.anchorOffset !== Tt.offset || re.focusNode !== _.node || re.focusOffset !== _.offset)) {
                      var H = oe.createRange();
                      H.setStart(Tt.node, Tt.offset), re.removeAllRanges(), Fe > en ? (re.addRange(H), re.extend(_.node, _.offset)) : (H.setEnd(_.node, _.offset), re.addRange(H));
                    }
                  }
                }
              }
              for (oe = [], re = R; re = re.parentNode; )
                re.nodeType === 1 && oe.push({
                  element: re,
                  left: re.scrollLeft,
                  top: re.scrollTop
                });
              for (typeof R.focus == "function" && R.focus(), R = 0; R < oe.length; R++) {
                var X = oe[R];
                X.element.scrollLeft = X.left, X.element.scrollTop = X.top;
              }
            }
            Tb = !!mT, gT = mT = null;
          } finally {
            Ht = O, Mt.p = g, I.T = h;
          }
        }
        t.current = i, Di = sE;
      }
    }
    function fv() {
      if (Di === sE) {
        Di = _h;
        var t = _c, i = ym, r = Hc, h = (i.flags & 8772) !== 0;
        if ((i.subtreeFlags & 8772) !== 0 || h) {
          h = I.T, I.T = null;
          var g = Mt.p;
          Mt.p = Ol;
          var O = Ht;
          Ht |= es;
          try {
            ke !== null && typeof ke.markLayoutEffectsStarted == "function" && ke.markLayoutEffectsStarted(r), hm = r, dm = t, e0(
              t,
              i.alternate,
              i
            ), dm = hm = null, ke !== null && typeof ke.markLayoutEffectsStopped == "function" && ke.markLayoutEffectsStopped();
          } finally {
            Ht = O, Mt.p = g, I.T = h;
          }
        }
        Di = rE;
      }
    }
    function g0() {
      if (Di === o3 || Di === rE) {
        Di = _h, vS();
        var t = _c, i = ym, r = Hc, h = uE, g = (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0;
        g ? Di = iT : (Di = _h, ym = _c = null, y0(t, t.pendingLanes), Hh = 0, Qy = null);
        var O = t.pendingLanes;
        if (O === 0 && (qc = null), g || ma(t), g = bu(r), i = i.stateNode, ii && typeof ii.onCommitFiberRoot == "function")
          try {
            var x = (i.current.flags & 128) === 128;
            switch (g) {
              case Ol:
                var R = mh;
                break;
              case Ga:
                R = X0;
                break;
              case Zo:
                R = xc;
                break;
              case Bp:
                R = G0;
                break;
              default:
                R = xc;
            }
            ii.onCommitFiberRoot(
              Fr,
              i,
              R,
              x
            );
          } catch (oe) {
            bn || (bn = !0, console.error(
              "React instrumentation encountered an error: %s",
              oe
            ));
          }
        if (Ll && t.memoizedUpdaters.clear(), rv(), h !== null) {
          x = I.T, R = Mt.p, Mt.p = Ol, I.T = null;
          try {
            var Q = t.onRecoverableError;
            for (i = 0; i < h.length; i++) {
              var N = h[i], ee = Uo(N.stack);
              Ge(
                N.source,
                Q,
                N.value,
                ee
              );
            }
          } finally {
            I.T = x, Mt.p = R;
          }
        }
        (Hc & 3) !== 0 && As(), ql(t), O = t.pendingLanes, (r & 4194090) !== 0 && (O & 42) !== 0 ? (Wv = !0, t === oT ? zy++ : (zy = 0, oT = t)) : zy = 0, Es(0), Ut();
      }
    }
    function Uo(t) {
      return t = { componentStack: t }, Object.defineProperty(t, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), t;
    }
    function y0(t, i) {
      (t.pooledCacheLanes &= i) === 0 && (i = t.pooledCache, i != null && (t.pooledCache = null, Rr(i)));
    }
    function As(t) {
      return up(), fv(), g0(), rc();
    }
    function rc() {
      if (Di !== iT) return !1;
      var t = _c, i = lT;
      lT = 0;
      var r = bu(Hc), h = Zo > r ? Zo : r;
      r = I.T;
      var g = Mt.p;
      try {
        Mt.p = h, I.T = null, h = aT, aT = null;
        var O = _c, x = Hc;
        if (Di = _h, ym = _c = null, Hc = 0, (Ht & (Tl | es)) !== xa)
          throw Error("Cannot flush passive effects while already rendering.");
        sT = !0, sb = !1, ke !== null && typeof ke.markPassiveEffectsStarted == "function" && ke.markPassiveEffectsStarted(x);
        var R = Ht;
        if (Ht |= es, o0(O.current), np(
          O,
          O.current,
          x,
          h
        ), ke !== null && typeof ke.markPassiveEffectsStopped == "function" && ke.markPassiveEffectsStopped(), ma(O), Ht = R, Es(0, !1), sb ? O === Qy ? Hh++ : (Hh = 0, Qy = O) : Hh = 0, sb = sT = !1, ii && typeof ii.onPostCommitFiberRoot == "function")
          try {
            ii.onPostCommitFiberRoot(Fr, O);
          } catch (N) {
            bn || (bn = !0, console.error(
              "React instrumentation encountered an error: %s",
              N
            ));
          }
        var Q = O.current.stateNode;
        return Q.effectDuration = 0, Q.passiveEffectDuration = 0, !0;
      } finally {
        Mt.p = g, I.T = r, y0(t, i);
      }
    }
    function an(t, i, r) {
      i = Bi(r, i), i = dn(t.stateNode, i, 2), t = ia(t, i, 2), t !== null && (as(t, 2), ql(t));
    }
    function Vt(t, i, r) {
      if (Om = !1, t.tag === 3)
        an(t, t, r);
      else {
        for (; i !== null; ) {
          if (i.tag === 3) {
            an(
              i,
              t,
              r
            );
            return;
          }
          if (i.tag === 1) {
            var h = i.stateNode;
            if (typeof i.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (qc === null || !qc.has(h))) {
              t = Bi(r, t), r = Vf(2), h = ia(i, r, 2), h !== null && (Br(
                r,
                h,
                i,
                t
              ), as(h, 2), ql(h));
              return;
            }
          }
          i = i.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          r
        );
      }
    }
    function O0(t, i, r) {
      var h = t.pingCache;
      if (h === null) {
        h = t.pingCache = new n3();
        var g = /* @__PURE__ */ new Set();
        h.set(i, g);
      } else
        g = h.get(i), g === void 0 && (g = /* @__PURE__ */ new Set(), h.set(i, g));
      g.has(r) || (eT = !0, g.add(r), h = hv.bind(null, t, i, r), Ll && jr(t, r), i.then(h, h));
    }
    function hv(t, i, r) {
      var h = t.pingCache;
      h !== null && h.delete(i), t.pingedLanes |= t.suspendedLanes & r, t.warmLanes &= ~r, r0() && I.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), It === t && (vt & r) === r && (Cn === Nh || Cn === KS && (vt & 62914560) === vt && ni() - nT < lE ? (Ht & Tl) === xa && No(t, 0) : tT |= r, qh === vt && (qh = 0)), ql(t);
    }
    function uc(t, i) {
      i === 0 && (i = fr()), t = qi(t, i), t !== null && (as(t, i), ql(t));
    }
    function ws(t) {
      var i = t.memoizedState, r = 0;
      i !== null && (r = i.retryLane), uc(t, r);
    }
    function dv(t, i) {
      var r = 0;
      switch (t.tag) {
        case 13:
          var h = t.stateNode, g = t.memoizedState;
          g !== null && (r = g.retryLane);
          break;
        case 19:
          h = t.stateNode;
          break;
        case 22:
          h = t.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      h !== null && h.delete(i), uc(t, r);
    }
    function cp(t, i, r) {
      if ((i.subtreeFlags & 67117056) !== 0)
        for (i = i.child; i !== null; ) {
          var h = t, g = i, O = g.type === Pr;
          O = r || O, g.tag !== 22 ? g.flags & 67108864 ? O && Ge(
            g,
            cc,
            h,
            g,
            (g.mode & ew) === on
          ) : cp(
            h,
            g,
            O
          ) : g.memoizedState === null && (O && g.flags & 8192 ? Ge(
            g,
            cc,
            h,
            g
          ) : g.subtreeFlags & 67108864 && Ge(
            g,
            cp,
            h,
            g,
            O
          )), i = i.sibling;
        }
    }
    function cc(t, i) {
      var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      Ke(!0);
      try {
        ha(i), r && s0(i), i0(t, i.alternate, i, !1), r && l0(t, i, 0, null, !1, 0);
      } finally {
        Ke(!1);
      }
    }
    function ma(t) {
      var i = !0;
      t.current.mode & (tl | Fo) || (i = !1), cp(
        t,
        t.current,
        i
      );
    }
    function v0(t) {
      if ((Ht & Tl) === xa) {
        var i = t.tag;
        if (i === 3 || i === 1 || i === 0 || i === 11 || i === 14 || i === 15) {
          if (i = Te(t) || "ReactComponent", rb !== null) {
            if (rb.has(i)) return;
            rb.add(i);
          } else rb = /* @__PURE__ */ new Set([i]);
          Ge(t, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function jr(t, i) {
      Ll && t.memoizedUpdaters.forEach(function(r) {
        Fn(t, r, i);
      });
    }
    function pv(t, i) {
      var r = I.actQueue;
      return r !== null ? (r.push(i), u3) : V0(t, i);
    }
    function b0(t) {
      r0() && I.actQueue === null && Ge(t, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          Te(t)
        );
      });
    }
    function ql(t) {
      t !== vm && t.next === null && (vm === null ? ub = vm = t : vm = vm.next = t), cb = !0, I.actQueue !== null ? uT || (uT = !0, gv()) : rT || (rT = !0, gv());
    }
    function Es(t, i) {
      if (!cT && cb) {
        cT = !0;
        do
          for (var r = !1, h = ub; h !== null; ) {
            if (t !== 0) {
              var g = h.pendingLanes;
              if (g === 0) var O = 0;
              else {
                var x = h.suspendedLanes, R = h.pingedLanes;
                O = (1 << 31 - Vn(42 | t) + 1) - 1, O &= g & ~(x & ~R), O = O & 201326741 ? O & 201326741 | 1 : O ? O | 2 : 0;
              }
              O !== 0 && (r = !0, S0(h, O));
            } else
              O = vt, O = po(
                h,
                h === It ? O : 0,
                h.cancelPendingCommit !== null || h.timeoutHandle !== Xh
              ), (O & 3) === 0 || mo(h, O) || (r = !0, S0(h, O));
            h = h.next;
          }
        while (r);
        cT = !1;
      }
    }
    function mv() {
      ga();
    }
    function ga() {
      cb = uT = rT = !1;
      var t = 0;
      Lh !== 0 && (C0() && (t = Lh), Lh = 0);
      for (var i = ni(), r = null, h = ub; h !== null; ) {
        var g = h.next, O = pn(h, i);
        O === 0 ? (h.next = null, r === null ? ub = g : r.next = g, g === null && (vm = r)) : (r = h, (t !== 0 || (O & 3) !== 0) && (cb = !0)), h = g;
      }
      Es(t);
    }
    function pn(t, i) {
      for (var r = t.suspendedLanes, h = t.pingedLanes, g = t.expirationTimes, O = t.pendingLanes & -62914561; 0 < O; ) {
        var x = 31 - Vn(O), R = 1 << x, Q = g[x];
        Q === -1 ? ((R & r) === 0 || (R & h) !== 0) && (g[x] = ad(R, i)) : Q <= i && (t.expiredLanes |= R), O &= ~R;
      }
      if (i = It, r = vt, r = po(
        t,
        t === i ? r : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== Xh
      ), h = t.callbackNode, r === 0 || t === i && (Yt === Uh || Yt === Bh) || t.cancelPendingCommit !== null)
        return h !== null && wn(h), t.callbackNode = null, t.callbackPriority = 0;
      if ((r & 3) === 0 || mo(t, r)) {
        if (i = r & -r, i !== t.callbackPriority || I.actQueue !== null && h !== fT)
          wn(h);
        else return i;
        switch (bu(r)) {
          case Ol:
          case Ga:
            r = X0;
            break;
          case Zo:
            r = xc;
            break;
          case Bp:
            r = G0;
            break;
          default:
            r = xc;
        }
        return h = fp.bind(null, t), I.actQueue !== null ? (I.actQueue.push(h), r = fT) : r = V0(r, h), t.callbackPriority = i, t.callbackNode = r, i;
      }
      return h !== null && wn(h), t.callbackPriority = 2, t.callbackNode = null, 2;
    }
    function fp(t, i) {
      if (Wv = Pv = !1, Di !== _h && Di !== iT)
        return t.callbackNode = null, t.callbackPriority = 0, null;
      var r = t.callbackNode;
      if (As() && t.callbackNode !== r)
        return null;
      var h = vt;
      return h = po(
        t,
        t === It ? h : 0,
        t.cancelPendingCommit !== null || t.timeoutHandle !== Xh
      ), h === 0 ? null : (Hn(
        t,
        h,
        i
      ), pn(t, ni()), t.callbackNode != null && t.callbackNode === r ? fp.bind(null, t) : null);
    }
    function S0(t, i) {
      if (As()) return null;
      Pv = Wv, Wv = !1, Hn(t, i, !0);
    }
    function wn(t) {
      t !== fT && t !== null && zv(t);
    }
    function gv() {
      I.actQueue !== null && I.actQueue.push(function() {
        return ga(), null;
      }), v3(function() {
        (Ht & (Tl | es)) !== xa ? V0(
          mh,
          mv
        ) : ga();
      });
    }
    function hp() {
      return Lh === 0 && (Lh = lt()), Lh;
    }
    function T0(t) {
      return t == null || typeof t == "symbol" || typeof t == "boolean" ? null : typeof t == "function" ? t : (le(t, "action"), bo("" + t));
    }
    function Kt(t, i) {
      var r = i.ownerDocument.createElement("input");
      return r.name = i.name, r.value = i.value, t.id && r.setAttribute("form", t.id), i.parentNode.insertBefore(r, i), t = new FormData(t), r.parentNode.removeChild(r), t;
    }
    function Pi(t, i, r, h, g) {
      if (i === "submit" && r && r.stateNode === g) {
        var O = T0(
          (g[el] || null).action
        ), x = h.submitter;
        x && (i = (i = x[el] || null) ? T0(i.formAction) : x.getAttribute("formAction"), i !== null && (O = i, x = null));
        var R = new zt(
          "action",
          "action",
          null,
          h,
          g
        );
        t.push({
          event: R,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (h.defaultPrevented) {
                  if (Lh !== 0) {
                    var Q = x ? Kt(
                      g,
                      x
                    ) : new FormData(g), N = {
                      pending: !0,
                      data: Q,
                      method: g.method,
                      action: O
                    };
                    Object.freeze(N), Hd(
                      r,
                      N,
                      null,
                      Q
                    );
                  }
                } else
                  typeof O == "function" && (R.preventDefault(), Q = x ? Kt(
                    g,
                    x
                  ) : new FormData(g), N = {
                    pending: !0,
                    data: Q,
                    method: g.method,
                    action: O
                  }, Object.freeze(N), Hd(
                    r,
                    N,
                    O,
                    Q
                  ));
              },
              currentTarget: g
            }
          ]
        });
      }
    }
    function _l(t, i, r) {
      t.currentTarget = r;
      try {
        i(t);
      } catch (h) {
        $S(h);
      }
      t.currentTarget = null;
    }
    function x0(t, i) {
      i = (i & 4) !== 0;
      for (var r = 0; r < t.length; r++) {
        var h = t[r];
        e: {
          var g = void 0, O = h.event;
          if (h = h.listeners, i)
            for (var x = h.length - 1; 0 <= x; x--) {
              var R = h[x], Q = R.instance, N = R.currentTarget;
              if (R = R.listener, Q !== g && O.isPropagationStopped())
                break e;
              Q !== null ? Ge(
                Q,
                _l,
                O,
                R,
                N
              ) : _l(O, R, N), g = Q;
            }
          else
            for (x = 0; x < h.length; x++) {
              if (R = h[x], Q = R.instance, N = R.currentTarget, R = R.listener, Q !== g && O.isPropagationStopped())
                break e;
              Q !== null ? Ge(
                Q,
                _l,
                O,
                R,
                N
              ) : _l(O, R, N), g = Q;
            }
        }
      }
    }
    function gt(t, i) {
      hT.has(t) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        t
      );
      var r = i[qp];
      r === void 0 && (r = i[qp] = /* @__PURE__ */ new Set());
      var h = t + "__bubble";
      r.has(h) || (Wi(i, t, 2, !1), r.add(h));
    }
    function A0(t, i, r) {
      hT.has(t) && !i && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        t
      );
      var h = 0;
      i && (h |= 4), Wi(
        r,
        t,
        h,
        i
      );
    }
    function nh(t) {
      if (!t[fb]) {
        t[fb] = !0, Kr.forEach(function(r) {
          r !== "selectionchange" && (hT.has(r) || A0(r, !1, t), A0(r, !0, t));
        });
        var i = t.nodeType === 9 ? t : t.ownerDocument;
        i === null || i[fb] || (i[fb] = !0, A0("selectionchange", !1, i));
      }
    }
    function Wi(t, i, r, h) {
      switch (Us(i)) {
        case Ol:
          var g = wp;
          break;
        case Ga:
          g = vc;
          break;
        default:
          g = rh;
      }
      r = g.bind(
        null,
        i,
        r,
        t
      ), g = void 0, !ce || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (g = !0), h ? g !== void 0 ? t.addEventListener(i, r, {
        capture: !0,
        passive: g
      }) : t.addEventListener(i, r, !0) : g !== void 0 ? t.addEventListener(i, r, {
        passive: g
      }) : t.addEventListener(
        i,
        r,
        !1
      );
    }
    function pl(t, i, r, h, g) {
      var O = h;
      if ((i & 1) === 0 && (i & 2) === 0 && h !== null)
        e: for (; ; ) {
          if (h === null) return;
          var x = h.tag;
          if (x === 3 || x === 4) {
            var R = h.stateNode.containerInfo;
            if (R === g) break;
            if (x === 4)
              for (x = h.return; x !== null; ) {
                var Q = x.tag;
                if ((Q === 3 || Q === 4) && x.stateNode.containerInfo === g)
                  return;
                x = x.return;
              }
            for (; R !== null; ) {
              if (x = Kn(R), x === null) return;
              if (Q = x.tag, Q === 5 || Q === 6 || Q === 26 || Q === 27) {
                h = O = x;
                continue e;
              }
              R = R.parentNode;
            }
          }
          h = h.return;
        }
      ku(function() {
        var N = O, ee = Jl(r), oe = [];
        e: {
          var J = IA.get(t);
          if (J !== void 0) {
            var re = zt, He = t;
            switch (t) {
              case "keypress":
                if (vr(r) === 0) break e;
              case "keydown":
              case "keyup":
                re = Ez;
                break;
              case "focusin":
                He = "focus", re = Pa;
                break;
              case "focusout":
                He = "blur", re = Pa;
                break;
              case "beforeblur":
              case "afterblur":
                re = Pa;
                break;
              case "click":
                if (r.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                re = Ye;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                re = jn;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                re = kz;
                break;
              case WA:
              case FA:
              case KA:
                re = yz;
                break;
              case JA:
                re = Mz;
                break;
              case "scroll":
              case "scrollend":
                re = j;
                break;
              case "wheel":
                re = Qz;
                break;
              case "copy":
              case "cut":
              case "paste":
                re = vz;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                re = VA;
                break;
              case "toggle":
              case "beforetoggle":
                re = Uz;
            }
            var Fe = (i & 4) !== 0, en = !Fe && (t === "scroll" || t === "scrollend"), Tt = Fe ? J !== null ? J + "Capture" : null : J;
            Fe = [];
            for (var _ = N, H; _ !== null; ) {
              var X = _;
              if (H = X.stateNode, X = X.tag, X !== 5 && X !== 26 && X !== 27 || H === null || Tt === null || (X = kl(_, Tt), X != null && Fe.push(
                fc(
                  _,
                  X,
                  H
                )
              )), en) break;
              _ = _.return;
            }
            0 < Fe.length && (J = new re(
              J,
              He,
              null,
              r,
              ee
            ), oe.push({
              event: J,
              listeners: Fe
            }));
          }
        }
        if ((i & 7) === 0) {
          e: {
            if (J = t === "mouseover" || t === "pointerover", re = t === "mouseout" || t === "pointerout", J && r !== T && (He = r.relatedTarget || r.fromElement) && (Kn(He) || He[Ls]))
              break e;
            if ((re || J) && (J = ee.window === ee ? ee : (J = ee.ownerDocument) ? J.defaultView || J.parentWindow : window, re ? (He = r.relatedTarget || r.toElement, re = N, He = He ? Kn(He) : null, He !== null && (en = ie(He), Fe = He.tag, He !== en || Fe !== 5 && Fe !== 27 && Fe !== 6) && (He = null)) : (re = null, He = N), re !== He)) {
              if (Fe = Ye, X = "onMouseLeave", Tt = "onMouseEnter", _ = "mouse", (t === "pointerout" || t === "pointerover") && (Fe = VA, X = "onPointerLeave", Tt = "onPointerEnter", _ = "pointer"), en = re == null ? J : Cl(re), H = He == null ? J : Cl(He), J = new Fe(
                X,
                _ + "leave",
                re,
                r,
                ee
              ), J.target = en, J.relatedTarget = H, X = null, Kn(ee) === N && (Fe = new Fe(
                Tt,
                _ + "enter",
                He,
                r,
                ee
              ), Fe.target = H, Fe.relatedTarget = en, X = Fe), en = X, re && He)
                t: {
                  for (Fe = re, Tt = He, _ = 0, H = Fe; H; H = Gr(H))
                    _++;
                  for (H = 0, X = Tt; X; X = Gr(X))
                    H++;
                  for (; 0 < _ - H; )
                    Fe = Gr(Fe), _--;
                  for (; 0 < H - _; )
                    Tt = Gr(Tt), H--;
                  for (; _--; ) {
                    if (Fe === Tt || Tt !== null && Fe === Tt.alternate)
                      break t;
                    Fe = Gr(Fe), Tt = Gr(Tt);
                  }
                  Fe = null;
                }
              else Fe = null;
              re !== null && Bo(
                oe,
                J,
                re,
                Fe,
                !1
              ), He !== null && en !== null && Bo(
                oe,
                en,
                He,
                Fe,
                !0
              );
            }
          }
          e: {
            if (J = N ? Cl(N) : window, re = J.nodeName && J.nodeName.toLowerCase(), re === "select" || re === "input" && J.type === "file")
              var ue = XO;
            else if (md(J))
              if (ZA)
                ue = oS;
              else {
                ue = lS;
                var Ce = rg;
              }
            else
              re = J.nodeName, !re || re.toLowerCase() !== "input" || J.type !== "checkbox" && J.type !== "radio" ? N && yr(N.elementType) && (ue = XO) : ue = aS;
            if (ue && (ue = ue(t, N))) {
              Du(
                oe,
                ue,
                r,
                ee
              );
              break e;
            }
            Ce && Ce(t, J, N), t === "focusout" && N && J.type === "number" && N.memoizedProps.value != null && sd(J, "number", J.value);
          }
          switch (Ce = N ? Cl(N) : window, t) {
            case "focusin":
              (md(Ce) || Ce.contentEditable === "true") && (Pp = Ce, AS = N, cy = null);
              break;
            case "focusout":
              cy = AS = Pp = null;
              break;
            case "mousedown":
              wS = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              wS = !1, yd(
                oe,
                r,
                ee
              );
              break;
            case "selectionchange":
              if (Hz) break;
            case "keydown":
            case "keyup":
              yd(
                oe,
                r,
                ee
              );
          }
          var ot;
          if (xS)
            e: {
              switch (t) {
                case "compositionstart":
                  var Le = "onCompositionStart";
                  break e;
                case "compositionend":
                  Le = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  Le = "onCompositionUpdate";
                  break e;
              }
              Le = void 0;
            }
          else
            Zp ? us(t, r) && (Le = "onCompositionEnd") : t === "keydown" && r.keyCode === XA && (Le = "onCompositionStart");
          Le && (jA && r.locale !== "ko" && (Zp || Le !== "onCompositionStart" ? Le === "onCompositionEnd" && Zp && (ot = pd()) : (K = ee, te = "value" in K ? K.value : K.textContent, Zp = !0)), Ce = mi(
            N,
            Le
          ), 0 < Ce.length && (Le = new LA(
            Le,
            t,
            null,
            r,
            ee
          ), oe.push({
            event: Le,
            listeners: Ce
          }), ot ? Le.data = ot : (ot = yf(r), ot !== null && (Le.data = ot)))), (ot = qz ? Of(t, r) : iS(t, r)) && (Le = mi(
            N,
            "onBeforeInput"
          ), 0 < Le.length && (Ce = new Sz(
            "onBeforeInput",
            "beforeinput",
            null,
            r,
            ee
          ), oe.push({
            event: Ce,
            listeners: Le
          }), Ce.data = ot)), Pi(
            oe,
            t,
            N,
            r,
            ee
          );
        }
        x0(oe, i);
      });
    }
    function fc(t, i, r) {
      return {
        instance: t,
        listener: i,
        currentTarget: r
      };
    }
    function mi(t, i) {
      for (var r = i + "Capture", h = []; t !== null; ) {
        var g = t, O = g.stateNode;
        if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || O === null || (g = kl(t, r), g != null && h.unshift(
          fc(t, g, O)
        ), g = kl(t, i), g != null && h.push(
          fc(t, g, O)
        )), t.tag === 3) return h;
        t = t.return;
      }
      return [];
    }
    function Gr(t) {
      if (t === null) return null;
      do
        t = t.return;
      while (t && t.tag !== 5 && t.tag !== 27);
      return t || null;
    }
    function Bo(t, i, r, h, g) {
      for (var O = i._reactName, x = []; r !== null && r !== h; ) {
        var R = r, Q = R.alternate, N = R.stateNode;
        if (R = R.tag, Q !== null && Q === h) break;
        R !== 5 && R !== 26 && R !== 27 || N === null || (Q = N, g ? (N = kl(r, O), N != null && x.unshift(
          fc(r, N, Q)
        )) : g || (N = kl(r, O), N != null && x.push(
          fc(r, N, Q)
        ))), r = r.return;
      }
      x.length !== 0 && t.push({ event: i, listeners: x });
    }
    function qo(t, i) {
      HO(t, i), t !== "input" && t !== "textarea" && t !== "select" || i == null || i.value !== null || jv || (jv = !0, t === "select" && i.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        t
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        t
      ));
      var r = {
        registrationNameDependencies: Sa,
        possibleRegistrationNames: _p
      };
      yr(t) || typeof i.is == "string" || LO(t, i, r), i.contentEditable && !i.suppressContentEditableWarning && i.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function Jt(t, i, r, h) {
      i !== r && (r = _o(r), _o(i) !== r && (h[t] = i));
    }
    function w0(t, i, r) {
      i.forEach(function(h) {
        r[hc(h)] = h === "style" ? dp(t) : t.getAttribute(h);
      });
    }
    function Hl(t, i) {
      i === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        t,
        t,
        t
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        t,
        typeof i
      );
    }
    function ya(t, i) {
      return t = t.namespaceURI === Gp || t.namespaceURI === Wo ? t.ownerDocument.createElementNS(
        t.namespaceURI,
        t.tagName
      ) : t.ownerDocument.createElement(t.tagName), t.innerHTML = i, t.innerHTML;
    }
    function _o(t) {
      return L(t) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        B(t)
      ), se(t)), (typeof t == "string" ? t : "" + t).replace(c3, `
`).replace(f3, "");
    }
    function Yr(t, i) {
      return i = _o(i), _o(t) === i;
    }
    function Cs() {
    }
    function wt(t, i, r, h, g, O) {
      switch (r) {
        case "children":
          typeof h == "string" ? (Cu(h, i, !1), i === "body" || i === "textarea" && h === "" || df(t, h)) : (typeof h == "number" || typeof h == "bigint") && (Cu("" + h, i, !1), i !== "body" && df(t, "" + h));
          break;
        case "className":
          Je(t, "class", h);
          break;
        case "tabIndex":
          Je(t, "tabindex", h);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Je(t, r, h);
          break;
        case "style":
          hd(t, h, O);
          break;
        case "data":
          if (i !== "object") {
            Je(t, "data", h);
            break;
          }
        case "src":
        case "href":
          if (h === "" && (i !== "a" || r !== "href")) {
            console.error(
              r === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              r,
              r
            ), t.removeAttribute(r);
            break;
          }
          if (h == null || typeof h == "function" || typeof h == "symbol" || typeof h == "boolean") {
            t.removeAttribute(r);
            break;
          }
          le(h, r), h = bo("" + h), t.setAttribute(r, h);
          break;
        case "action":
        case "formAction":
          if (h != null && (i === "form" ? r === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof h == "function" && (g.encType == null && g.method == null || pb || (pb = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), g.target == null || db || (db = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : i === "input" || i === "button" ? r === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : i !== "input" || g.type === "submit" || g.type === "image" || hb ? i !== "button" || g.type == null || g.type === "submit" || hb ? typeof h == "function" && (g.name == null || pE || (pE = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), g.formEncType == null && g.formMethod == null || pb || (pb = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), g.formTarget == null || db || (db = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (hb = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (hb = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            r === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof h == "function") {
            t.setAttribute(
              r,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof O == "function" && (r === "formAction" ? (i !== "input" && wt(t, i, "name", g.name, g, null), wt(
              t,
              i,
              "formEncType",
              g.formEncType,
              g,
              null
            ), wt(
              t,
              i,
              "formMethod",
              g.formMethod,
              g,
              null
            ), wt(
              t,
              i,
              "formTarget",
              g.formTarget,
              g,
              null
            )) : (wt(
              t,
              i,
              "encType",
              g.encType,
              g,
              null
            ), wt(t, i, "method", g.method, g, null), wt(
              t,
              i,
              "target",
              g.target,
              g,
              null
            )));
          if (h == null || typeof h == "symbol" || typeof h == "boolean") {
            t.removeAttribute(r);
            break;
          }
          le(h, r), h = bo("" + h), t.setAttribute(r, h);
          break;
        case "onClick":
          h != null && (typeof h != "function" && Hl(r, h), t.onclick = Cs);
          break;
        case "onScroll":
          h != null && (typeof h != "function" && Hl(r, h), gt("scroll", t));
          break;
        case "onScrollEnd":
          h != null && (typeof h != "function" && Hl(r, h), gt("scrollend", t));
          break;
        case "dangerouslySetInnerHTML":
          if (h != null) {
            if (typeof h != "object" || !("__html" in h))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (r = h.__html, r != null) {
              if (g.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = r;
            }
          }
          break;
        case "multiple":
          t.multiple = h && typeof h != "function" && typeof h != "symbol";
          break;
        case "muted":
          t.muted = h && typeof h != "function" && typeof h != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (h == null || typeof h == "function" || typeof h == "boolean" || typeof h == "symbol") {
            t.removeAttribute("xlink:href");
            break;
          }
          le(h, r), r = bo("" + h), t.setAttributeNS(Vh, "xlink:href", r);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          h != null && typeof h != "function" && typeof h != "symbol" ? (le(h, r), t.setAttribute(r, "" + h)) : t.removeAttribute(r);
          break;
        case "inert":
          h !== "" || mb[r] || (mb[r] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            r
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          h && typeof h != "function" && typeof h != "symbol" ? t.setAttribute(r, "") : t.removeAttribute(r);
          break;
        case "capture":
        case "download":
          h === !0 ? t.setAttribute(r, "") : h !== !1 && h != null && typeof h != "function" && typeof h != "symbol" ? (le(h, r), t.setAttribute(r, h)) : t.removeAttribute(r);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          h != null && typeof h != "function" && typeof h != "symbol" && !isNaN(h) && 1 <= h ? (le(h, r), t.setAttribute(r, h)) : t.removeAttribute(r);
          break;
        case "rowSpan":
        case "start":
          h == null || typeof h == "function" || typeof h == "symbol" || isNaN(h) ? t.removeAttribute(r) : (le(h, r), t.setAttribute(r, h));
          break;
        case "popover":
          gt("beforetoggle", t), gt("toggle", t), St(t, "popover", h);
          break;
        case "xlinkActuate":
          Sn(
            t,
            Vh,
            "xlink:actuate",
            h
          );
          break;
        case "xlinkArcrole":
          Sn(
            t,
            Vh,
            "xlink:arcrole",
            h
          );
          break;
        case "xlinkRole":
          Sn(
            t,
            Vh,
            "xlink:role",
            h
          );
          break;
        case "xlinkShow":
          Sn(
            t,
            Vh,
            "xlink:show",
            h
          );
          break;
        case "xlinkTitle":
          Sn(
            t,
            Vh,
            "xlink:title",
            h
          );
          break;
        case "xlinkType":
          Sn(
            t,
            Vh,
            "xlink:type",
            h
          );
          break;
        case "xmlBase":
          Sn(
            t,
            dT,
            "xml:base",
            h
          );
          break;
        case "xmlLang":
          Sn(
            t,
            dT,
            "xml:lang",
            h
          );
          break;
        case "xmlSpace":
          Sn(
            t,
            dT,
            "xml:space",
            h
          );
          break;
        case "is":
          O != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), St(t, "is", h);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          mE || h == null || typeof h != "object" || (mE = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            h
          ));
        default:
          !(2 < r.length) || r[0] !== "o" && r[0] !== "O" || r[1] !== "n" && r[1] !== "N" ? (r = Or(r), St(t, r, h)) : Sa.hasOwnProperty(r) && h != null && typeof h != "function" && Hl(r, h);
      }
    }
    function Rs(t, i, r, h, g, O) {
      switch (r) {
        case "style":
          hd(t, h, O);
          break;
        case "dangerouslySetInnerHTML":
          if (h != null) {
            if (typeof h != "object" || !("__html" in h))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (r = h.__html, r != null) {
              if (g.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              t.innerHTML = r;
            }
          }
          break;
        case "children":
          typeof h == "string" ? df(t, h) : (typeof h == "number" || typeof h == "bigint") && df(t, "" + h);
          break;
        case "onScroll":
          h != null && (typeof h != "function" && Hl(r, h), gt("scroll", t));
          break;
        case "onScrollEnd":
          h != null && (typeof h != "function" && Hl(r, h), gt("scrollend", t));
          break;
        case "onClick":
          h != null && (typeof h != "function" && Hl(r, h), t.onclick = Cs);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (Sa.hasOwnProperty(r))
            h != null && typeof h != "function" && Hl(r, h);
          else
            e: {
              if (r[0] === "o" && r[1] === "n" && (g = r.endsWith("Capture"), i = r.slice(2, g ? r.length - 7 : void 0), O = t[el] || null, O = O != null ? O[r] : null, typeof O == "function" && t.removeEventListener(i, O, g), typeof h == "function")) {
                typeof O != "function" && O !== null && (r in t ? t[r] = null : t.hasAttribute(r) && t.removeAttribute(r)), t.addEventListener(i, h, g);
                break e;
              }
              r in t ? t[r] = h : h === !0 ? t.setAttribute(r, "") : St(t, r, h);
            }
      }
    }
    function Ln(t, i, r) {
      switch (qo(i, r), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          gt("error", t), gt("load", t);
          var h = !1, g = !1, O;
          for (O in r)
            if (r.hasOwnProperty(O)) {
              var x = r[O];
              if (x != null)
                switch (O) {
                  case "src":
                    h = !0;
                    break;
                  case "srcSet":
                    g = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    wt(t, i, O, x, r, null);
                }
            }
          g && wt(t, i, "srcSet", r.srcSet, r, null), h && wt(t, i, "src", r.src, r, null);
          return;
        case "input":
          _e("input", r), gt("invalid", t);
          var R = O = x = g = null, Q = null, N = null;
          for (h in r)
            if (r.hasOwnProperty(h)) {
              var ee = r[h];
              if (ee != null)
                switch (h) {
                  case "name":
                    g = ee;
                    break;
                  case "type":
                    x = ee;
                    break;
                  case "checked":
                    Q = ee;
                    break;
                  case "defaultChecked":
                    N = ee;
                    break;
                  case "value":
                    O = ee;
                    break;
                  case "defaultValue":
                    R = ee;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (ee != null)
                      throw Error(
                        i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    wt(t, i, h, ee, r, null);
                }
            }
          pr(t, r), Jm(
            t,
            O,
            R,
            Q,
            N,
            x,
            g,
            !1
          ), On(t);
          return;
        case "select":
          _e("select", r), gt("invalid", t), h = x = O = null;
          for (g in r)
            if (r.hasOwnProperty(g) && (R = r[g], R != null))
              switch (g) {
                case "value":
                  O = R;
                  break;
                case "defaultValue":
                  x = R;
                  break;
                case "multiple":
                  h = R;
                default:
                  wt(
                    t,
                    i,
                    g,
                    R,
                    r,
                    null
                  );
              }
          Qa(t, r), i = O, r = x, t.multiple = !!h, i != null ? Oo(t, !!h, i, !1) : r != null && Oo(t, !!h, r, !0);
          return;
        case "textarea":
          _e("textarea", r), gt("invalid", t), O = g = h = null;
          for (x in r)
            if (r.hasOwnProperty(x) && (R = r[x], R != null))
              switch (x) {
                case "value":
                  h = R;
                  break;
                case "defaultValue":
                  g = R;
                  break;
                case "children":
                  O = R;
                  break;
                case "dangerouslySetInnerHTML":
                  if (R != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  wt(
                    t,
                    i,
                    x,
                    R,
                    r,
                    null
                  );
              }
          rd(t, r), mr(t, h, g, O), On(t);
          return;
        case "option":
          _O(t, r);
          for (Q in r)
            if (r.hasOwnProperty(Q) && (h = r[Q], h != null))
              switch (Q) {
                case "selected":
                  t.selected = h && typeof h != "function" && typeof h != "symbol";
                  break;
                default:
                  wt(t, i, Q, h, r, null);
              }
          return;
        case "dialog":
          gt("beforetoggle", t), gt("toggle", t), gt("cancel", t), gt("close", t);
          break;
        case "iframe":
        case "object":
          gt("load", t);
          break;
        case "video":
        case "audio":
          for (h = 0; h < Ny.length; h++)
            gt(Ny[h], t);
          break;
        case "image":
          gt("error", t), gt("load", t);
          break;
        case "details":
          gt("toggle", t);
          break;
        case "embed":
        case "source":
        case "link":
          gt("error", t), gt("load", t);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (N in r)
            if (r.hasOwnProperty(N) && (h = r[N], h != null))
              switch (N) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  wt(t, i, N, h, r, null);
              }
          return;
        default:
          if (yr(i)) {
            for (ee in r)
              r.hasOwnProperty(ee) && (h = r[ee], h !== void 0 && Rs(
                t,
                i,
                ee,
                h,
                r,
                void 0
              ));
            return;
          }
      }
      for (R in r)
        r.hasOwnProperty(R) && (h = r[R], h != null && wt(t, i, R, h, r, null));
    }
    function yv(t, i, r, h) {
      switch (qo(i, h), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var g = null, O = null, x = null, R = null, Q = null, N = null, ee = null;
          for (re in r) {
            var oe = r[re];
            if (r.hasOwnProperty(re) && oe != null)
              switch (re) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  Q = oe;
                default:
                  h.hasOwnProperty(re) || wt(
                    t,
                    i,
                    re,
                    null,
                    h,
                    oe
                  );
              }
          }
          for (var J in h) {
            var re = h[J];
            if (oe = r[J], h.hasOwnProperty(J) && (re != null || oe != null))
              switch (J) {
                case "type":
                  O = re;
                  break;
                case "name":
                  g = re;
                  break;
                case "checked":
                  N = re;
                  break;
                case "defaultChecked":
                  ee = re;
                  break;
                case "value":
                  x = re;
                  break;
                case "defaultValue":
                  R = re;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (re != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  re !== oe && wt(
                    t,
                    i,
                    J,
                    re,
                    h,
                    oe
                  );
              }
          }
          i = r.type === "checkbox" || r.type === "radio" ? r.checked != null : r.value != null, h = h.type === "checkbox" || h.type === "radio" ? h.checked != null : h.value != null, i || !h || dE || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), dE = !0), !i || h || hE || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), hE = !0), Km(
            t,
            x,
            R,
            Q,
            N,
            ee,
            O,
            g
          );
          return;
        case "select":
          re = x = R = J = null;
          for (O in r)
            if (Q = r[O], r.hasOwnProperty(O) && Q != null)
              switch (O) {
                case "value":
                  break;
                case "multiple":
                  re = Q;
                default:
                  h.hasOwnProperty(O) || wt(
                    t,
                    i,
                    O,
                    null,
                    h,
                    Q
                  );
              }
          for (g in h)
            if (O = h[g], Q = r[g], h.hasOwnProperty(g) && (O != null || Q != null))
              switch (g) {
                case "value":
                  J = O;
                  break;
                case "defaultValue":
                  R = O;
                  break;
                case "multiple":
                  x = O;
                default:
                  O !== Q && wt(
                    t,
                    i,
                    g,
                    O,
                    h,
                    Q
                  );
              }
          h = R, i = x, r = re, J != null ? Oo(t, !!i, J, !1) : !!r != !!i && (h != null ? Oo(t, !!i, h, !0) : Oo(t, !!i, i ? [] : "", !1));
          return;
        case "textarea":
          re = J = null;
          for (R in r)
            if (g = r[R], r.hasOwnProperty(R) && g != null && !h.hasOwnProperty(R))
              switch (R) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  wt(t, i, R, null, h, g);
              }
          for (x in h)
            if (g = h[x], O = r[x], h.hasOwnProperty(x) && (g != null || O != null))
              switch (x) {
                case "value":
                  J = g;
                  break;
                case "defaultValue":
                  re = g;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (g != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  g !== O && wt(t, i, x, g, h, O);
              }
          Im(t, J, re);
          return;
        case "option":
          for (var He in r)
            if (J = r[He], r.hasOwnProperty(He) && J != null && !h.hasOwnProperty(He))
              switch (He) {
                case "selected":
                  t.selected = !1;
                  break;
                default:
                  wt(
                    t,
                    i,
                    He,
                    null,
                    h,
                    J
                  );
              }
          for (Q in h)
            if (J = h[Q], re = r[Q], h.hasOwnProperty(Q) && J !== re && (J != null || re != null))
              switch (Q) {
                case "selected":
                  t.selected = J && typeof J != "function" && typeof J != "symbol";
                  break;
                default:
                  wt(
                    t,
                    i,
                    Q,
                    J,
                    h,
                    re
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var Fe in r)
            J = r[Fe], r.hasOwnProperty(Fe) && J != null && !h.hasOwnProperty(Fe) && wt(
              t,
              i,
              Fe,
              null,
              h,
              J
            );
          for (N in h)
            if (J = h[N], re = r[N], h.hasOwnProperty(N) && J !== re && (J != null || re != null))
              switch (N) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (J != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  wt(
                    t,
                    i,
                    N,
                    J,
                    h,
                    re
                  );
              }
          return;
        default:
          if (yr(i)) {
            for (var en in r)
              J = r[en], r.hasOwnProperty(en) && J !== void 0 && !h.hasOwnProperty(en) && Rs(
                t,
                i,
                en,
                void 0,
                h,
                J
              );
            for (ee in h)
              J = h[ee], re = r[ee], !h.hasOwnProperty(ee) || J === re || J === void 0 && re === void 0 || Rs(
                t,
                i,
                ee,
                J,
                h,
                re
              );
            return;
          }
      }
      for (var Tt in r)
        J = r[Tt], r.hasOwnProperty(Tt) && J != null && !h.hasOwnProperty(Tt) && wt(t, i, Tt, null, h, J);
      for (oe in h)
        J = h[oe], re = r[oe], !h.hasOwnProperty(oe) || J === re || J == null && re == null || wt(t, i, oe, J, h, re);
    }
    function hc(t) {
      switch (t) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return t;
      }
    }
    function dp(t) {
      var i = {};
      t = t.style;
      for (var r = 0; r < t.length; r++) {
        var h = t[r];
        i[h] = t.getPropertyValue(h);
      }
      return i;
    }
    function ih(t, i, r) {
      if (i != null && typeof i != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var h, g = h = "", O;
        for (O in i)
          if (i.hasOwnProperty(O)) {
            var x = i[O];
            x != null && typeof x != "boolean" && x !== "" && (O.indexOf("--") === 0 ? (Ae(x, O), h += g + O + ":" + ("" + x).trim()) : typeof x != "number" || x === 0 || oy.has(O) ? (Ae(x, O), h += g + O.replace(Po, "-$1").toLowerCase().replace(Rc, "-ms-") + ":" + ("" + x).trim()) : h += g + O.replace(Po, "-$1").toLowerCase().replace(Rc, "-ms-") + ":" + x + "px", g = ";");
          }
        h = h || null, i = t.getAttribute("style"), i !== h && (h = _o(h), _o(i) !== h && (r.style = dp(t)));
      }
    }
    function ml(t, i, r, h, g, O) {
      if (g.delete(r), t = t.getAttribute(r), t === null)
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (h != null)
        switch (typeof h) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (le(h, i), t === "" + h)
              return;
        }
      Jt(i, t, h, O);
    }
    function Ov(t, i, r, h, g, O) {
      if (g.delete(r), t = t.getAttribute(r), t === null) {
        switch (typeof h) {
          case "function":
          case "symbol":
            return;
        }
        if (!h) return;
      } else
        switch (typeof h) {
          case "function":
          case "symbol":
            break;
          default:
            if (h) return;
        }
      Jt(i, t, h, O);
    }
    function E0(t, i, r, h, g, O) {
      if (g.delete(r), t = t.getAttribute(r), t === null)
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (h != null)
        switch (typeof h) {
          case "function":
          case "symbol":
            break;
          default:
            if (le(h, r), t === "" + h)
              return;
        }
      Jt(i, t, h, O);
    }
    function qt(t, i, r, h, g, O) {
      if (g.delete(r), t = t.getAttribute(r), t === null)
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(h)) return;
        }
      else if (h != null)
        switch (typeof h) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(h) && (le(h, i), t === "" + h))
              return;
        }
      Jt(i, t, h, O);
    }
    function Xt(t, i, r, h, g, O) {
      if (g.delete(r), t = t.getAttribute(r), t === null)
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (h != null)
        switch (typeof h) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (le(h, i), r = bo("" + h), t === r)
              return;
        }
      Jt(i, t, h, O);
    }
    function yt(t, i, r, h) {
      for (var g = {}, O = /* @__PURE__ */ new Set(), x = t.attributes, R = 0; R < x.length; R++)
        switch (x[R].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            O.add(x[R].name);
        }
      if (yr(i)) {
        for (var Q in r)
          if (r.hasOwnProperty(Q)) {
            var N = r[Q];
            if (N != null) {
              if (Sa.hasOwnProperty(Q))
                typeof N != "function" && Hl(Q, N);
              else if (r.suppressHydrationWarning !== !0)
                switch (Q) {
                  case "children":
                    typeof N != "string" && typeof N != "number" || Jt(
                      "children",
                      t.textContent,
                      N,
                      g
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    x = t.innerHTML, N = N ? N.__html : void 0, N != null && (N = ya(t, N), Jt(
                      Q,
                      x,
                      N,
                      g
                    ));
                    continue;
                  case "style":
                    O.delete(Q), ih(t, N, g);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    O.delete(Q.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      Q
                    );
                    continue;
                  case "className":
                    O.delete("class"), x = tt(
                      t,
                      "class",
                      N
                    ), Jt(
                      "className",
                      x,
                      N,
                      g
                    );
                    continue;
                  default:
                    h.context === ou && i !== "svg" && i !== "math" ? O.delete(Q.toLowerCase()) : O.delete(Q), x = tt(
                      t,
                      Q,
                      N
                    ), Jt(
                      Q,
                      x,
                      N,
                      g
                    );
                }
            }
          }
      } else
        for (N in r)
          if (r.hasOwnProperty(N) && (Q = r[N], Q != null)) {
            if (Sa.hasOwnProperty(N))
              typeof Q != "function" && Hl(N, Q);
            else if (r.suppressHydrationWarning !== !0)
              switch (N) {
                case "children":
                  typeof Q != "string" && typeof Q != "number" || Jt(
                    "children",
                    t.textContent,
                    Q,
                    g
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  x = t.innerHTML, Q = Q ? Q.__html : void 0, Q != null && (Q = ya(t, Q), x !== Q && (g[N] = { __html: x }));
                  continue;
                case "className":
                  ml(
                    t,
                    N,
                    "class",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "tabIndex":
                  ml(
                    t,
                    N,
                    "tabindex",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "style":
                  O.delete(N), ih(t, Q, g);
                  continue;
                case "multiple":
                  O.delete(N), Jt(
                    N,
                    t.multiple,
                    Q,
                    g
                  );
                  continue;
                case "muted":
                  O.delete(N), Jt(
                    N,
                    t.muted,
                    Q,
                    g
                  );
                  continue;
                case "autoFocus":
                  O.delete("autofocus"), Jt(
                    N,
                    t.autofocus,
                    Q,
                    g
                  );
                  continue;
                case "data":
                  if (i !== "object") {
                    O.delete(N), x = t.getAttribute("data"), Jt(
                      N,
                      x,
                      Q,
                      g
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(Q !== "" || i === "a" && N === "href" || i === "object" && N === "data")) {
                    console.error(
                      N === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      N,
                      N
                    );
                    continue;
                  }
                  Xt(
                    t,
                    N,
                    N,
                    Q,
                    O,
                    g
                  );
                  continue;
                case "action":
                case "formAction":
                  if (x = t.getAttribute(N), typeof Q == "function") {
                    O.delete(N.toLowerCase()), N === "formAction" ? (O.delete("name"), O.delete("formenctype"), O.delete("formmethod"), O.delete("formtarget")) : (O.delete("enctype"), O.delete("method"), O.delete("target"));
                    continue;
                  } else if (x === h3) {
                    O.delete(N.toLowerCase()), Jt(
                      N,
                      "function",
                      Q,
                      g
                    );
                    continue;
                  }
                  Xt(
                    t,
                    N,
                    N.toLowerCase(),
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkHref":
                  Xt(
                    t,
                    N,
                    "xlink:href",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "contentEditable":
                  E0(
                    t,
                    N,
                    "contenteditable",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "spellCheck":
                  E0(
                    t,
                    N,
                    "spellcheck",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  E0(
                    t,
                    N,
                    N,
                    Q,
                    O,
                    g
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  Ov(
                    t,
                    N,
                    N.toLowerCase(),
                    Q,
                    O,
                    g
                  );
                  continue;
                case "capture":
                case "download":
                  e: {
                    R = t;
                    var ee = x = N, oe = g;
                    if (O.delete(ee), R = R.getAttribute(ee), R === null)
                      switch (typeof Q) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break e;
                        default:
                          if (Q === !1) break e;
                      }
                    else if (Q != null)
                      switch (typeof Q) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (Q === !0 && R === "") break e;
                          break;
                        default:
                          if (le(Q, x), R === "" + Q)
                            break e;
                      }
                    Jt(
                      x,
                      R,
                      Q,
                      oe
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  e: {
                    if (R = t, ee = x = N, oe = g, O.delete(ee), R = R.getAttribute(ee), R === null)
                      switch (typeof Q) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break e;
                        default:
                          if (isNaN(Q) || 1 > Q) break e;
                      }
                    else if (Q != null)
                      switch (typeof Q) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(Q) || 1 > Q) && (le(Q, x), R === "" + Q))
                            break e;
                      }
                    Jt(
                      x,
                      R,
                      Q,
                      oe
                    );
                  }
                  continue;
                case "rowSpan":
                  qt(
                    t,
                    N,
                    "rowspan",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "start":
                  qt(
                    t,
                    N,
                    N,
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xHeight":
                  ml(
                    t,
                    N,
                    "x-height",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkActuate":
                  ml(
                    t,
                    N,
                    "xlink:actuate",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkArcrole":
                  ml(
                    t,
                    N,
                    "xlink:arcrole",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkRole":
                  ml(
                    t,
                    N,
                    "xlink:role",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkShow":
                  ml(
                    t,
                    N,
                    "xlink:show",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkTitle":
                  ml(
                    t,
                    N,
                    "xlink:title",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xlinkType":
                  ml(
                    t,
                    N,
                    "xlink:type",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xmlBase":
                  ml(
                    t,
                    N,
                    "xml:base",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xmlLang":
                  ml(
                    t,
                    N,
                    "xml:lang",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "xmlSpace":
                  ml(
                    t,
                    N,
                    "xml:space",
                    Q,
                    O,
                    g
                  );
                  continue;
                case "inert":
                  Q !== "" || mb[N] || (mb[N] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    N
                  )), Ov(
                    t,
                    N,
                    N,
                    Q,
                    O,
                    g
                  );
                  continue;
                default:
                  if (!(2 < N.length) || N[0] !== "o" && N[0] !== "O" || N[1] !== "n" && N[1] !== "N") {
                    R = Or(N), x = !1, h.context === ou && i !== "svg" && i !== "math" ? O.delete(R.toLowerCase()) : (ee = N.toLowerCase(), ee = wh.hasOwnProperty(
                      ee
                    ) && wh[ee] || null, ee !== null && ee !== N && (x = !0, O.delete(ee)), O.delete(R));
                    e: if (ee = t, oe = R, R = Q, ht(oe))
                      if (ee.hasAttribute(oe))
                        ee = ee.getAttribute(
                          oe
                        ), le(
                          R,
                          oe
                        ), R = ee === "" + R ? R : ee;
                      else {
                        switch (typeof R) {
                          case "function":
                          case "symbol":
                            break e;
                          case "boolean":
                            if (ee = oe.toLowerCase().slice(0, 5), ee !== "data-" && ee !== "aria-")
                              break e;
                        }
                        R = R === void 0 ? void 0 : null;
                      }
                    else R = void 0;
                    x || Jt(
                      N,
                      R,
                      Q,
                      g
                    );
                  }
              }
          }
      return 0 < O.size && r.suppressHydrationWarning !== !0 && w0(t, O, g), Object.keys(g).length === 0 ? null : g;
    }
    function xt(t, i) {
      switch (t.length) {
        case 0:
          return "";
        case 1:
          return t[0];
        case 2:
          return t[0] + " " + i + " " + t[1];
        default:
          return t.slice(0, -1).join(", ") + ", " + i + " " + t[t.length - 1];
      }
    }
    function Et(t) {
      return t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Fi(t) {
      switch (t) {
        case Wo:
          return bm;
        case Gp:
          return Ob;
        default:
          return ou;
      }
    }
    function Ho(t, i) {
      if (t === ou)
        switch (i) {
          case "svg":
            return bm;
          case "math":
            return Ob;
          default:
            return ou;
        }
      return t === bm && i === "foreignObject" ? ou : t;
    }
    function ks(t, i) {
      return t === "textarea" || t === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
    }
    function C0() {
      var t = window.event;
      return t && t.type === "popstate" ? t === yT ? !1 : (yT = t, !0) : (yT = null, !1);
    }
    function Lo(t) {
      setTimeout(function() {
        throw t;
      });
    }
    function mn(t, i, r) {
      switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          r.autoFocus && t.focus();
          break;
        case "img":
          r.src ? t.src = r.src : r.srcSet && (t.srcset = r.srcSet);
      }
    }
    function Ds(t, i, r, h) {
      yv(t, i, r, h), t[el] = h;
    }
    function Ms(t) {
      df(t, "");
    }
    function R0(t, i, r) {
      t.nodeValue = r;
    }
    function Mn(t) {
      return t === "head";
    }
    function dc(t, i) {
      t.removeChild(i);
    }
    function lh(t, i) {
      (t.nodeType === 9 ? t.body : t.nodeName === "HTML" ? t.ownerDocument.body : t).removeChild(i);
    }
    function Ci(t, i) {
      var r = i, h = 0, g = 0;
      do {
        var O = r.nextSibling;
        if (t.removeChild(r), O && O.nodeType === 8)
          if (r = O.data, r === yb) {
            if (0 < h && 8 > h) {
              r = h;
              var x = t.ownerDocument;
              if (r & p3 && gc(x.documentElement), r & m3 && gc(x.body), r & g3)
                for (r = x.head, gc(r), x = r.firstChild; x; ) {
                  var R = x.nextSibling, Q = x.nodeName;
                  x[yh] || Q === "SCRIPT" || Q === "STYLE" || Q === "LINK" && x.rel.toLowerCase() === "stylesheet" || r.removeChild(x), x = R;
                }
            }
            if (g === 0) {
              t.removeChild(O), Sc(i);
              return;
            }
            g--;
          } else
            r === gb || r === au || r === Uy ? g++ : h = r.charCodeAt(0) - 48;
        else h = 0;
        r = O;
      } while (r);
      Sc(i);
    }
    function k0(t) {
      t = t.style, typeof t.setProperty == "function" ? t.setProperty("display", "none", "important") : t.display = "none";
    }
    function D0(t) {
      t.nodeValue = "";
    }
    function pp(t, i) {
      i = i[y3], i = i != null && i.hasOwnProperty("display") ? i.display : null, t.style.display = i == null || typeof i == "boolean" ? "" : ("" + i).trim();
    }
    function mp(t, i) {
      t.nodeValue = i;
    }
    function La(t) {
      var i = t.firstChild;
      for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
        var r = i;
        switch (i = i.nextSibling, r.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            La(r), Kl(r);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (r.rel.toLowerCase() === "stylesheet") continue;
        }
        t.removeChild(r);
      }
    }
    function ti(t, i, r, h) {
      for (; t.nodeType === 1; ) {
        var g = r;
        if (t.nodeName.toLowerCase() !== i.toLowerCase()) {
          if (!h && (t.nodeName !== "INPUT" || t.type !== "hidden"))
            break;
        } else if (h) {
          if (!t[yh])
            switch (i) {
              case "meta":
                if (!t.hasAttribute("itemprop")) break;
                return t;
              case "link":
                if (O = t.getAttribute("rel"), O === "stylesheet" && t.hasAttribute("data-precedence"))
                  break;
                if (O !== g.rel || t.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || t.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || t.getAttribute("title") !== (g.title == null ? null : g.title))
                  break;
                return t;
              case "style":
                if (t.hasAttribute("data-precedence")) break;
                return t;
              case "script":
                if (O = t.getAttribute("src"), (O !== (g.src == null ? null : g.src) || t.getAttribute("type") !== (g.type == null ? null : g.type) || t.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && O && t.hasAttribute("async") && !t.hasAttribute("itemprop"))
                  break;
                return t;
              default:
                return t;
            }
        } else if (i === "input" && t.type === "hidden") {
          le(g.name, "name");
          var O = g.name == null ? null : "" + g.name;
          if (g.type === "hidden" && t.getAttribute("name") === O)
            return t;
        } else return t;
        if (t = Ki(t.nextSibling), t === null) break;
      }
      return null;
    }
    function zs(t, i, r) {
      if (i === "") return null;
      for (; t.nodeType !== 3; )
        if ((t.nodeType !== 1 || t.nodeName !== "INPUT" || t.type !== "hidden") && !r || (t = Ki(t.nextSibling), t === null)) return null;
      return t;
    }
    function Qs(t) {
      return t.data === Uy || t.data === au && t.ownerDocument.readyState === yE;
    }
    function pc(t, i) {
      var r = t.ownerDocument;
      if (t.data !== au || r.readyState === yE)
        i();
      else {
        var h = function() {
          i(), r.removeEventListener("DOMContentLoaded", h);
        };
        r.addEventListener("DOMContentLoaded", h), t._reactRetry = h;
      }
    }
    function Ki(t) {
      for (; t != null; t = t.nextSibling) {
        var i = t.nodeType;
        if (i === 1 || i === 3) break;
        if (i === 8) {
          if (i = t.data, i === gb || i === Uy || i === au || i === pT || i === gE)
            break;
          if (i === yb) return null;
        }
      }
      return t;
    }
    function gp(t) {
      if (t.nodeType === 1) {
        for (var i = t.nodeName.toLowerCase(), r = {}, h = t.attributes, g = 0; g < h.length; g++) {
          var O = h[g];
          r[hc(O.name)] = O.name.toLowerCase() === "style" ? dp(t) : O.value;
        }
        return { type: i, props: r };
      }
      return t.nodeType === 8 ? { type: "Suspense", props: {} } : t.nodeValue;
    }
    function M0(t, i, r) {
      return r === null || r[d3] !== !0 ? (t.nodeValue === i ? t = null : (i = _o(i), t = _o(t.nodeValue) === i ? null : t.nodeValue), t) : null;
    }
    function mc(t) {
      t = t.nextSibling;
      for (var i = 0; t; ) {
        if (t.nodeType === 8) {
          var r = t.data;
          if (r === yb) {
            if (i === 0)
              return Ki(t.nextSibling);
            i--;
          } else
            r !== gb && r !== Uy && r !== au || i++;
        }
        t = t.nextSibling;
      }
      return null;
    }
    function yp(t) {
      t = t.previousSibling;
      for (var i = 0; t; ) {
        if (t.nodeType === 8) {
          var r = t.data;
          if (r === gb || r === Uy || r === au) {
            if (i === 0) return t;
            i--;
          } else r === yb && i++;
        }
        t = t.previousSibling;
      }
      return null;
    }
    function gl(t) {
      Sc(t);
    }
    function vv(t) {
      Sc(t);
    }
    function Ji(t, i, r, h, g) {
      switch (g && fd(t, h.ancestorInfo), i = Et(r), t) {
        case "html":
          if (t = i.documentElement, !t)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "head":
          if (t = i.head, !t)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        case "body":
          if (t = i.body, !t)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return t;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function bv(t, i, r, h) {
      if (!r[Ls] && Ui(r)) {
        var g = r.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          g,
          g,
          g
        );
      }
      switch (t) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (g = r.attributes; g.length; )
        r.removeAttributeNode(g[0]);
      Ln(r, t, i), r[gi] = h, r[el] = i;
    }
    function gc(t) {
      for (var i = t.attributes; i.length; )
        t.removeAttributeNode(i[0]);
      Kl(t);
    }
    function Op(t) {
      return typeof t.getRootNode == "function" ? t.getRootNode() : t.nodeType === 9 ? t : t.ownerDocument;
    }
    function Vo(t, i, r) {
      var h = Sm;
      if (h && typeof i == "string" && i) {
        var g = qn(i);
        g = 'link[rel="' + t + '"][href="' + g + '"]', typeof r == "string" && (g += '[crossorigin="' + r + '"]'), xE.has(g) || (xE.add(g), t = { rel: t, crossOrigin: r, href: i }, h.querySelector(g) === null && (i = h.createElement("link"), Ln(i, "link", t), Y(i), h.head.appendChild(i)));
      }
    }
    function ah(t, i, r, h) {
      var g = (g = Xa.current) ? Op(g) : null;
      if (!g)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (t) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof r.precedence == "string" && typeof r.href == "string" ? (r = Oa(r.href), i = M(g).hoistableStyles, h = i.get(r), h || (h = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, i.set(r, h)), h) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (r.rel === "stylesheet" && typeof r.href == "string" && typeof r.precedence == "string") {
            t = Oa(r.href);
            var O = M(g).hoistableStyles, x = O.get(t);
            if (!x && (g = g.ownerDocument || g, x = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: jh, preload: null }
            }, O.set(t, x), (O = g.querySelector(
              Oc(t)
            )) && !O._p && (x.instance = O, x.state.loading = By | lo), !ao.has(t))) {
              var R = {
                rel: "preload",
                as: "style",
                href: r.href,
                crossOrigin: r.crossOrigin,
                integrity: r.integrity,
                media: r.media,
                hrefLang: r.hrefLang,
                referrerPolicy: r.referrerPolicy
              };
              ao.set(t, R), O || Sv(
                g,
                t,
                R,
                x.state
              );
            }
            if (i && h === null)
              throw r = `

  - ` + yc(i) + `
  + ` + yc(r), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + r
              );
            return x;
          }
          if (i && h !== null)
            throw r = `

  - ` + yc(i) + `
  + ` + yc(r), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + r
            );
          return null;
        case "script":
          return i = r.async, r = r.src, typeof r == "string" && i && typeof i != "function" && typeof i != "symbol" ? (r = Ns(r), i = M(g).hoistableScripts, h = i.get(r), h || (h = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, i.set(r, h)), h) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + t + '". this is a bug in React.'
          );
      }
    }
    function yc(t) {
      var i = 0, r = "<link";
      return typeof t.rel == "string" ? (i++, r += ' rel="' + t.rel + '"') : ja.call(t, "rel") && (i++, r += ' rel="' + (t.rel === null ? "null" : "invalid type " + typeof t.rel) + '"'), typeof t.href == "string" ? (i++, r += ' href="' + t.href + '"') : ja.call(t, "href") && (i++, r += ' href="' + (t.href === null ? "null" : "invalid type " + typeof t.href) + '"'), typeof t.precedence == "string" ? (i++, r += ' precedence="' + t.precedence + '"') : ja.call(t, "precedence") && (i++, r += " precedence={" + (t.precedence === null ? "null" : "invalid type " + typeof t.precedence) + "}"), Object.getOwnPropertyNames(t).length > i && (r += " ..."), r + " />";
    }
    function Oa(t) {
      return 'href="' + qn(t) + '"';
    }
    function Oc(t) {
      return 'link[rel="stylesheet"][' + t + "]";
    }
    function z0(t) {
      return Ie({}, t, {
        "data-precedence": t.precedence,
        precedence: null
      });
    }
    function Sv(t, i, r, h) {
      t.querySelector(
        'link[rel="preload"][as="style"][' + i + "]"
      ) ? h.loading = By : (i = t.createElement("link"), h.preload = i, i.addEventListener("load", function() {
        return h.loading |= By;
      }), i.addEventListener("error", function() {
        return h.loading |= SE;
      }), Ln(i, "link", r), Y(i), t.head.appendChild(i));
    }
    function Ns(t) {
      return '[src="' + qn(t) + '"]';
    }
    function $r(t) {
      return "script[async]" + t;
    }
    function Tv(t, i, r) {
      if (i.count++, i.instance === null)
        switch (i.type) {
          case "style":
            var h = t.querySelector(
              'style[data-href~="' + qn(r.href) + '"]'
            );
            if (h)
              return i.instance = h, Y(h), h;
            var g = Ie({}, r, {
              "data-href": r.href,
              "data-precedence": r.precedence,
              href: null,
              precedence: null
            });
            return h = (t.ownerDocument || t).createElement("style"), Y(h), Ln(h, "style", g), vp(h, r.precedence, t), i.instance = h;
          case "stylesheet":
            g = Oa(r.href);
            var O = t.querySelector(
              Oc(g)
            );
            if (O)
              return i.state.loading |= lo, i.instance = O, Y(O), O;
            h = z0(r), (g = ao.get(g)) && Q0(h, g), O = (t.ownerDocument || t).createElement("link"), Y(O);
            var x = O;
            return x._p = new Promise(function(R, Q) {
              x.onload = R, x.onerror = Q;
            }), Ln(O, "link", h), i.state.loading |= lo, vp(O, r.precedence, t), i.instance = O;
          case "script":
            return O = Ns(r.src), (g = t.querySelector(
              $r(O)
            )) ? (i.instance = g, Y(g), g) : (h = r, (g = ao.get(O)) && (h = Ie({}, r), bp(h, g)), t = t.ownerDocument || t, g = t.createElement("script"), Y(g), Ln(g, "link", h), t.head.appendChild(g), i.instance = g);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + i.type + '". this is a bug in React.'
            );
        }
      else
        i.type === "stylesheet" && (i.state.loading & lo) === jh && (h = i.instance, i.state.loading |= lo, vp(h, r.precedence, t));
      return i.instance;
    }
    function vp(t, i, r) {
      for (var h = r.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), g = h.length ? h[h.length - 1] : null, O = g, x = 0; x < h.length; x++) {
        var R = h[x];
        if (R.dataset.precedence === i) O = R;
        else if (O !== g) break;
      }
      O ? O.parentNode.insertBefore(t, O.nextSibling) : (i = r.nodeType === 9 ? r.head : r, i.insertBefore(t, i.firstChild));
    }
    function Q0(t, i) {
      t.crossOrigin == null && (t.crossOrigin = i.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = i.referrerPolicy), t.title == null && (t.title = i.title);
    }
    function bp(t, i) {
      t.crossOrigin == null && (t.crossOrigin = i.crossOrigin), t.referrerPolicy == null && (t.referrerPolicy = i.referrerPolicy), t.integrity == null && (t.integrity = i.integrity);
    }
    function N0(t, i, r) {
      if (vb === null) {
        var h = /* @__PURE__ */ new Map(), g = vb = /* @__PURE__ */ new Map();
        g.set(r, h);
      } else
        g = vb, h = g.get(r), h || (h = /* @__PURE__ */ new Map(), g.set(r, h));
      if (h.has(t)) return h;
      for (h.set(t, null), r = r.getElementsByTagName(t), g = 0; g < r.length; g++) {
        var O = r[g];
        if (!(O[yh] || O[gi] || t === "link" && O.getAttribute("rel") === "stylesheet") && O.namespaceURI !== Wo) {
          var x = O.getAttribute(i) || "";
          x = t + x;
          var R = h.get(x);
          R ? R.push(O) : h.set(x, [O]);
        }
      }
      return h;
    }
    function Zr(t, i, r) {
      t = t.ownerDocument || t, t.head.insertBefore(
        r,
        i === "title" ? t.querySelector("head > title") : null
      );
    }
    function Sp(t, i, r) {
      var h = !r.ancestorInfo.containerTagInScope;
      if (r.context === bm || i.itemProp != null)
        return !h || i.itemProp == null || t !== "meta" && t !== "title" && t !== "style" && t !== "link" && t !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          t,
          t
        ), !1;
      switch (t) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "") {
            h && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError) {
            if (i.rel === "stylesheet" && typeof i.precedence == "string") {
              t = i.href;
              var g = i.onError, O = i.disabled;
              r = [], i.onLoad && r.push("`onLoad`"), g && r.push("`onError`"), O != null && r.push("`disabled`"), g = xt(r, "and"), g += r.length === 1 ? " prop" : " props", O = r.length === 1 ? "an " + g : "the " + g, r.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                t,
                O,
                g
              );
            }
            h && (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (i.onError || i.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (i.rel) {
            case "stylesheet":
              return t = i.precedence, i = i.disabled, typeof t != "string" && h && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof t == "string" && i == null;
            default:
              return !0;
          }
        case "script":
          if (t = i.async && typeof i.async != "function" && typeof i.async != "symbol", !t || i.onLoad || i.onError || !i.src || typeof i.src != "string") {
            h && (t ? i.onLoad || i.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          h && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            t
          );
      }
      return !1;
    }
    function U0(t) {
      return !(t.type === "stylesheet" && (t.state.loading & TE) === jh);
    }
    function xv() {
    }
    function Av(t, i, r) {
      if (qy === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var h = qy;
      if (i.type === "stylesheet" && (typeof r.media != "string" || matchMedia(r.media).matches !== !1) && (i.state.loading & lo) === jh) {
        if (i.instance === null) {
          var g = Oa(r.href), O = t.querySelector(
            Oc(g)
          );
          if (O) {
            t = O._p, t !== null && typeof t == "object" && typeof t.then == "function" && (h.count++, h = oh.bind(h), t.then(h, h)), i.state.loading |= lo, i.instance = O, Y(O);
            return;
          }
          O = t.ownerDocument || t, r = z0(r), (g = ao.get(g)) && Q0(r, g), O = O.createElement("link"), Y(O);
          var x = O;
          x._p = new Promise(function(R, Q) {
            x.onload = R, x.onerror = Q;
          }), Ln(O, "link", r), i.instance = O;
        }
        h.stylesheets === null && (h.stylesheets = /* @__PURE__ */ new Map()), h.stylesheets.set(i, t), (t = i.state.preload) && (i.state.loading & TE) === jh && (h.count++, i = oh.bind(h), t.addEventListener("load", i), t.addEventListener("error", i));
      }
    }
    function wv() {
      if (qy === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var t = qy;
      return t.stylesheets && t.count === 0 && Tp(t, t.stylesheets), 0 < t.count ? function(i) {
        var r = setTimeout(function() {
          if (t.stylesheets && Tp(t, t.stylesheets), t.unsuspend) {
            var h = t.unsuspend;
            t.unsuspend = null, h();
          }
        }, 6e4);
        return t.unsuspend = i, function() {
          t.unsuspend = null, clearTimeout(r);
        };
      } : null;
    }
    function oh() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Tp(this, this.stylesheets);
        else if (this.unsuspend) {
          var t = this.unsuspend;
          this.unsuspend = null, t();
        }
      }
    }
    function Tp(t, i) {
      t.stylesheets = null, t.unsuspend !== null && (t.count++, bb = /* @__PURE__ */ new Map(), i.forEach(xp, t), bb = null, oh.call(t));
    }
    function xp(t, i) {
      if (!(i.state.loading & lo)) {
        var r = bb.get(t);
        if (r) var h = r.get(vT);
        else {
          r = /* @__PURE__ */ new Map(), bb.set(t, r);
          for (var g = t.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), O = 0; O < g.length; O++) {
            var x = g[O];
            (x.nodeName === "LINK" || x.getAttribute("media") !== "not all") && (r.set(x.dataset.precedence, x), h = x);
          }
          h && r.set(vT, h);
        }
        g = i.instance, x = g.getAttribute("data-precedence"), O = r.get(x) || h, O === h && r.set(vT, g), r.set(x, g), this.count++, h = oh.bind(this), g.addEventListener("load", h), g.addEventListener("error", h), O ? O.parentNode.insertBefore(g, O.nextSibling) : (t = t.nodeType === 9 ? t.head : t, t.insertBefore(g, t.firstChild)), i.state.loading |= lo;
      }
    }
    function Ev(t, i, r, h, g, O, x, R) {
      for (this.tag = 1, this.containerInfo = t, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Xh, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = hr(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = hr(0), this.hiddenUpdates = hr(null), this.identifierPrefix = h, this.onUncaughtError = g, this.onCaughtError = O, this.onRecoverableError = x, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = R, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), t = this.pendingUpdatersLaneMap = [], i = 0; 31 > i; i++) t.push(/* @__PURE__ */ new Set());
      this._debugRootType = r ? "hydrateRoot()" : "createRoot()";
    }
    function B0(t, i, r, h, g, O, x, R, Q, N, ee, oe) {
      return t = new Ev(
        t,
        i,
        r,
        x,
        R,
        Q,
        N,
        oe
      ), i = jz, O === !0 && (i |= tl | Fo), Ll && (i |= Ri), O = E(3, null, null, i), t.current = O, O.stateNode = t, i = bg(), Ml(i), t.pooledCache = i, Ml(i), O.memoizedState = {
        element: h,
        isDehydrated: r,
        cache: i
      }, ps(O), t;
    }
    function jt(t) {
      return t ? (t = Dc, t) : Dc;
    }
    function sh(t, i, r, h, g, O) {
      if (ii && typeof ii.onScheduleFiberRoot == "function")
        try {
          ii.onScheduleFiberRoot(Fr, h, r);
        } catch (x) {
          bn || (bn = !0, console.error(
            "React instrumentation encountered an error: %s",
            x
          ));
        }
      ke !== null && typeof ke.markRenderScheduled == "function" && ke.markRenderScheduled(i), g = jt(g), h.context === null ? h.context = g : h.pendingContext = g, Ya && li !== null && !CE && (CE = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        Te(li) || "Unknown"
      )), h = na(i), h.payload = { element: r }, O = O === void 0 ? null : O, O !== null && (typeof O != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        O
      ), h.callback = O), r = ia(t, h, i), r !== null && (mt(r, t, i), kr(r, t, i));
    }
    function Cv(t, i) {
      if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < i ? r : i;
      }
    }
    function Ap(t, i) {
      Cv(t, i), (t = t.alternate) && Cv(t, i);
    }
    function Rv(t) {
      if (t.tag === 13) {
        var i = qi(t, 67108864);
        i !== null && mt(i, t, 67108864), Ap(t, 67108864);
      }
    }
    function dS() {
      return li;
    }
    function pS() {
      for (var t = /* @__PURE__ */ new Map(), i = 1, r = 0; 31 > r; r++) {
        var h = af(i);
        t.set(i, h), i *= 2;
      }
      return t;
    }
    function wp(t, i, r, h) {
      var g = I.T;
      I.T = null;
      var O = Mt.p;
      try {
        Mt.p = Ol, rh(t, i, r, h);
      } finally {
        Mt.p = O, I.T = g;
      }
    }
    function vc(t, i, r, h) {
      var g = I.T;
      I.T = null;
      var O = Mt.p;
      try {
        Mt.p = Ga, rh(t, i, r, h);
      } finally {
        Mt.p = O, I.T = g;
      }
    }
    function rh(t, i, r, h) {
      if (Tb) {
        var g = bc(h);
        if (g === null)
          pl(
            t,
            i,
            h,
            xb,
            r
          ), va(t, h);
        else if (mS(
          g,
          t,
          i,
          r,
          h
        ))
          h.stopPropagation();
        else if (va(t, h), i & 4 && -1 < S3.indexOf(t)) {
          for (; g !== null; ) {
            var O = Ui(g);
            if (O !== null)
              switch (O.tag) {
                case 3:
                  if (O = O.stateNode, O.current.memoizedState.isDehydrated) {
                    var x = _t(O.pendingLanes);
                    if (x !== 0) {
                      var R = O;
                      for (R.pendingLanes |= 2, R.entangledLanes |= 2; x; ) {
                        var Q = 1 << 31 - Vn(x);
                        R.entanglements[1] |= Q, x &= ~Q;
                      }
                      ql(O), (Ht & (Tl | es)) === xa && (ob = ni() + aE, Es(0));
                    }
                  }
                  break;
                case 13:
                  R = qi(O, 2), R !== null && mt(R, O, 2), Vr(), Ap(O, 2);
              }
            if (O = bc(h), O === null && pl(
              t,
              i,
              h,
              xb,
              r
            ), O === g) break;
            g = O;
          }
          g !== null && h.stopPropagation();
        } else
          pl(
            t,
            i,
            h,
            null,
            r
          );
      }
    }
    function bc(t) {
      return t = Jl(t), uh(t);
    }
    function uh(t) {
      if (xb = null, t = Kn(t), t !== null) {
        var i = ie(t);
        if (i === null) t = null;
        else {
          var r = i.tag;
          if (r === 13) {
            if (t = me(i), t !== null) return t;
            t = null;
          } else if (r === 3) {
            if (i.stateNode.current.memoizedState.isDehydrated)
              return i.tag === 3 ? i.stateNode.containerInfo : null;
            t = null;
          } else i !== t && (t = null);
        }
      }
      return xb = t, null;
    }
    function Us(t) {
      switch (t) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Ol;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Ga;
        case "message":
          switch (Qv()) {
            case mh:
              return Ol;
            case X0:
              return Ga;
            case xc:
            case j0:
              return Zo;
            case G0:
              return Bp;
            default:
              return Zo;
          }
        default:
          return Zo;
      }
    }
    function va(t, i) {
      switch (t) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Vc = null;
          break;
        case "mouseover":
        case "mouseout":
          Xc = null;
          break;
        case "pointerover":
        case "pointerout":
          Hy.delete(i.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Ly.delete(i.pointerId);
      }
    }
    function Xo(t, i, r, h, g, O) {
      return t === null || t.nativeEvent !== O ? (t = {
        blockedOn: i,
        domEventName: r,
        eventSystemFlags: h,
        nativeEvent: O,
        targetContainers: [g]
      }, i !== null && (i = Ui(i), i !== null && Rv(i)), t) : (t.eventSystemFlags |= h, i = t.targetContainers, g !== null && i.indexOf(g) === -1 && i.push(g), t);
    }
    function mS(t, i, r, h, g) {
      switch (i) {
        case "focusin":
          return Lc = Xo(
            Lc,
            t,
            i,
            r,
            h,
            g
          ), !0;
        case "dragenter":
          return Vc = Xo(
            Vc,
            t,
            i,
            r,
            h,
            g
          ), !0;
        case "mouseover":
          return Xc = Xo(
            Xc,
            t,
            i,
            r,
            h,
            g
          ), !0;
        case "pointerover":
          var O = g.pointerId;
          return Hy.set(
            O,
            Xo(
              Hy.get(O) || null,
              t,
              i,
              r,
              h,
              g
            )
          ), !0;
        case "gotpointercapture":
          return O = g.pointerId, Ly.set(
            O,
            Xo(
              Ly.get(O) || null,
              t,
              i,
              r,
              h,
              g
            )
          ), !0;
      }
      return !1;
    }
    function q0(t) {
      var i = Kn(t.target);
      if (i !== null) {
        var r = ie(i);
        if (r !== null) {
          if (i = r.tag, i === 13) {
            if (i = me(r), i !== null) {
              t.blockedOn = i, yo(t.priority, function() {
                if (r.tag === 13) {
                  var h = dl(r);
                  h = El(h);
                  var g = qi(
                    r,
                    h
                  );
                  g !== null && mt(g, r, h), Ap(r, h);
                }
              });
              return;
            }
          } else if (i === 3 && r.stateNode.current.memoizedState.isDehydrated) {
            t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
            return;
          }
        }
      }
      t.blockedOn = null;
    }
    function ch(t) {
      if (t.blockedOn !== null) return !1;
      for (var i = t.targetContainers; 0 < i.length; ) {
        var r = bc(t.nativeEvent);
        if (r === null) {
          r = t.nativeEvent;
          var h = new r.constructor(
            r.type,
            r
          ), g = h;
          T !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), T = g, r.target.dispatchEvent(h), T === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), T = null;
        } else
          return i = Ui(r), i !== null && Rv(i), t.blockedOn = r, !1;
        i.shift();
      }
      return !0;
    }
    function _0(t, i, r) {
      ch(t) && r.delete(i);
    }
    function kv() {
      bT = !1, Lc !== null && ch(Lc) && (Lc = null), Vc !== null && ch(Vc) && (Vc = null), Xc !== null && ch(Xc) && (Xc = null), Hy.forEach(_0), Ly.forEach(_0);
    }
    function Ep(t, i) {
      t.blockedOn === i && (t.blockedOn = null, bT || (bT = !0, gn.unstable_scheduleCallback(
        gn.unstable_NormalPriority,
        kv
      )));
    }
    function Cp(t) {
      Ab !== t && (Ab = t, gn.unstable_scheduleCallback(
        gn.unstable_NormalPriority,
        function() {
          Ab === t && (Ab = null);
          for (var i = 0; i < t.length; i += 3) {
            var r = t[i], h = t[i + 1], g = t[i + 2];
            if (typeof h != "function") {
              if (uh(h || r) === null)
                continue;
              break;
            }
            var O = Ui(r);
            O !== null && (t.splice(i, 3), i -= 3, r = {
              pending: !0,
              data: g,
              method: r.method,
              action: h
            }, Object.freeze(r), Hd(
              O,
              r,
              h,
              g
            ));
          }
        }
      ));
    }
    function Sc(t) {
      function i(Q) {
        return Ep(Q, t);
      }
      Lc !== null && Ep(Lc, t), Vc !== null && Ep(Vc, t), Xc !== null && Ep(Xc, t), Hy.forEach(i), Ly.forEach(i);
      for (var r = 0; r < jc.length; r++) {
        var h = jc[r];
        h.blockedOn === t && (h.blockedOn = null);
      }
      for (; 0 < jc.length && (r = jc[0], r.blockedOn === null); )
        q0(r), r.blockedOn === null && jc.shift();
      if (r = (t.ownerDocument || t).$$reactFormReplay, r != null)
        for (h = 0; h < r.length; h += 3) {
          var g = r[h], O = r[h + 1], x = g[el] || null;
          if (typeof O == "function")
            x || Cp(r);
          else if (x) {
            var R = null;
            if (O && O.hasAttribute("formAction")) {
              if (g = O, x = O[el] || null)
                R = x.formAction;
              else if (uh(g) !== null) continue;
            } else R = x.action;
            typeof R == "function" ? r[h + 1] = R : (r.splice(h, 3), h -= 3), Cp(r);
          }
        }
    }
    function Rp(t) {
      this._internalRoot = t;
    }
    function kp(t) {
      this._internalRoot = t;
    }
    function Dp(t) {
      t[Ls] && (t._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var gn = ak(), H0 = Xm(), gS = ok(), Ie = Object.assign, yS = Symbol.for("react.element"), jo = Symbol.for("react.transitional.element"), at = Symbol.for("react.portal"), Bs = Symbol.for("react.fragment"), Pr = Symbol.for("react.strict_mode"), fh = Symbol.for("react.profiler"), Dv = Symbol.for("react.provider"), hh = Symbol.for("react.consumer"), Ii = Symbol.for("react.context"), qs = Symbol.for("react.forward_ref"), _s = Symbol.for("react.suspense"), Mp = Symbol.for("react.suspense_list"), zp = Symbol.for("react.memo"), yl = Symbol.for("react.lazy"), Qp = Symbol.for("react.activity"), Mv = Symbol.for("react.memo_cache_sentinel"), dh = Symbol.iterator, Gt = Symbol.for("react.client.reference"), zn = Array.isArray, I = H0.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Mt = gS.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, L0 = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), ph = [], Tc = [], Va = -1, Go = ze(null), Wr = ze(null), Xa = ze(null), Np = ze(null), ja = Object.prototype.hasOwnProperty, V0 = gn.unstable_scheduleCallback, zv = gn.unstable_cancelCallback, OS = gn.unstable_shouldYield, vS = gn.unstable_requestPaint, ni = gn.unstable_now, Qv = gn.unstable_getCurrentPriorityLevel, mh = gn.unstable_ImmediatePriority, X0 = gn.unstable_UserBlockingPriority, xc = gn.unstable_NormalPriority, j0 = gn.unstable_LowPriority, G0 = gn.unstable_IdlePriority, ba = gn.log, Y0 = gn.unstable_setDisableYieldValue, Fr = null, ii = null, ke = null, bn = !1, Ll = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Vn = Math.clz32 ? Math.clz32 : ld, Yo = Math.log, bS = Math.LN2, Up = 256, $o = 4194304, Ol = 2, Ga = 8, Zo = 32, Bp = 268435456, Hs = Math.random().toString(36).slice(2), gi = "__reactFiber$" + Hs, el = "__reactProps$" + Hs, Ls = "__reactContainer$" + Hs, qp = "__reactEvents$" + Hs, Ac = "__reactListeners$" + Hs, gh = "__reactHandles$" + Hs, $0 = "__reactResources$" + Hs, yh = "__reactMarker$" + Hs, Kr = /* @__PURE__ */ new Set(), Sa = {}, _p = {}, Hp = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, Z0 = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Lp = {}, Oh = {}, wc = 0, P0, Nv, W0, Ec, Uv, Bv, qv;
    Ma.__reactDisabledLog = !0;
    var Cc, vh, bh = !1, F0 = new (typeof WeakMap == "function" ? WeakMap : Map)(), li = null, Ya = !1, _v = /[\n"\\]/g, K0 = !1, J0 = !1, I0 = !1, Vp = !1, ey = !1, Sh = !1, Hv = ["value", "defaultValue"], Lv = !1, Xp = /["'&<>\n\t]|^\s|\s$/, ty = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), Th = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), ny = Th.concat(["button"]), Vv = "dd dt li option optgroup p rp rt".split(" "), jp = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: !1
    }, Ta = {}, $a = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, Po = /([A-Z])/g, Rc = /^ms-/, xh = /^(?:webkit|moz|o)[A-Z]/, Vs = /^-ms-/, SS = /-(.)/g, iy = /;\s*$/, Za = {}, ly = {}, ay = !1, Ah = !1, oy = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), Gp = "http://www.w3.org/1998/Math/MathML", Wo = "http://www.w3.org/2000/svg", Yp = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), wh = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, kc = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Xs = {}, $p = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Xv = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), jv = !1, Xn = {}, a = /^on./, u = /^on[^A-Z]/, f = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), p = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), v = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, T = null, k = null, D = null, q = !1, P = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ce = !1;
    if (P)
      try {
        var de = {};
        Object.defineProperty(de, "passive", {
          get: function() {
            ce = !0;
          }
        }), window.addEventListener("test", de, de), window.removeEventListener("test", de, de);
      } catch {
        ce = !1;
      }
    var K = null, te = null, Pe = null, $e = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(t) {
        return t.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, zt = In($e), $ = Ie({}, $e, { view: 0, detail: 0 }), j = In($), W, he, Ue, ct = Ie({}, $, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: hi,
      button: 0,
      buttons: 0,
      relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
      },
      movementX: function(t) {
        return "movementX" in t ? t.movementX : (t !== Ue && (Ue && t.type === "mousemove" ? (W = t.screenX - Ue.screenX, he = t.screenY - Ue.screenY) : he = W = 0, Ue = t), W);
      },
      movementY: function(t) {
        return "movementY" in t ? t.movementY : he;
      }
    }), Ye = In(ct), We = Ie({}, ct, { dataTransfer: 0 }), jn = In(We), Ct = Ie({}, $, { relatedTarget: 0 }), Pa = In(Ct), TS = Ie({}, $e, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), yz = In(TS), Oz = Ie({}, $e, {
      clipboardData: function(t) {
        return "clipboardData" in t ? t.clipboardData : window.clipboardData;
      }
    }), vz = In(Oz), bz = Ie({}, $e, { data: 0 }), LA = In(
      bz
    ), Sz = LA, Tz = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, xz = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Az = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, wz = Ie({}, $, {
      key: function(t) {
        if (t.key) {
          var i = Tz[t.key] || t.key;
          if (i !== "Unidentified") return i;
        }
        return t.type === "keypress" ? (t = vr(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? xz[t.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: hi,
      charCode: function(t) {
        return t.type === "keypress" ? vr(t) : 0;
      },
      keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      },
      which: function(t) {
        return t.type === "keypress" ? vr(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
      }
    }), Ez = In(wz), Cz = Ie({}, ct, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), VA = In(Cz), Rz = Ie({}, $, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: hi
    }), kz = In(Rz), Dz = Ie({}, $e, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Mz = In(Dz), zz = Ie({}, ct, {
      deltaX: function(t) {
        return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
      },
      deltaY: function(t) {
        return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Qz = In(zz), Nz = Ie({}, $e, {
      newState: 0,
      oldState: 0
    }), Uz = In(Nz), Bz = [9, 13, 27, 32], XA = 229, xS = P && "CompositionEvent" in window, sy = null;
    P && "documentMode" in document && (sy = document.documentMode);
    var qz = P && "TextEvent" in window && !sy, jA = P && (!xS || sy && 8 < sy && 11 >= sy), GA = 32, YA = String.fromCharCode(GA), $A = !1, Zp = !1, _z = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, ry = null, uy = null, ZA = !1;
    P && (ZA = sg("input") && (!document.documentMode || 9 < document.documentMode));
    var vl = typeof Object.is == "function" ? Object.is : sS, Hz = P && "documentMode" in document && 11 >= document.documentMode, Pp = null, AS = null, cy = null, wS = !1, Wp = {
      animationend: br("Animation", "AnimationEnd"),
      animationiteration: br("Animation", "AnimationIteration"),
      animationstart: br("Animation", "AnimationStart"),
      transitionrun: br("Transition", "TransitionRun"),
      transitionstart: br("Transition", "TransitionStart"),
      transitioncancel: br("Transition", "TransitionCancel"),
      transitionend: br("Transition", "TransitionEnd")
    }, ES = {}, PA = {};
    P && (PA = document.createElement("div").style, "AnimationEvent" in window || (delete Wp.animationend.animation, delete Wp.animationiteration.animation, delete Wp.animationstart.animation), "TransitionEvent" in window || delete Wp.transitionend.transition);
    var WA = Sr("animationend"), FA = Sr("animationiteration"), KA = Sr("animationstart"), Lz = Sr("transitionrun"), Vz = Sr("transitionstart"), Xz = Sr("transitioncancel"), JA = Sr("transitionend"), IA = /* @__PURE__ */ new Map(), CS = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    CS.push("scrollEnd");
    var RS = /* @__PURE__ */ new WeakMap(), kS = 1, Eh = 2, Wa = [], Fp = 0, DS = 0, Dc = {};
    Object.freeze(Dc);
    var Fa = null, Kp = null, on = 0, jz = 1, Ri = 2, tl = 8, Fo = 16, ew = 64, tw = !1;
    try {
      var nw = Object.preventExtensions({});
    } catch {
      tw = !0;
    }
    var Jp = [], Ip = 0, Gv = null, Yv = 0, Ka = [], Ja = 0, Ch = null, Jr = 1, Ir = "", bl = null, En = null, Rt = !1, eu = !1, Ia = null, Rh = null, js = !1, MS = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), iw = 0;
    if (typeof performance == "object" && typeof performance.now == "function")
      var Gz = performance, lw = function() {
        return Gz.now();
      };
    else {
      var Yz = Date;
      lw = function() {
        return Yz.now();
      };
    }
    var zS = ze(null), QS = ze(null), aw = {}, $v = null, em = null, tm = !1, $z = typeof AbortController < "u" ? AbortController : function() {
      var t = [], i = this.signal = {
        aborted: !1,
        addEventListener: function(r, h) {
          t.push(h);
        }
      };
      this.abort = function() {
        i.aborted = !0, t.forEach(function(r) {
          return r();
        });
      };
    }, Zz = gn.unstable_scheduleCallback, Pz = gn.unstable_NormalPriority, ai = {
      $$typeof: Ii,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, nm = gn.unstable_now, ow = -0, Zv = -0, Vl = -1.1, kh = -0, Pv = !1, Wv = !1, fy = null, NS = 0, Dh = 0, im = null, sw = I.S;
    I.S = function(t, i) {
      typeof i == "object" && i !== null && typeof i.then == "function" && KO(t, i), sw !== null && sw(t, i);
    };
    var Mh = ze(null), Ko = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, hy = [], dy = [], py = [], my = [], gy = [], yy = [], zh = /* @__PURE__ */ new Set();
    Ko.recordUnsafeLifecycleWarnings = function(t, i) {
      zh.has(t.type) || (typeof i.componentWillMount == "function" && i.componentWillMount.__suppressDeprecationWarning !== !0 && hy.push(t), t.mode & tl && typeof i.UNSAFE_componentWillMount == "function" && dy.push(t), typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && py.push(t), t.mode & tl && typeof i.UNSAFE_componentWillReceiveProps == "function" && my.push(t), typeof i.componentWillUpdate == "function" && i.componentWillUpdate.__suppressDeprecationWarning !== !0 && gy.push(t), t.mode & tl && typeof i.UNSAFE_componentWillUpdate == "function" && yy.push(t));
    }, Ko.flushPendingUnsafeLifecycleWarnings = function() {
      var t = /* @__PURE__ */ new Set();
      0 < hy.length && (hy.forEach(function(R) {
        t.add(
          Te(R) || "Component"
        ), zh.add(R.type);
      }), hy = []);
      var i = /* @__PURE__ */ new Set();
      0 < dy.length && (dy.forEach(function(R) {
        i.add(
          Te(R) || "Component"
        ), zh.add(R.type);
      }), dy = []);
      var r = /* @__PURE__ */ new Set();
      0 < py.length && (py.forEach(function(R) {
        r.add(
          Te(R) || "Component"
        ), zh.add(R.type);
      }), py = []);
      var h = /* @__PURE__ */ new Set();
      0 < my.length && (my.forEach(
        function(R) {
          h.add(
            Te(R) || "Component"
          ), zh.add(R.type);
        }
      ), my = []);
      var g = /* @__PURE__ */ new Set();
      0 < gy.length && (gy.forEach(function(R) {
        g.add(
          Te(R) || "Component"
        ), zh.add(R.type);
      }), gy = []);
      var O = /* @__PURE__ */ new Set();
      if (0 < yy.length && (yy.forEach(function(R) {
        O.add(
          Te(R) || "Component"
        ), zh.add(R.type);
      }), yy = []), 0 < i.size) {
        var x = w(
          i
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          x
        );
      }
      0 < h.size && (x = w(
        h
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        x
      )), 0 < O.size && (x = w(
        O
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        x
      )), 0 < t.size && (x = w(t), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        x
      )), 0 < r.size && (x = w(
        r
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        x
      )), 0 < g.size && (x = w(g), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        x
      ));
    };
    var Fv = /* @__PURE__ */ new Map(), rw = /* @__PURE__ */ new Set();
    Ko.recordLegacyContextWarning = function(t, i) {
      for (var r = null, h = t; h !== null; )
        h.mode & tl && (r = h), h = h.return;
      r === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !rw.has(t.type) && (h = Fv.get(r), t.type.contextTypes != null || t.type.childContextTypes != null || i !== null && typeof i.getChildContext == "function") && (h === void 0 && (h = [], Fv.set(r, h)), h.push(t));
    }, Ko.flushLegacyContextWarning = function() {
      Fv.forEach(function(t) {
        if (t.length !== 0) {
          var i = t[0], r = /* @__PURE__ */ new Set();
          t.forEach(function(g) {
            r.add(Te(g) || "Component"), rw.add(g.type);
          });
          var h = w(r);
          Ge(i, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              h
            );
          });
        }
      });
    }, Ko.discardPendingWarnings = function() {
      hy = [], dy = [], py = [], my = [], gy = [], yy = [], Fv = /* @__PURE__ */ new Map();
    };
    var Oy = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    ), uw = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), Kv = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
    ), US = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, vy = null, Jv = !1, eo = 0, to = 1, Sl = 2, ki = 4, oi = 8, cw = 0, fw = 1, hw = 2, BS = 3, Mc = !1, dw = !1, qS = null, _S = !1, lm = ze(null), Iv = ze(0), am, pw = /* @__PURE__ */ new Set(), mw = /* @__PURE__ */ new Set(), HS = /* @__PURE__ */ new Set(), gw = /* @__PURE__ */ new Set(), zc = 0, et = null, Pt = null, Gn = null, eb = !1, om = !1, Qh = !1, tb = 0, by = 0, tu = null, Wz = 0, Fz = 25, ae = null, no = null, nu = -1, Sy = !1, nb = {
      readContext: Wt,
      use: hn,
      useCallback: Zt,
      useContext: Zt,
      useEffect: Zt,
      useImperativeHandle: Zt,
      useLayoutEffect: Zt,
      useInsertionEffect: Zt,
      useMemo: Zt,
      useReducer: Zt,
      useRef: Zt,
      useState: Zt,
      useDebugValue: Zt,
      useDeferredValue: Zt,
      useTransition: Zt,
      useSyncExternalStore: Zt,
      useId: Zt,
      useHostTransitionStatus: Zt,
      useFormState: Zt,
      useActionState: Zt,
      useOptimistic: Zt,
      useMemoCache: Zt,
      useCacheRefresh: Zt
    }, LS = null, yw = null, VS = null, Ow = null, Gs = null, Jo = null, ib = null;
    LS = {
      readContext: function(t) {
        return Wt(t);
      },
      use: hn,
      useCallback: function(t, i) {
        return ae = "useCallback", rt(), gs(i), $u(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", rt(), Wt(t);
      },
      useEffect: function(t, i) {
        return ae = "useEffect", rt(), gs(i), zf(t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", rt(), gs(r), Ro(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        ae = "useInsertionEffect", rt(), gs(i), Ql(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", rt(), gs(i), kg(t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", rt(), gs(i);
        var r = I.H;
        I.H = Gs;
        try {
          return zr(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", rt();
        var h = I.H;
        I.H = Gs;
        try {
          return Eo(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function(t) {
        return ae = "useRef", rt(), bs(t);
      },
      useState: function(t) {
        ae = "useState", rt();
        var i = I.H;
        I.H = Gs;
        try {
          return ra(t);
        } finally {
          I.H = i;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", rt();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", rt(), Zu(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", rt(), Uf();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", rt(), Qd(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", rt(), Qr();
      },
      useFormState: function(t, i) {
        return ae = "useFormState", rt(), qu(), ju(t, i);
      },
      useActionState: function(t, i) {
        return ae = "useActionState", rt(), ju(t, i);
      },
      useOptimistic: function(t) {
        return ae = "useOptimistic", rt(), Ua(t);
      },
      useHostTransitionStatus: Xi,
      useMemoCache: Lt,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", rt(), Bf();
      }
    }, yw = {
      readContext: function(t) {
        return Wt(t);
      },
      use: hn,
      useCallback: function(t, i) {
        return ae = "useCallback", be(), $u(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", be(), Wt(t);
      },
      useEffect: function(t, i) {
        return ae = "useEffect", be(), zf(t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", be(), Ro(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        ae = "useInsertionEffect", be(), Ql(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", be(), kg(t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", be();
        var r = I.H;
        I.H = Gs;
        try {
          return zr(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", be();
        var h = I.H;
        I.H = Gs;
        try {
          return Eo(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function(t) {
        return ae = "useRef", be(), bs(t);
      },
      useState: function(t) {
        ae = "useState", be();
        var i = I.H;
        I.H = Gs;
        try {
          return ra(t);
        } finally {
          I.H = i;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", be();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", be(), Zu(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", be(), Uf();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", be(), Qd(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", be(), Qr();
      },
      useActionState: function(t, i) {
        return ae = "useActionState", be(), ju(t, i);
      },
      useFormState: function(t, i) {
        return ae = "useFormState", be(), qu(), ju(t, i);
      },
      useOptimistic: function(t) {
        return ae = "useOptimistic", be(), Ua(t);
      },
      useHostTransitionStatus: Xi,
      useMemoCache: Lt,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", be(), Bf();
      }
    }, VS = {
      readContext: function(t) {
        return Wt(t);
      },
      use: hn,
      useCallback: function(t, i) {
        return ae = "useCallback", be(), Qf(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", be(), Wt(t);
      },
      useEffect: function(t, i) {
        ae = "useEffect", be(), Vi(2048, oi, t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", be(), Yu(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        return ae = "useInsertionEffect", be(), Vi(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", be(), Vi(4, ki, t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", be();
        var r = I.H;
        I.H = Jo;
        try {
          return Nf(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", be();
        var h = I.H;
        I.H = Jo;
        try {
          return wi(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function() {
        return ae = "useRef", be(), Bt().memoizedState;
      },
      useState: function() {
        ae = "useState", be();
        var t = I.H;
        I.H = Jo;
        try {
          return wi(ut);
        } finally {
          I.H = t;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", be();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", be(), _d(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", be(), Ld();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", be(), kf(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", be(), Bt().memoizedState;
      },
      useFormState: function(t) {
        return ae = "useFormState", be(), qu(), qd(t);
      },
      useActionState: function(t) {
        return ae = "useActionState", be(), qd(t);
      },
      useOptimistic: function(t, i) {
        return ae = "useOptimistic", be(), Ba(t, i);
      },
      useHostTransitionStatus: Xi,
      useMemoCache: Lt,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", be(), Bt().memoizedState;
      }
    }, Ow = {
      readContext: function(t) {
        return Wt(t);
      },
      use: hn,
      useCallback: function(t, i) {
        return ae = "useCallback", be(), Qf(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", be(), Wt(t);
      },
      useEffect: function(t, i) {
        ae = "useEffect", be(), Vi(2048, oi, t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", be(), Yu(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        return ae = "useInsertionEffect", be(), Vi(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", be(), Vi(4, ki, t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", be();
        var r = I.H;
        I.H = ib;
        try {
          return Nf(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", be();
        var h = I.H;
        I.H = ib;
        try {
          return sa(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function() {
        return ae = "useRef", be(), Bt().memoizedState;
      },
      useState: function() {
        ae = "useState", be();
        var t = I.H;
        I.H = ib;
        try {
          return sa(ut);
        } finally {
          I.H = t;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", be();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", be(), Mg(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", be(), Do();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", be(), kf(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", be(), Bt().memoizedState;
      },
      useFormState: function(t) {
        return ae = "useFormState", be(), qu(), vs(t);
      },
      useActionState: function(t) {
        return ae = "useActionState", be(), vs(t);
      },
      useOptimistic: function(t, i) {
        return ae = "useOptimistic", be(), Bd(t, i);
      },
      useHostTransitionStatus: Xi,
      useMemoCache: Lt,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", be(), Bt().memoizedState;
      }
    }, Gs = {
      readContext: function(t) {
        return S(), Wt(t);
      },
      use: function(t) {
        return b(), hn(t);
      },
      useCallback: function(t, i) {
        return ae = "useCallback", b(), rt(), $u(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", b(), rt(), Wt(t);
      },
      useEffect: function(t, i) {
        return ae = "useEffect", b(), rt(), zf(t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", b(), rt(), Ro(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        ae = "useInsertionEffect", b(), rt(), Ql(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", b(), rt(), kg(t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", b(), rt();
        var r = I.H;
        I.H = Gs;
        try {
          return zr(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", b(), rt();
        var h = I.H;
        I.H = Gs;
        try {
          return Eo(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function(t) {
        return ae = "useRef", b(), rt(), bs(t);
      },
      useState: function(t) {
        ae = "useState", b(), rt();
        var i = I.H;
        I.H = Gs;
        try {
          return ra(t);
        } finally {
          I.H = i;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", b(), rt();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", b(), rt(), Zu(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", b(), rt(), Uf();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", b(), rt(), Qd(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", b(), rt(), Qr();
      },
      useFormState: function(t, i) {
        return ae = "useFormState", b(), rt(), ju(t, i);
      },
      useActionState: function(t, i) {
        return ae = "useActionState", b(), rt(), ju(t, i);
      },
      useOptimistic: function(t) {
        return ae = "useOptimistic", b(), rt(), Ua(t);
      },
      useMemoCache: function(t) {
        return b(), Lt(t);
      },
      useHostTransitionStatus: Xi,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", rt(), Bf();
      }
    }, Jo = {
      readContext: function(t) {
        return S(), Wt(t);
      },
      use: function(t) {
        return b(), hn(t);
      },
      useCallback: function(t, i) {
        return ae = "useCallback", b(), be(), Qf(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", b(), be(), Wt(t);
      },
      useEffect: function(t, i) {
        ae = "useEffect", b(), be(), Vi(2048, oi, t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", b(), be(), Yu(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        return ae = "useInsertionEffect", b(), be(), Vi(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", b(), be(), Vi(4, ki, t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", b(), be();
        var r = I.H;
        I.H = Jo;
        try {
          return Nf(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", b(), be();
        var h = I.H;
        I.H = Jo;
        try {
          return wi(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function() {
        return ae = "useRef", b(), be(), Bt().memoizedState;
      },
      useState: function() {
        ae = "useState", b(), be();
        var t = I.H;
        I.H = Jo;
        try {
          return wi(ut);
        } finally {
          I.H = t;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", b(), be();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", b(), be(), _d(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", b(), be(), Ld();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", b(), be(), kf(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", b(), be(), Bt().memoizedState;
      },
      useFormState: function(t) {
        return ae = "useFormState", b(), be(), qd(t);
      },
      useActionState: function(t) {
        return ae = "useActionState", b(), be(), qd(t);
      },
      useOptimistic: function(t, i) {
        return ae = "useOptimistic", b(), be(), Ba(t, i);
      },
      useMemoCache: function(t) {
        return b(), Lt(t);
      },
      useHostTransitionStatus: Xi,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", be(), Bt().memoizedState;
      }
    }, ib = {
      readContext: function(t) {
        return S(), Wt(t);
      },
      use: function(t) {
        return b(), hn(t);
      },
      useCallback: function(t, i) {
        return ae = "useCallback", b(), be(), Qf(t, i);
      },
      useContext: function(t) {
        return ae = "useContext", b(), be(), Wt(t);
      },
      useEffect: function(t, i) {
        ae = "useEffect", b(), be(), Vi(2048, oi, t, i);
      },
      useImperativeHandle: function(t, i, r) {
        return ae = "useImperativeHandle", b(), be(), Yu(t, i, r);
      },
      useInsertionEffect: function(t, i) {
        return ae = "useInsertionEffect", b(), be(), Vi(4, Sl, t, i);
      },
      useLayoutEffect: function(t, i) {
        return ae = "useLayoutEffect", b(), be(), Vi(4, ki, t, i);
      },
      useMemo: function(t, i) {
        ae = "useMemo", b(), be();
        var r = I.H;
        I.H = Jo;
        try {
          return Nf(t, i);
        } finally {
          I.H = r;
        }
      },
      useReducer: function(t, i, r) {
        ae = "useReducer", b(), be();
        var h = I.H;
        I.H = Jo;
        try {
          return sa(t, i, r);
        } finally {
          I.H = h;
        }
      },
      useRef: function() {
        return ae = "useRef", b(), be(), Bt().memoizedState;
      },
      useState: function() {
        ae = "useState", b(), be();
        var t = I.H;
        I.H = Jo;
        try {
          return sa(ut);
        } finally {
          I.H = t;
        }
      },
      useDebugValue: function() {
        ae = "useDebugValue", b(), be();
      },
      useDeferredValue: function(t, i) {
        return ae = "useDeferredValue", b(), be(), Mg(t, i);
      },
      useTransition: function() {
        return ae = "useTransition", b(), be(), Do();
      },
      useSyncExternalStore: function(t, i, r) {
        return ae = "useSyncExternalStore", b(), be(), kf(
          t,
          i,
          r
        );
      },
      useId: function() {
        return ae = "useId", b(), be(), Bt().memoizedState;
      },
      useFormState: function(t) {
        return ae = "useFormState", b(), be(), vs(t);
      },
      useActionState: function(t) {
        return ae = "useActionState", b(), be(), vs(t);
      },
      useOptimistic: function(t, i) {
        return ae = "useOptimistic", b(), be(), Bd(t, i);
      },
      useMemoCache: function(t) {
        return b(), Lt(t);
      },
      useHostTransitionStatus: Xi,
      useCacheRefresh: function() {
        return ae = "useCacheRefresh", be(), Bt().memoizedState;
      }
    };
    var vw = {
      "react-stack-bottom-frame": function(t, i, r) {
        var h = Ya;
        Ya = !0;
        try {
          return t(i, r);
        } finally {
          Ya = h;
        }
      }
    }, XS = vw["react-stack-bottom-frame"].bind(vw), bw = {
      "react-stack-bottom-frame": function(t) {
        var i = Ya;
        Ya = !0;
        try {
          return t.render();
        } finally {
          Ya = i;
        }
      }
    }, Sw = bw["react-stack-bottom-frame"].bind(bw), Tw = {
      "react-stack-bottom-frame": function(t, i) {
        try {
          i.componentDidMount();
        } catch (r) {
          Vt(t, t.return, r);
        }
      }
    }, jS = Tw["react-stack-bottom-frame"].bind(Tw), xw = {
      "react-stack-bottom-frame": function(t, i, r, h, g) {
        try {
          i.componentDidUpdate(r, h, g);
        } catch (O) {
          Vt(t, t.return, O);
        }
      }
    }, Aw = xw["react-stack-bottom-frame"].bind(xw), ww = {
      "react-stack-bottom-frame": function(t, i) {
        var r = i.stack;
        t.componentDidCatch(i.value, {
          componentStack: r !== null ? r : ""
        });
      }
    }, Kz = ww["react-stack-bottom-frame"].bind(ww), Ew = {
      "react-stack-bottom-frame": function(t, i, r) {
        try {
          r.componentWillUnmount();
        } catch (h) {
          Vt(t, i, h);
        }
      }
    }, Cw = Ew["react-stack-bottom-frame"].bind(Ew), Rw = {
      "react-stack-bottom-frame": function(t) {
        t.resourceKind != null && console.error(
          "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
          t.resourceKind
        );
        var i = t.create;
        return t = t.inst, i = i(), t.destroy = i;
      }
    }, Jz = Rw["react-stack-bottom-frame"].bind(Rw), kw = {
      "react-stack-bottom-frame": function(t, i, r) {
        try {
          r();
        } catch (h) {
          Vt(t, i, h);
        }
      }
    }, Iz = kw["react-stack-bottom-frame"].bind(kw), Dw = {
      "react-stack-bottom-frame": function(t) {
        var i = t._init;
        return i(t._payload);
      }
    }, Qc = Dw["react-stack-bottom-frame"].bind(Dw), sm = null, Ty = 0, dt = null, GS, Mw = GS = !1, zw = {}, Qw = {}, Nw = {};
    y = function(t, i, r) {
      if (r !== null && typeof r == "object" && r._store && (!r._store.validated && r.key == null || r._store.validated === 2)) {
        if (typeof r._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        r._store.validated = 1;
        var h = Te(t), g = h || "null";
        if (!zw[g]) {
          zw[g] = !0, r = r._owner, t = t._debugOwner;
          var O = "";
          t && typeof t.tag == "number" && (g = Te(t)) && (O = `

Check the render method of \`` + g + "`."), O || h && (O = `

Check the top-level render call using <` + h + ">.");
          var x = "";
          r != null && t !== r && (h = null, typeof r.tag == "number" ? h = Te(r) : typeof r.name == "string" && (h = r.name), h && (x = " It was passed a child from " + h + ".")), Ge(i, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              O,
              x
            );
          });
        }
      }
    };
    var rm = Ur(!0), Uw = Ur(!1), io = ze(null), Ys = null, um = 1, xy = 2, si = ze(0), Bw = {}, qw = /* @__PURE__ */ new Set(), _w = /* @__PURE__ */ new Set(), Hw = /* @__PURE__ */ new Set(), Lw = /* @__PURE__ */ new Set(), Vw = /* @__PURE__ */ new Set(), Xw = /* @__PURE__ */ new Set(), jw = /* @__PURE__ */ new Set(), Gw = /* @__PURE__ */ new Set(), Yw = /* @__PURE__ */ new Set(), $w = /* @__PURE__ */ new Set();
    Object.freeze(Bw);
    var YS = {
      enqueueSetState: function(t, i, r) {
        t = t._reactInternals;
        var h = dl(t), g = na(h);
        g.payload = i, r != null && (un(r), g.callback = r), i = ia(t, g, h), i !== null && (mt(i, t, h), kr(i, t, h)), Da(t, h);
      },
      enqueueReplaceState: function(t, i, r) {
        t = t._reactInternals;
        var h = dl(t), g = na(h);
        g.tag = fw, g.payload = i, r != null && (un(r), g.callback = r), i = ia(t, g, h), i !== null && (mt(i, t, h), kr(i, t, h)), Da(t, h);
      },
      enqueueForceUpdate: function(t, i) {
        t = t._reactInternals;
        var r = dl(t), h = na(r);
        h.tag = hw, i != null && (un(i), h.callback = i), i = ia(t, h, r), i !== null && (mt(i, t, r), kr(i, t, r)), ke !== null && typeof ke.markForceUpdateScheduled == "function" && ke.markForceUpdateScheduled(t, r);
      }
    }, $S = typeof reportError == "function" ? reportError : function(t) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var i = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof t == "object" && t !== null && typeof t.message == "string" ? String(t.message) : String(t),
          error: t
        });
        if (!window.dispatchEvent(i)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", t);
        return;
      }
      console.error(t);
    }, cm = null, ZS = null, Zw = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), yi = !1, Pw = {}, Ww = {}, Fw = {}, Kw = {}, fm = !1, Jw = {}, PS = {}, WS = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, Iw = !1, eE = null;
    eE = /* @__PURE__ */ new Set();
    var iu = !1, Qn = !1, FS = !1, tE = typeof WeakSet == "function" ? WeakSet : Set, Oi = null, hm = null, dm = null, Yn = null, Xl = !1, Io = null, Ay = 8192, e3 = {
      getCacheForType: function(t) {
        var i = Wt(ai), r = i.data.get(t);
        return r === void 0 && (r = t(), i.data.set(t, r)), r;
      },
      getOwner: function() {
        return li;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var wy = Symbol.for;
      wy("selector.component"), wy("selector.has_pseudo_class"), wy("selector.role"), wy("selector.test_id"), wy("selector.text");
    }
    var t3 = [], n3 = typeof WeakMap == "function" ? WeakMap : Map, xa = 0, Tl = 2, es = 4, lu = 0, Ey = 1, pm = 2, KS = 3, Nh = 4, lb = 6, nE = 5, Ht = xa, It = null, Ot = null, vt = 0, jl = 0, Cy = 1, Uh = 2, Ry = 3, iE = 4, JS = 5, mm = 6, ky = 7, IS = 8, Bh = 9, Yt = jl, Aa = null, Nc = !1, gm = !1, eT = !1, $s = 0, Cn = lu, Uc = 0, Bc = 0, tT = 0, wa = 0, qh = 0, Dy = null, xl = null, ab = !1, nT = 0, lE = 300, ob = 1 / 0, aE = 500, My = null, qc = null, i3 = 0, l3 = 1, a3 = 2, _h = 0, oE = 1, sE = 2, rE = 3, o3 = 4, iT = 5, Di = 0, _c = null, ym = null, Hc = 0, lT = 0, aT = null, uE = null, s3 = 50, zy = 0, oT = null, sT = !1, sb = !1, r3 = 50, Hh = 0, Qy = null, Om = !1, rb = null, cE = !1, fE = /* @__PURE__ */ new Set(), u3 = {}, ub = null, vm = null, rT = !1, uT = !1, cb = !1, cT = !1, Lh = 0, fT = {};
    (function() {
      for (var t = 0; t < CS.length; t++) {
        var i = CS[t], r = i.toLowerCase();
        i = i[0].toUpperCase() + i.slice(1), Il(r, "on" + i);
      }
      Il(WA, "onAnimationEnd"), Il(FA, "onAnimationIteration"), Il(KA, "onAnimationStart"), Il("dblclick", "onDoubleClick"), Il("focusin", "onFocus"), Il("focusout", "onBlur"), Il(Lz, "onTransitionRun"), Il(Vz, "onTransitionStart"), Il(Xz, "onTransitionCancel"), Il(JA, "onTransitionEnd");
    })(), Ee("onMouseEnter", ["mouseout", "mouseover"]), Ee("onMouseLeave", ["mouseout", "mouseover"]), Ee("onPointerEnter", ["pointerout", "pointerover"]), Ee("onPointerLeave", ["pointerout", "pointerover"]), xe(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), xe(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), xe("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), xe(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), xe(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), xe(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var Ny = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), hT = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ny)
    ), fb = "_reactListening" + Math.random().toString(36).slice(2), hE = !1, dE = !1, hb = !1, pE = !1, db = !1, pb = !1, mE = !1, mb = {}, c3 = /\r\n?/g, f3 = /\u0000|\uFFFD/g, Vh = "http://www.w3.org/1999/xlink", dT = "http://www.w3.org/XML/1998/namespace", h3 = "javascript:throw new Error('React form unexpectedly submitted.')", d3 = "suppressHydrationWarning", gb = "$", yb = "/$", au = "$?", Uy = "$!", p3 = 1, m3 = 2, g3 = 4, pT = "F!", gE = "F", yE = "complete", y3 = "style", ou = 0, bm = 1, Ob = 2, mT = null, gT = null, OE = { dialog: !0, webview: !0 }, yT = null, vE = typeof setTimeout == "function" ? setTimeout : void 0, O3 = typeof clearTimeout == "function" ? clearTimeout : void 0, Xh = -1, bE = typeof Promise == "function" ? Promise : void 0, v3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof bE < "u" ? function(t) {
      return bE.resolve(null).then(t).catch(Lo);
    } : vE, OT = null, jh = 0, By = 1, SE = 2, TE = 3, lo = 4, ao = /* @__PURE__ */ new Map(), xE = /* @__PURE__ */ new Set(), su = Mt.d;
    Mt.d = {
      f: function() {
        var t = su.f(), i = Vr();
        return t || i;
      },
      r: function(t) {
        var i = Ui(t);
        i !== null && i.tag === 5 && i.type === "form" ? ko(i) : su.r(t);
      },
      D: function(t) {
        su.D(t), Vo("dns-prefetch", t, null);
      },
      C: function(t, i) {
        su.C(t, i), Vo("preconnect", t, i);
      },
      L: function(t, i, r) {
        su.L(t, i, r);
        var h = Sm;
        if (h && t && i) {
          var g = 'link[rel="preload"][as="' + qn(i) + '"]';
          i === "image" && r && r.imageSrcSet ? (g += '[imagesrcset="' + qn(
            r.imageSrcSet
          ) + '"]', typeof r.imageSizes == "string" && (g += '[imagesizes="' + qn(
            r.imageSizes
          ) + '"]')) : g += '[href="' + qn(t) + '"]';
          var O = g;
          switch (i) {
            case "style":
              O = Oa(t);
              break;
            case "script":
              O = Ns(t);
          }
          ao.has(O) || (t = Ie(
            {
              rel: "preload",
              href: i === "image" && r && r.imageSrcSet ? void 0 : t,
              as: i
            },
            r
          ), ao.set(O, t), h.querySelector(g) !== null || i === "style" && h.querySelector(
            Oc(O)
          ) || i === "script" && h.querySelector($r(O)) || (i = h.createElement("link"), Ln(i, "link", t), Y(i), h.head.appendChild(i)));
        }
      },
      m: function(t, i) {
        su.m(t, i);
        var r = Sm;
        if (r && t) {
          var h = i && typeof i.as == "string" ? i.as : "script", g = 'link[rel="modulepreload"][as="' + qn(h) + '"][href="' + qn(t) + '"]', O = g;
          switch (h) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              O = Ns(t);
          }
          if (!ao.has(O) && (t = Ie({ rel: "modulepreload", href: t }, i), ao.set(O, t), r.querySelector(g) === null)) {
            switch (h) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (r.querySelector($r(O)))
                  return;
            }
            h = r.createElement("link"), Ln(h, "link", t), Y(h), r.head.appendChild(h);
          }
        }
      },
      X: function(t, i) {
        su.X(t, i);
        var r = Sm;
        if (r && t) {
          var h = M(r).hoistableScripts, g = Ns(t), O = h.get(g);
          O || (O = r.querySelector(
            $r(g)
          ), O || (t = Ie({ src: t, async: !0 }, i), (i = ao.get(g)) && bp(t, i), O = r.createElement("script"), Y(O), Ln(O, "link", t), r.head.appendChild(O)), O = {
            type: "script",
            instance: O,
            count: 1,
            state: null
          }, h.set(g, O));
        }
      },
      S: function(t, i, r) {
        su.S(t, i, r);
        var h = Sm;
        if (h && t) {
          var g = M(h).hoistableStyles, O = Oa(t);
          i = i || "default";
          var x = g.get(O);
          if (!x) {
            var R = { loading: jh, preload: null };
            if (x = h.querySelector(
              Oc(O)
            ))
              R.loading = By | lo;
            else {
              t = Ie(
                {
                  rel: "stylesheet",
                  href: t,
                  "data-precedence": i
                },
                r
              ), (r = ao.get(O)) && Q0(t, r);
              var Q = x = h.createElement("link");
              Y(Q), Ln(Q, "link", t), Q._p = new Promise(function(N, ee) {
                Q.onload = N, Q.onerror = ee;
              }), Q.addEventListener("load", function() {
                R.loading |= By;
              }), Q.addEventListener("error", function() {
                R.loading |= SE;
              }), R.loading |= lo, vp(x, i, h);
            }
            x = {
              type: "stylesheet",
              instance: x,
              count: 1,
              state: R
            }, g.set(O, x);
          }
        }
      },
      M: function(t, i) {
        su.M(t, i);
        var r = Sm;
        if (r && t) {
          var h = M(r).hoistableScripts, g = Ns(t), O = h.get(g);
          O || (O = r.querySelector(
            $r(g)
          ), O || (t = Ie({ src: t, async: !0, type: "module" }, i), (i = ao.get(g)) && bp(t, i), O = r.createElement("script"), Y(O), Ln(O, "link", t), r.head.appendChild(O)), O = {
            type: "script",
            instance: O,
            count: 1,
            state: null
          }, h.set(g, O));
        }
      }
    };
    var Sm = typeof document > "u" ? null : document, vb = null, qy = null, vT = null, bb = null, Gh = L0, _y = {
      $$typeof: Ii,
      Provider: null,
      Consumer: null,
      _currentValue: Gh,
      _currentValue2: Gh,
      _threadCount: 0
    }, AE = "%c%s%c ", wE = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", EE = "", Sb = " ", b3 = Function.prototype.bind, CE = !1, RE = null, kE = null, DE = null, ME = null, zE = null, QE = null, NE = null, UE = null, BE = null;
    RE = function(t, i, r, h) {
      i = e(t, i), i !== null && (r = n(i.memoizedState, r, 0, h), i.memoizedState = r, i.baseState = r, t.memoizedProps = Ie({}, t.memoizedProps), r = qi(t, 2), r !== null && mt(r, t, 2));
    }, kE = function(t, i, r) {
      i = e(t, i), i !== null && (r = c(i.memoizedState, r, 0), i.memoizedState = r, i.baseState = r, t.memoizedProps = Ie({}, t.memoizedProps), r = qi(t, 2), r !== null && mt(r, t, 2));
    }, DE = function(t, i, r, h) {
      i = e(t, i), i !== null && (r = l(i.memoizedState, r, h), i.memoizedState = r, i.baseState = r, t.memoizedProps = Ie({}, t.memoizedProps), r = qi(t, 2), r !== null && mt(r, t, 2));
    }, ME = function(t, i, r) {
      t.pendingProps = n(t.memoizedProps, i, 0, r), t.alternate && (t.alternate.pendingProps = t.pendingProps), i = qi(t, 2), i !== null && mt(i, t, 2);
    }, zE = function(t, i) {
      t.pendingProps = c(t.memoizedProps, i, 0), t.alternate && (t.alternate.pendingProps = t.pendingProps), i = qi(t, 2), i !== null && mt(i, t, 2);
    }, QE = function(t, i, r) {
      t.pendingProps = l(
        t.memoizedProps,
        i,
        r
      ), t.alternate && (t.alternate.pendingProps = t.pendingProps), i = qi(t, 2), i !== null && mt(i, t, 2);
    }, NE = function(t) {
      var i = qi(t, 2);
      i !== null && mt(i, t, 2);
    }, UE = function(t) {
      m = t;
    }, BE = function(t) {
      d = t;
    };
    var Tb = !0, xb = null, bT = !1, Lc = null, Vc = null, Xc = null, Hy = /* @__PURE__ */ new Map(), Ly = /* @__PURE__ */ new Map(), jc = [], S3 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), Ab = null;
    if (kp.prototype.render = Rp.prototype.render = function(t) {
      var i = this._internalRoot;
      if (i === null) throw Error("Cannot update an unmounted root.");
      var r = arguments;
      typeof r[1] == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : G(r[1]) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof r[1] < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), r = t;
      var h = i.current, g = dl(h);
      sh(h, g, r, i, null, null);
    }, kp.prototype.unmount = Rp.prototype.unmount = function() {
      var t = arguments;
      if (typeof t[0] == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), t = this._internalRoot, t !== null) {
        this._internalRoot = null;
        var i = t.containerInfo;
        (Ht & (Tl | es)) !== xa && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), sh(t.current, 2, null, t, null, null), Vr(), i[Ls] = null;
      }
    }, kp.prototype.unstable_scheduleHydration = function(t) {
      if (t) {
        var i = sf();
        t = { blockedOn: null, target: t, priority: i };
        for (var r = 0; r < jc.length && i !== 0 && i < jc[r].priority; r++) ;
        jc.splice(r, 0, t), r === 0 && q0(t);
      }
    }, function() {
      var t = H0.version;
      if (t !== "19.1.0")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (t + `
  - react-dom:  19.1.0
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    }(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), Mt.findDOMNode = function(t) {
      var i = t._reactInternals;
      if (i === void 0)
        throw typeof t.render == "function" ? Error("Unable to find node on an unmounted component.") : (t = Object.keys(t).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + t
        ));
      return t = ne(i), t = t !== null ? ye(t) : null, t = t === null ? null : t.stateNode, t;
    }, !function() {
      var t = {
        bundleType: 1,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: I,
        reconcilerVersion: "19.1.0"
      };
      return t.overrideHookState = RE, t.overrideHookStateDeletePath = kE, t.overrideHookStateRenamePath = DE, t.overrideProps = ME, t.overridePropsDeletePath = zE, t.overridePropsRenamePath = QE, t.scheduleUpdate = NE, t.setErrorHandler = UE, t.setSuspenseHandler = BE, t.scheduleRefresh = U, t.scheduleRoot = z, t.setRefreshHandler = V, t.getCurrentFiber = dS, t.getLaneLabelMap = pS, t.injectProfilingHooks = Nt, Ne(t);
    }() && P && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var qE = window.location.protocol;
      /^(https?|file):$/.test(qE) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (qE === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    Xy.createRoot = function(t, i) {
      if (!G(t))
        throw Error("Target container is not a DOM element.");
      Dp(t);
      var r = !1, h = "", g = IO, O = Gd, x = Yd, R = null;
      return i != null && (i.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof i == "object" && i !== null && i.$$typeof === jo && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), i.unstable_strictMode === !0 && (r = !0), i.identifierPrefix !== void 0 && (h = i.identifierPrefix), i.onUncaughtError !== void 0 && (g = i.onUncaughtError), i.onCaughtError !== void 0 && (O = i.onCaughtError), i.onRecoverableError !== void 0 && (x = i.onRecoverableError), i.unstable_transitionCallbacks !== void 0 && (R = i.unstable_transitionCallbacks)), i = B0(
        t,
        1,
        !1,
        null,
        null,
        r,
        h,
        g,
        O,
        x,
        R,
        null
      ), t[Ls] = i.current, nh(t), new Rp(i);
    }, Xy.hydrateRoot = function(t, i, r) {
      if (!G(t))
        throw Error("Target container is not a DOM element.");
      Dp(t), i === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var h = !1, g = "", O = IO, x = Gd, R = Yd, Q = null, N = null;
      return r != null && (r.unstable_strictMode === !0 && (h = !0), r.identifierPrefix !== void 0 && (g = r.identifierPrefix), r.onUncaughtError !== void 0 && (O = r.onUncaughtError), r.onCaughtError !== void 0 && (x = r.onCaughtError), r.onRecoverableError !== void 0 && (R = r.onRecoverableError), r.unstable_transitionCallbacks !== void 0 && (Q = r.unstable_transitionCallbacks), r.formState !== void 0 && (N = r.formState)), i = B0(
        t,
        1,
        !0,
        i,
        r ?? null,
        h,
        g,
        O,
        x,
        R,
        Q,
        N
      ), i.context = jt(null), r = i.current, h = dl(r), h = El(h), g = na(h), g.callback = null, ia(r, g, h), r = h, i.current.lanes = r, as(i, r), ql(i), t[Ls] = i.current, nh(t), new kp(i);
    }, Xy.version = "19.1.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }(), Xy;
}
var WE;
function Q3() {
  if (WE) return Eb.exports;
  WE = 1;
  var o = {};
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (o.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (n) {
        console.error(n);
      }
    }
  }
  return o.NODE_ENV === "production" ? (e(), Eb.exports = M3()) : Eb.exports = z3(), Eb.exports;
}
var N3 = Q3(), kb = { exports: {} }, jy = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FE;
function U3() {
  if (FE) return jy;
  FE = 1;
  var o = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function n(l, s, c) {
    var d = null;
    if (c !== void 0 && (d = "" + c), s.key !== void 0 && (d = "" + s.key), "key" in s) {
      c = {};
      for (var m in s)
        m !== "key" && (c[m] = s[m]);
    } else c = s;
    return s = c.ref, {
      $$typeof: o,
      type: l,
      key: d,
      ref: s !== void 0 ? s : null,
      props: c
    };
  }
  return jy.Fragment = e, jy.jsx = n, jy.jsxs = n, jy;
}
var Gy = {}, KE;
function B3() {
  if (KE) return Gy;
  KE = 1;
  var o = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return o.NODE_ENV !== "production" && function() {
    function e(L) {
      if (L == null) return null;
      if (typeof L == "function")
        return L.$$typeof === ze ? null : L.displayName || L.name || null;
      if (typeof L == "string") return L;
      switch (L) {
        case V:
          return "Fragment";
        case ie:
          return "Profiler";
        case G:
          return "StrictMode";
        case ye:
          return "Suspense";
        case Oe:
          return "SuspenseList";
        case Te:
          return "Activity";
      }
      if (typeof L == "object")
        switch (typeof L.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), L.$$typeof) {
          case U:
            return "Portal";
          case pe:
            return (L.displayName || "Context") + ".Provider";
          case me:
            return (L._context.displayName || "Context") + ".Consumer";
          case ne:
            var se = L.render;
            return L = L.displayName, L || (L = se.displayName || se.name || "", L = L !== "" ? "ForwardRef(" + L + ")" : "ForwardRef"), L;
          case we:
            return se = L.displayName || null, se !== null ? se : e(L.type) || "Memo";
          case Re:
            se = L._payload, L = L._init;
            try {
              return e(L(se));
            } catch {
            }
        }
      return null;
    }
    function n(L) {
      return "" + L;
    }
    function l(L) {
      try {
        n(L);
        var se = !1;
      } catch {
        se = !0;
      }
      if (se) {
        se = console;
        var le = se.error, Ae = typeof Symbol == "function" && Symbol.toStringTag && L[Symbol.toStringTag] || L.constructor.name || "Object";
        return le.call(
          se,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          Ae
        ), n(L);
      }
    }
    function s(L) {
      if (L === V) return "<>";
      if (typeof L == "object" && L !== null && L.$$typeof === Re)
        return "<...>";
      try {
        var se = e(L);
        return se ? "<" + se + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function c() {
      var L = fe.A;
      return L === null ? null : L.getOwner();
    }
    function d() {
      return Error("react-stack-top-frame");
    }
    function m(L) {
      if (Qe.call(L, "key")) {
        var se = Object.getOwnPropertyDescriptor(L, "key").get;
        if (se && se.isReactWarning) return !1;
      }
      return L.key !== void 0;
    }
    function y(L, se) {
      function le() {
        F || (F = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          se
        ));
      }
      le.isReactWarning = !0, Object.defineProperty(L, "key", {
        get: le,
        configurable: !0
      });
    }
    function b() {
      var L = e(this.type);
      return Z[L] || (Z[L] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), L = this.props.ref, L !== void 0 ? L : null;
    }
    function S(L, se, le, Ae, je, Ne, Ke, Nt) {
      return le = Ne.ref, L = {
        $$typeof: z,
        type: L,
        key: se,
        props: Ne,
        _owner: je
      }, (le !== void 0 ? le : null) !== null ? Object.defineProperty(L, "ref", {
        enumerable: !1,
        get: b
      }) : Object.defineProperty(L, "ref", { enumerable: !1, value: null }), L._store = {}, Object.defineProperty(L._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(L, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(L, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Ke
      }), Object.defineProperty(L, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Nt
      }), Object.freeze && (Object.freeze(L.props), Object.freeze(L)), L;
    }
    function A(L, se, le, Ae, je, Ne, Ke, Nt) {
      var Ut = se.children;
      if (Ut !== void 0)
        if (Ae)
          if (Ve(Ut)) {
            for (Ae = 0; Ae < Ut.length; Ae++)
              w(Ut[Ae]);
            Object.freeze && Object.freeze(Ut);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else w(Ut);
      if (Qe.call(se, "key")) {
        Ut = e(L);
        var Rn = Object.keys(se).filter(function(ho) {
          return ho !== "key";
        });
        Ae = 0 < Rn.length ? "{key: someKey, " + Rn.join(": ..., ") + ": ...}" : "{key: someKey}", B[Ut + Ae] || (Rn = 0 < Rn.length ? "{" + Rn.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          Ae,
          Ut,
          Rn,
          Ut
        ), B[Ut + Ae] = !0);
      }
      if (Ut = null, le !== void 0 && (l(le), Ut = "" + le), m(se) && (l(se.key), Ut = "" + se.key), "key" in se) {
        le = {};
        for (var Ti in se)
          Ti !== "key" && (le[Ti] = se[Ti]);
      } else le = se;
      return Ut && y(
        le,
        typeof L == "function" ? L.displayName || L.name || "Unknown" : L
      ), S(
        L,
        Ut,
        Ne,
        je,
        c(),
        le,
        Ke,
        Nt
      );
    }
    function w(L) {
      typeof L == "object" && L !== null && L.$$typeof === z && L._store && (L._store.validated = 1);
    }
    var E = Xm(), z = Symbol.for("react.transitional.element"), U = Symbol.for("react.portal"), V = Symbol.for("react.fragment"), G = Symbol.for("react.strict_mode"), ie = Symbol.for("react.profiler"), me = Symbol.for("react.consumer"), pe = Symbol.for("react.context"), ne = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), Oe = Symbol.for("react.suspense_list"), we = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), Te = Symbol.for("react.activity"), ze = Symbol.for("react.client.reference"), fe = E.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Qe = Object.prototype.hasOwnProperty, Ve = Array.isArray, Xe = console.createTask ? console.createTask : function() {
      return null;
    };
    E = {
      "react-stack-bottom-frame": function(L) {
        return L();
      }
    };
    var F, Z = {}, ge = E["react-stack-bottom-frame"].bind(
      E,
      d
    )(), Se = Xe(s(d)), B = {};
    Gy.Fragment = V, Gy.jsx = function(L, se, le, Ae, je) {
      var Ne = 1e4 > fe.recentlyCreatedOwnerStacks++;
      return A(
        L,
        se,
        le,
        !1,
        Ae,
        je,
        Ne ? Error("react-stack-top-frame") : ge,
        Ne ? Xe(s(L)) : Se
      );
    }, Gy.jsxs = function(L, se, le, Ae, je) {
      var Ne = 1e4 > fe.recentlyCreatedOwnerStacks++;
      return A(
        L,
        se,
        le,
        !0,
        Ae,
        je,
        Ne ? Error("react-stack-top-frame") : ge,
        Ne ? Xe(s(L)) : Se
      );
    };
  }(), Gy;
}
var JE;
function q3() {
  if (JE) return kb.exports;
  JE = 1;
  var o = {};
  return o.NODE_ENV === "production" ? kb.exports = U3() : kb.exports = B3(), kb.exports;
}
var Ks = q3();
function ix() {
  return ix = Object.assign ? Object.assign.bind() : function(o) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var l in n) ({}).hasOwnProperty.call(n, l) && (o[l] = n[l]);
    }
    return o;
  }, ix.apply(null, arguments);
}
function _3(o, e) {
  if (o == null) return {};
  var n = {};
  for (var l in o) if ({}.hasOwnProperty.call(o, l)) {
    if (e.indexOf(l) !== -1) continue;
    n[l] = o[l];
  }
  return n;
}
let lx = [], sk = [];
(() => {
  let o = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, n = 0; e < o.length; e++)
    (e % 2 ? sk : lx).push(n = n + o[e]);
})();
function H3(o) {
  if (o < 768) return !1;
  for (let e = 0, n = lx.length; ; ) {
    let l = e + n >> 1;
    if (o < lx[l]) n = l;
    else if (o >= sk[l]) e = l + 1;
    else return !0;
    if (e == n) return !1;
  }
}
function IE(o) {
  return o >= 127462 && o <= 127487;
}
const eC = 8205;
function L3(o, e, n = !0, l = !0) {
  return (n ? rk : V3)(o, e, l);
}
function rk(o, e, n) {
  if (e == o.length) return e;
  e && uk(o.charCodeAt(e)) && ck(o.charCodeAt(e - 1)) && e--;
  let l = xT(o, e);
  for (e += tC(l); e < o.length; ) {
    let s = xT(o, e);
    if (l == eC || s == eC || n && H3(s))
      e += tC(s), l = s;
    else if (IE(s)) {
      let c = 0, d = e - 2;
      for (; d >= 0 && IE(xT(o, d)); )
        c++, d -= 2;
      if (c % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function V3(o, e, n) {
  for (; e > 0; ) {
    let l = rk(o, e - 2, n);
    if (l < e) return l;
    e--;
  }
  return 0;
}
function xT(o, e) {
  let n = o.charCodeAt(e);
  if (!ck(n) || e + 1 == o.length) return n;
  let l = o.charCodeAt(e + 1);
  return uk(l) ? (n - 55296 << 10) + (l - 56320) + 65536 : n;
}
function uk(o) {
  return o >= 56320 && o < 57344;
}
function ck(o) {
  return o >= 55296 && o < 56320;
}
function tC(o) {
  return o < 65536 ? 1 : 2;
}
class kt {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, n, l) {
    [e, n] = Nm(this, e, n);
    let s = [];
    return this.decompose(
      0,
      e,
      s,
      2
      /* Open.To */
    ), l.length && l.decompose(
      0,
      l.length,
      s,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      s,
      1
      /* Open.From */
    ), Js.from(s, this.length - (n - e) + l.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, n = this.length) {
    [e, n] = Nm(this, e, n);
    let l = [];
    return this.decompose(e, n, l, 0), Js.from(l, n - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), l = this.length - this.scanIdentical(e, -1), s = new iO(this), c = new iO(e);
    for (let d = n, m = n; ; ) {
      if (s.next(d), c.next(d), d = 0, s.lineBreak != c.lineBreak || s.done != c.done || s.value != c.value)
        return !1;
      if (m += s.value.length, s.done || m >= l)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new iO(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, n = this.length) {
    return new fk(this, e, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.

  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, n) {
    let l;
    if (e == null)
      l = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let s = this.line(e).from;
      l = this.iterRange(s, Math.max(s, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new hk(l);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? kt.empty : e.length <= 32 ? new Un(e) : Js.from(Un.split(e, []));
  }
}
class Un extends kt {
  constructor(e, n = X3(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, l, s) {
    for (let c = 0; ; c++) {
      let d = this.text[c], m = s + d.length;
      if ((n ? l : m) >= e)
        return new j3(s, m, l, d);
      s = m + 1, l++;
    }
  }
  decompose(e, n, l, s) {
    let c = e <= 0 && n >= this.length ? this : new Un(nC(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (s & 1) {
      let d = l.pop(), m = t1(c.text, d.text.slice(), 0, c.length);
      if (m.length <= 32)
        l.push(new Un(m, d.length + c.length));
      else {
        let y = m.length >> 1;
        l.push(new Un(m.slice(0, y)), new Un(m.slice(y)));
      }
    } else
      l.push(c);
  }
  replace(e, n, l) {
    if (!(l instanceof Un))
      return super.replace(e, n, l);
    [e, n] = Nm(this, e, n);
    let s = t1(this.text, t1(l.text, nC(this.text, 0, e)), n), c = this.length + l.length - (n - e);
    return s.length <= 32 ? new Un(s, c) : Js.from(Un.split(s, []), c);
  }
  sliceString(e, n = this.length, l = `
`) {
    [e, n] = Nm(this, e, n);
    let s = "";
    for (let c = 0, d = 0; c <= n && d < this.text.length; d++) {
      let m = this.text[d], y = c + m.length;
      c > e && d && (s += l), e < y && n > c && (s += m.slice(Math.max(0, e - c), n - c)), c = y + 1;
    }
    return s;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let l = [], s = -1;
    for (let c of e)
      l.push(c), s += c.length + 1, l.length == 32 && (n.push(new Un(l, s)), l = [], s = -1);
    return s > -1 && n.push(new Un(l, s)), n;
  }
}
class Js extends kt {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let l of e)
      this.lines += l.lines;
  }
  lineInner(e, n, l, s) {
    for (let c = 0; ; c++) {
      let d = this.children[c], m = s + d.length, y = l + d.lines - 1;
      if ((n ? y : m) >= e)
        return d.lineInner(e, n, l, s);
      s = m + 1, l = y + 1;
    }
  }
  decompose(e, n, l, s) {
    for (let c = 0, d = 0; d <= n && c < this.children.length; c++) {
      let m = this.children[c], y = d + m.length;
      if (e <= y && n >= d) {
        let b = s & ((d <= e ? 1 : 0) | (y >= n ? 2 : 0));
        d >= e && y <= n && !b ? l.push(m) : m.decompose(e - d, n - d, l, b);
      }
      d = y + 1;
    }
  }
  replace(e, n, l) {
    if ([e, n] = Nm(this, e, n), l.lines < this.lines)
      for (let s = 0, c = 0; s < this.children.length; s++) {
        let d = this.children[s], m = c + d.length;
        if (e >= c && n <= m) {
          let y = d.replace(e - c, n - c, l), b = this.lines - d.lines + y.lines;
          if (y.lines < b >> 4 && y.lines > b >> 6) {
            let S = this.children.slice();
            return S[s] = y, new Js(S, this.length - (n - e) + l.length);
          }
          return super.replace(c, m, y);
        }
        c = m + 1;
      }
    return super.replace(e, n, l);
  }
  sliceString(e, n = this.length, l = `
`) {
    [e, n] = Nm(this, e, n);
    let s = "";
    for (let c = 0, d = 0; c < this.children.length && d <= n; c++) {
      let m = this.children[c], y = d + m.length;
      d > e && c && (s += l), e < y && n > d && (s += m.sliceString(e - d, n - d, l)), d = y + 1;
    }
    return s;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Js))
      return 0;
    let l = 0, [s, c, d, m] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; s += n, c += n) {
      if (s == d || c == m)
        return l;
      let y = this.children[s], b = e.children[c];
      if (y != b)
        return l + y.scanIdentical(b, n);
      l += y.length + 1;
    }
  }
  static from(e, n = e.reduce((l, s) => l + s.length + 1, -1)) {
    let l = 0;
    for (let E of e)
      l += E.lines;
    if (l < 32) {
      let E = [];
      for (let z of e)
        z.flatten(E);
      return new Un(E, n);
    }
    let s = Math.max(
      32,
      l >> 5
      /* Tree.BranchShift */
    ), c = s << 1, d = s >> 1, m = [], y = 0, b = -1, S = [];
    function A(E) {
      let z;
      if (E.lines > c && E instanceof Js)
        for (let U of E.children)
          A(U);
      else E.lines > d && (y > d || !y) ? (w(), m.push(E)) : E instanceof Un && y && (z = S[S.length - 1]) instanceof Un && E.lines + z.lines <= 32 ? (y += E.lines, b += E.length + 1, S[S.length - 1] = new Un(z.text.concat(E.text), z.length + 1 + E.length)) : (y + E.lines > s && w(), y += E.lines, b += E.length + 1, S.push(E));
    }
    function w() {
      y != 0 && (m.push(S.length == 1 ? S[0] : Js.from(S, b)), b = -1, y = S.length = 0);
    }
    for (let E of e)
      A(E);
    return w(), m.length == 1 ? m[0] : new Js(m, n);
  }
}
kt.empty = /* @__PURE__ */ new Un([""], 0);
function X3(o) {
  let e = -1;
  for (let n of o)
    e += n.length + 1;
  return e;
}
function t1(o, e, n = 0, l = 1e9) {
  for (let s = 0, c = 0, d = !0; c < o.length && s <= l; c++) {
    let m = o[c], y = s + m.length;
    y >= n && (y > l && (m = m.slice(0, l - s)), s < n && (m = m.slice(n - s)), d ? (e[e.length - 1] += m, d = !1) : e.push(m)), s = y + 1;
  }
  return e;
}
function nC(o, e, n) {
  return t1(o, [""], e, n);
}
class iO {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof Un ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let l = this.nodes.length - 1, s = this.nodes[l], c = this.offsets[l], d = c >> 1, m = s instanceof Un ? s.text.length : s.children.length;
      if (d == (n > 0 ? m : 0)) {
        if (l == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[l - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((c & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[l] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (s instanceof Un) {
        let y = s.text[d + (n < 0 ? -1 : 0)];
        if (this.offsets[l] += n, y.length > Math.max(0, e))
          return this.value = e == 0 ? y : n > 0 ? y.slice(e) : y.slice(0, y.length - e), this;
        e -= y.length;
      } else {
        let y = s.children[d + (n < 0 ? -1 : 0)];
        e > y.length ? (e -= y.length, this.offsets[l] += n) : (n < 0 && this.offsets[l]--, this.nodes.push(y), this.offsets.push(n > 0 ? 1 : (y instanceof Un ? y.text.length : y.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class fk {
  constructor(e, n, l) {
    this.value = "", this.done = !1, this.cursor = new iO(e, n > l ? -1 : 1), this.pos = n > l ? e.length : 0, this.from = Math.min(n, l), this.to = Math.max(n, l);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let l = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > l && (e = l), l -= e;
    let { value: s } = this.cursor.next(e);
    return this.pos += (s.length + e) * n, this.value = s.length <= l ? s : n < 0 ? s.slice(s.length - l) : s.slice(0, l), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class hk {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: l, value: s } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : l ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (kt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, iO.prototype[Symbol.iterator] = fk.prototype[Symbol.iterator] = hk.prototype[Symbol.iterator] = function() {
  return this;
});
class j3 {
  /**
  @internal
  */
  constructor(e, n, l, s) {
    this.from = e, this.to = n, this.number = l, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Nm(o, e, n) {
  return e = Math.max(0, Math.min(o.length, e)), [e, Math.max(e, Math.min(o.length, n))];
}
function Ni(o, e, n = !0, l = !0) {
  return L3(o, e, n, l);
}
function G3(o) {
  return o >= 56320 && o < 57344;
}
function Y3(o) {
  return o >= 55296 && o < 56320;
}
function Gl(o, e) {
  let n = o.charCodeAt(e);
  if (!Y3(n) || e + 1 == o.length)
    return n;
  let l = o.charCodeAt(e + 1);
  return G3(l) ? (n - 55296 << 10) + (l - 56320) + 65536 : n;
}
function eA(o) {
  return o <= 65535 ? String.fromCharCode(o) : (o -= 65536, String.fromCharCode((o >> 10) + 55296, (o & 1023) + 56320));
}
function Is(o) {
  return o < 65536 ? 1 : 2;
}
const ax = /\r\n?|\n/;
var Qi = /* @__PURE__ */ function(o) {
  return o[o.Simple = 0] = "Simple", o[o.TrackDel = 1] = "TrackDel", o[o.TrackBefore = 2] = "TrackBefore", o[o.TrackAfter = 3] = "TrackAfter", o;
}(Qi || (Qi = {}));
class lr {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let l = this.sections[n + 1];
      e += l < 0 ? this.sections[n] : l;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let n = 0, l = 0, s = 0; n < this.sections.length; ) {
      let c = this.sections[n++], d = this.sections[n++];
      d < 0 ? (e(l, s, c), s += c) : s += d, l += c;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.

  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, n = !1) {
    ox(this, e, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let l = this.sections[n++], s = this.sections[n++];
      s < 0 ? e.push(l, s) : e.push(s, l);
    }
    return new lr(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : dk(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, n = !1) {
    return e.empty ? this : sx(this, e, n);
  }
  mapPos(e, n = -1, l = Qi.Simple) {
    let s = 0, c = 0;
    for (let d = 0; d < this.sections.length; ) {
      let m = this.sections[d++], y = this.sections[d++], b = s + m;
      if (y < 0) {
        if (b > e)
          return c + (e - s);
        c += m;
      } else {
        if (l != Qi.Simple && b >= e && (l == Qi.TrackDel && s < e && b > e || l == Qi.TrackBefore && s < e || l == Qi.TrackAfter && b > e))
          return null;
        if (b > e || b == e && n < 0 && !m)
          return e == s || n < 0 ? c : c + y;
        c += y;
      }
      s = b;
    }
    if (e > s)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);
    return c;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, n = e) {
    for (let l = 0, s = 0; l < this.sections.length && s <= n; ) {
      let c = this.sections[l++], d = this.sections[l++], m = s + c;
      if (d >= 0 && s <= n && m >= e)
        return s < e && m > n ? "cover" : !0;
      s = m;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let l = this.sections[n++], s = this.sections[n++];
      e += (e ? " " : "") + l + (s >= 0 ? ":" + s : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new lr(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new lr(e);
  }
}
class ri extends lr {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return ox(this, (n, l, s, c, d) => e = e.replace(s, s + (l - n), d), !1), e;
  }
  mapDesc(e, n = !1) {
    return sx(this, e, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let n = this.sections.slice(), l = [];
    for (let s = 0, c = 0; s < n.length; s += 2) {
      let d = n[s], m = n[s + 1];
      if (m >= 0) {
        n[s] = m, n[s + 1] = d;
        let y = s >> 1;
        for (; l.length < y; )
          l.push(kt.empty);
        l.push(d ? e.slice(c, c + d) : kt.empty);
      }
      c += d;
    }
    return new ri(n, l);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : dk(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.

  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, n = !1) {
    return e.empty ? this : sx(this, e, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).

  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, n = !1) {
    ox(this, e, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return lr.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let n = [], l = [], s = [], c = new uO(this);
    e: for (let d = 0, m = 0; ; ) {
      let y = d == e.length ? 1e9 : e[d++];
      for (; m < y || m == y && c.len == 0; ) {
        if (c.done)
          break e;
        let S = Math.min(c.len, y - m);
        ll(s, S, -1);
        let A = c.ins == -1 ? -1 : c.off == 0 ? c.ins : 0;
        ll(n, S, A), A > 0 && Zc(l, n, c.text), c.forward(S), m += S;
      }
      let b = e[d++];
      for (; m < b; ) {
        if (c.done)
          break e;
        let S = Math.min(c.len, b - m);
        ll(n, S, -1), ll(s, S, c.ins == -1 ? -1 : c.off == 0 ? c.ins : 0), c.forward(S), m += S;
      }
    }
    return {
      changes: new ri(n, l),
      filtered: lr.create(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let l = this.sections[n], s = this.sections[n + 1];
      s < 0 ? e.push(l) : s == 0 ? e.push([l]) : e.push([l].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, n, l) {
    let s = [], c = [], d = 0, m = null;
    function y(S = !1) {
      if (!S && !s.length)
        return;
      d < n && ll(s, n - d, -1);
      let A = new ri(s, c);
      m = m ? m.compose(A.map(m)) : A, s = [], c = [], d = 0;
    }
    function b(S) {
      if (Array.isArray(S))
        for (let A of S)
          b(A);
      else if (S instanceof ri) {
        if (S.length != n)
          throw new RangeError(`Mismatched change set length (got ${S.length}, expected ${n})`);
        y(), m = m ? m.compose(S.map(m)) : S;
      } else {
        let { from: A, to: w = A, insert: E } = S;
        if (A > w || A < 0 || w > n)
          throw new RangeError(`Invalid change range ${A} to ${w} (in doc of length ${n})`);
        let z = E ? typeof E == "string" ? kt.of(E.split(l || ax)) : E : kt.empty, U = z.length;
        if (A == w && U == 0)
          return;
        A < d && y(), A > d && ll(s, A - d, -1), ll(s, w - A, U), Zc(c, s, z), d = w;
      }
    }
    return b(e), y(!m), m;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ri(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], l = [];
    for (let s = 0; s < e.length; s++) {
      let c = e[s];
      if (typeof c == "number")
        n.push(c, -1);
      else {
        if (!Array.isArray(c) || typeof c[0] != "number" || c.some((d, m) => m && typeof d != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (c.length == 1)
          n.push(c[0], 0);
        else {
          for (; l.length < s; )
            l.push(kt.empty);
          l[s] = kt.of(c.slice(1)), n.push(c[0], l[s].length);
        }
      }
    }
    return new ri(n, l);
  }
  /**
  @internal
  */
  static createSet(e, n) {
    return new ri(e, n);
  }
}
function ll(o, e, n, l = !1) {
  if (e == 0 && n <= 0)
    return;
  let s = o.length - 2;
  s >= 0 && n <= 0 && n == o[s + 1] ? o[s] += e : s >= 0 && e == 0 && o[s] == 0 ? o[s + 1] += n : l ? (o[s] += e, o[s + 1] += n) : o.push(e, n);
}
function Zc(o, e, n) {
  if (n.length == 0)
    return;
  let l = e.length - 2 >> 1;
  if (l < o.length)
    o[o.length - 1] = o[o.length - 1].append(n);
  else {
    for (; o.length < l; )
      o.push(kt.empty);
    o.push(n);
  }
}
function ox(o, e, n) {
  let l = o.inserted;
  for (let s = 0, c = 0, d = 0; d < o.sections.length; ) {
    let m = o.sections[d++], y = o.sections[d++];
    if (y < 0)
      s += m, c += m;
    else {
      let b = s, S = c, A = kt.empty;
      for (; b += m, S += y, y && l && (A = A.append(l[d - 2 >> 1])), !(n || d == o.sections.length || o.sections[d + 1] < 0); )
        m = o.sections[d++], y = o.sections[d++];
      e(s, b, c, S, A), s = b, c = S;
    }
  }
}
function sx(o, e, n, l = !1) {
  let s = [], c = l ? [] : null, d = new uO(o), m = new uO(e);
  for (let y = -1; ; ) {
    if (d.done && m.len || m.done && d.len)
      throw new Error("Mismatched change set lengths");
    if (d.ins == -1 && m.ins == -1) {
      let b = Math.min(d.len, m.len);
      ll(s, b, -1), d.forward(b), m.forward(b);
    } else if (m.ins >= 0 && (d.ins < 0 || y == d.i || d.off == 0 && (m.len < d.len || m.len == d.len && !n))) {
      let b = m.len;
      for (ll(s, m.ins, -1); b; ) {
        let S = Math.min(d.len, b);
        d.ins >= 0 && y < d.i && d.len <= S && (ll(s, 0, d.ins), c && Zc(c, s, d.text), y = d.i), d.forward(S), b -= S;
      }
      m.next();
    } else if (d.ins >= 0) {
      let b = 0, S = d.len;
      for (; S; )
        if (m.ins == -1) {
          let A = Math.min(S, m.len);
          b += A, S -= A, m.forward(A);
        } else if (m.ins == 0 && m.len < S)
          S -= m.len, m.next();
        else
          break;
      ll(s, b, y < d.i ? d.ins : 0), c && y < d.i && Zc(c, s, d.text), y = d.i, d.forward(d.len - S);
    } else {
      if (d.done && m.done)
        return c ? ri.createSet(s, c) : lr.create(s);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function dk(o, e, n = !1) {
  let l = [], s = n ? [] : null, c = new uO(o), d = new uO(e);
  for (let m = !1; ; ) {
    if (c.done && d.done)
      return s ? ri.createSet(l, s) : lr.create(l);
    if (c.ins == 0)
      ll(l, c.len, 0, m), c.next();
    else if (d.len == 0 && !d.done)
      ll(l, 0, d.ins, m), s && Zc(s, l, d.text), d.next();
    else {
      if (c.done || d.done)
        throw new Error("Mismatched change set lengths");
      {
        let y = Math.min(c.len2, d.len), b = l.length;
        if (c.ins == -1) {
          let S = d.ins == -1 ? -1 : d.off ? 0 : d.ins;
          ll(l, y, S, m), s && S && Zc(s, l, d.text);
        } else d.ins == -1 ? (ll(l, c.off ? 0 : c.len, y, m), s && Zc(s, l, c.textBit(y))) : (ll(l, c.off ? 0 : c.len, d.off ? 0 : d.ins, m), s && !d.off && Zc(s, l, d.text));
        m = (c.ins > y || d.ins >= 0 && d.len > y) && (m || l.length > b), c.forward2(y), d.forward(y);
      }
    }
  }
}
class uO {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? kt.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, l = this.i - 2 >> 1;
    return l >= n.length && !e ? kt.empty : n[l].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Ph {
  constructor(e, n, l) {
    this.from = e, this.to = n, this.flags = l;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, n = -1) {
    let l, s;
    return this.empty ? l = s = e.mapPos(this.from, n) : (l = e.mapPos(this.from, 1), s = e.mapPos(this.to, -1)), l == this.from && s == this.to ? this : new Ph(l, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return ve.range(e, n);
    let l = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return ve.range(this.anchor, l);
  }
  /**
  Compare this range to another range.
  */
  eq(e, n = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ve.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, n, l) {
    return new Ph(e, n, l);
  }
}
class ve {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, n = -1) {
    return e.empty ? this : ve.create(this.ranges.map((l) => l.map(e, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, n = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let l = 0; l < this.ranges.length; l++)
      if (!this.ranges[l].eq(e.ranges[l], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ve([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, n = !0) {
    return ve.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, n = this.mainIndex) {
    let l = this.ranges.slice();
    return l[n] = e, ve.create(l, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ve(e.ranges.map((n) => Ph.fromJSON(n)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, n = e) {
    return new ve([ve.range(e, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let l = 0, s = 0; s < e.length; s++) {
      let c = e[s];
      if (c.empty ? c.from <= l : c.from < l)
        return ve.normalized(e.slice(), n);
      l = c.to;
    }
    return new ve(e, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, n = 0, l, s) {
    return Ph.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (l == null ? 7 : Math.min(6, l)) | (s ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, n, l, s) {
    let c = (l ?? 16777215) << 6 | (s == null ? 7 : Math.min(6, s));
    return n < e ? Ph.create(n, e, 48 | c) : Ph.create(e, n, (n > e ? 8 : 0) | c);
  }
  /**
  @internal
  */
  static normalized(e, n = 0) {
    let l = e[n];
    e.sort((s, c) => s.from - c.from), n = e.indexOf(l);
    for (let s = 1; s < e.length; s++) {
      let c = e[s], d = e[s - 1];
      if (c.empty ? c.from <= d.to : c.from < d.to) {
        let m = d.from, y = Math.max(c.to, d.to);
        s <= n && n--, e.splice(--s, 2, c.anchor > c.head ? ve.range(y, m) : ve.range(m, y));
      }
    }
    return new ve(e, n);
  }
}
function pk(o, e) {
  for (let n of o.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let tA = 0;
class Be {
  constructor(e, n, l, s, c) {
    this.combine = e, this.compareInput = n, this.compare = l, this.isStatic = s, this.id = tA++, this.default = e([]), this.extensions = typeof c == "function" ? c(this) : c;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Be(e.combine || ((n) => n), e.compareInput || ((n, l) => n === l), e.compare || (e.combine ? (n, l) => n === l : nA), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new n1([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.

  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new n1(e, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new n1(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (l) => l), this.compute([e], (l) => n(l.field(e)));
  }
}
function nA(o, e) {
  return o == e || o.length == e.length && o.every((n, l) => n === e[l]);
}
class n1 {
  constructor(e, n, l, s) {
    this.dependencies = e, this.facet = n, this.type = l, this.value = s, this.id = tA++;
  }
  dynamicSlot(e) {
    var n;
    let l = this.value, s = this.facet.compareInput, c = this.id, d = e[c] >> 1, m = this.type == 2, y = !1, b = !1, S = [];
    for (let A of this.dependencies)
      A == "doc" ? y = !0 : A == "selection" ? b = !0 : (((n = e[A.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && S.push(e[A.id]);
    return {
      create(A) {
        return A.values[d] = l(A), 1;
      },
      update(A, w) {
        if (y && w.docChanged || b && (w.docChanged || w.selection) || rx(A, S)) {
          let E = l(A);
          if (m ? !iC(E, A.values[d], s) : !s(E, A.values[d]))
            return A.values[d] = E, 1;
        }
        return 0;
      },
      reconfigure: (A, w) => {
        let E, z = w.config.address[c];
        if (z != null) {
          let U = g1(w, z);
          if (this.dependencies.every((V) => V instanceof Be ? w.facet(V) === A.facet(V) : V instanceof Si ? w.field(V, !1) == A.field(V, !1) : !0) || (m ? iC(E = l(A), U, s) : s(E = l(A), U)))
            return A.values[d] = U, 0;
        } else
          E = l(A);
        return A.values[d] = E, 1;
      }
    };
  }
}
function iC(o, e, n) {
  if (o.length != e.length)
    return !1;
  for (let l = 0; l < o.length; l++)
    if (!n(o[l], e[l]))
      return !1;
  return !0;
}
function rx(o, e) {
  let n = !1;
  for (let l of e)
    lO(o, l) & 1 && (n = !0);
  return n;
}
function $3(o, e, n) {
  let l = n.map((y) => o[y.id]), s = n.map((y) => y.type), c = l.filter((y) => !(y & 1)), d = o[e.id] >> 1;
  function m(y) {
    let b = [];
    for (let S = 0; S < l.length; S++) {
      let A = g1(y, l[S]);
      if (s[S] == 2)
        for (let w of A)
          b.push(w);
      else
        b.push(A);
    }
    return e.combine(b);
  }
  return {
    create(y) {
      for (let b of l)
        lO(y, b);
      return y.values[d] = m(y), 1;
    },
    update(y, b) {
      if (!rx(y, c))
        return 0;
      let S = m(y);
      return e.compare(S, y.values[d]) ? 0 : (y.values[d] = S, 1);
    },
    reconfigure(y, b) {
      let S = rx(y, l), A = b.config.facets[e.id], w = b.facet(e);
      if (A && !S && nA(n, A))
        return y.values[d] = w, 0;
      let E = m(y);
      return e.compare(E, w) ? (y.values[d] = w, 0) : (y.values[d] = E, 1);
    }
  };
}
const Db = /* @__PURE__ */ Be.define({ static: !0 });
class Si {
  constructor(e, n, l, s, c) {
    this.id = e, this.createF = n, this.updateF = l, this.compareF = s, this.spec = c, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let n = new Si(tA++, e.create, e.update, e.compare || ((l, s) => l === s), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(Db).find((l) => l.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (l) => (l.values[n] = this.create(l), 1),
      update: (l, s) => {
        let c = l.values[n], d = this.updateF(c, s);
        return this.compareF(c, d) ? 0 : (l.values[n] = d, 1);
      },
      reconfigure: (l, s) => {
        let c = l.facet(Db), d = s.facet(Db), m;
        return (m = c.find((y) => y.field == this)) && m != d.find((y) => y.field == this) ? (l.values[n] = m.create(l), 1) : s.config.address[this.id] != null ? (l.values[n] = s.field(this), 0) : (l.values[n] = this.create(l), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Db.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const $h = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Yy(o) {
  return (e) => new mk(e, o);
}
const nf = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Yy($h.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Yy($h.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Yy($h.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Yy($h.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Yy($h.lowest)
};
class mk {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class X1 {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new ux(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return X1.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class ux {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class m1 {
  constructor(e, n, l, s, c, d) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = l, this.address = s, this.staticValues = c, this.facets = d, this.statusTemplate = []; this.statusTemplate.length < l.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, l) {
    let s = [], c = /* @__PURE__ */ Object.create(null), d = /* @__PURE__ */ new Map();
    for (let w of Z3(e, n, d))
      w instanceof Si ? s.push(w) : (c[w.facet.id] || (c[w.facet.id] = [])).push(w);
    let m = /* @__PURE__ */ Object.create(null), y = [], b = [];
    for (let w of s)
      m[w.id] = b.length << 1, b.push((E) => w.slot(E));
    let S = l == null ? void 0 : l.config.facets;
    for (let w in c) {
      let E = c[w], z = E[0].facet, U = S && S[w] || [];
      if (E.every(
        (V) => V.type == 0
        /* Provider.Static */
      ))
        if (m[z.id] = y.length << 1 | 1, nA(U, E))
          y.push(l.facet(z));
        else {
          let V = z.combine(E.map((G) => G.value));
          y.push(l && z.compare(V, l.facet(z)) ? l.facet(z) : V);
        }
      else {
        for (let V of E)
          V.type == 0 ? (m[V.id] = y.length << 1 | 1, y.push(V.value)) : (m[V.id] = b.length << 1, b.push((G) => V.dynamicSlot(G)));
        m[z.id] = b.length << 1, b.push((V) => $3(V, z, E));
      }
    }
    let A = b.map((w) => w(m));
    return new m1(e, d, A, m, y, c);
  }
}
function Z3(o, e, n) {
  let l = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function c(d, m) {
    let y = s.get(d);
    if (y != null) {
      if (y <= m)
        return;
      let b = l[y].indexOf(d);
      b > -1 && l[y].splice(b, 1), d instanceof ux && n.delete(d.compartment);
    }
    if (s.set(d, m), Array.isArray(d))
      for (let b of d)
        c(b, m);
    else if (d instanceof ux) {
      if (n.has(d.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let b = e.get(d.compartment) || d.inner;
      n.set(d.compartment, b), c(b, m);
    } else if (d instanceof mk)
      c(d.inner, d.prec);
    else if (d instanceof Si)
      l[m].push(d), d.provides && c(d.provides, m);
    else if (d instanceof n1)
      l[m].push(d), d.facet.extensions && c(d.facet.extensions, $h.default);
    else {
      let b = d.extension;
      if (!b)
        throw new Error(`Unrecognized extension value in extension set (${d}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      c(b, m);
    }
  }
  return c(o, $h.default), l.reduce((d, m) => d.concat(m));
}
function lO(o, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, l = o.status[n];
  if (l == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (l & 2)
    return l;
  o.status[n] = 4;
  let s = o.computeSlot(o, o.config.dynamicSlots[n]);
  return o.status[n] = 2 | s;
}
function g1(o, e) {
  return e & 1 ? o.config.staticValues[e >> 1] : o.values[e >> 1];
}
const gk = /* @__PURE__ */ Be.define(), cx = /* @__PURE__ */ Be.define({
  combine: (o) => o.some((e) => e),
  static: !0
}), yk = /* @__PURE__ */ Be.define({
  combine: (o) => o.length ? o[0] : void 0,
  static: !0
}), Ok = /* @__PURE__ */ Be.define(), vk = /* @__PURE__ */ Be.define(), bk = /* @__PURE__ */ Be.define(), Sk = /* @__PURE__ */ Be.define({
  combine: (o) => o.length ? o[0] : !1
});
class or {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new P3();
  }
}
class P3 {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new or(this, e);
  }
}
class W3 {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new it(this, e);
  }
}
class it {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new it(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new W3(e.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let l = [];
    for (let s of e) {
      let c = s.map(n);
      c && l.push(c);
    }
    return l;
  }
}
it.reconfigure = /* @__PURE__ */ it.define();
it.appendConfig = /* @__PURE__ */ it.define();
class Pn {
  constructor(e, n, l, s, c, d) {
    this.startState = e, this.changes = n, this.selection = l, this.effects = s, this.annotations = c, this.scrollIntoView = d, this._doc = null, this._state = null, l && pk(l, n.newLength), c.some((m) => m.type == Pn.time) || (this.annotations = c.concat(Pn.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, n, l, s, c, d) {
    return new Pn(e, n, l, s, c, d);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let n = this.annotation(Pn.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
Pn.time = /* @__PURE__ */ or.define();
Pn.userEvent = /* @__PURE__ */ or.define();
Pn.addToHistory = /* @__PURE__ */ or.define();
Pn.remote = /* @__PURE__ */ or.define();
function F3(o, e) {
  let n = [];
  for (let l = 0, s = 0; ; ) {
    let c, d;
    if (l < o.length && (s == e.length || e[s] >= o[l]))
      c = o[l++], d = o[l++];
    else if (s < e.length)
      c = e[s++], d = e[s++];
    else
      return n;
    !n.length || n[n.length - 1] < c ? n.push(c, d) : n[n.length - 1] < d && (n[n.length - 1] = d);
  }
}
function Tk(o, e, n) {
  var l;
  let s, c, d;
  return n ? (s = e.changes, c = ri.empty(e.changes.length), d = o.changes.compose(e.changes)) : (s = e.changes.map(o.changes), c = o.changes.mapDesc(e.changes, !0), d = o.changes.compose(s)), {
    changes: d,
    selection: e.selection ? e.selection.map(c) : (l = o.selection) === null || l === void 0 ? void 0 : l.map(s),
    effects: it.mapEffects(o.effects, s).concat(it.mapEffects(e.effects, c)),
    annotations: o.annotations.length ? o.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: o.scrollIntoView || e.scrollIntoView
  };
}
function fx(o, e, n) {
  let l = e.selection, s = Rm(e.annotations);
  return e.userEvent && (s = s.concat(Pn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ri ? e.changes : ri.of(e.changes || [], n, o.facet(yk)),
    selection: l && (l instanceof ve ? l : ve.single(l.anchor, l.head)),
    effects: Rm(e.effects),
    annotations: s,
    scrollIntoView: !!e.scrollIntoView
  };
}
function xk(o, e, n) {
  let l = fx(o, e.length ? e[0] : {}, o.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let c = 1; c < e.length; c++) {
    e[c].filter === !1 && (n = !1);
    let d = !!e[c].sequential;
    l = Tk(l, fx(o, e[c], d ? l.changes.newLength : o.doc.length), d);
  }
  let s = Pn.create(o, l.changes, l.selection, l.effects, l.annotations, l.scrollIntoView);
  return J3(n ? K3(s) : s);
}
function K3(o) {
  let e = o.startState, n = !0;
  for (let s of e.facet(Ok)) {
    let c = s(o);
    if (c === !1) {
      n = !1;
      break;
    }
    Array.isArray(c) && (n = n === !0 ? c : F3(n, c));
  }
  if (n !== !0) {
    let s, c;
    if (n === !1)
      c = o.changes.invertedDesc, s = ri.empty(e.doc.length);
    else {
      let d = o.changes.filter(n);
      s = d.changes, c = d.filtered.mapDesc(d.changes).invertedDesc;
    }
    o = Pn.create(e, s, o.selection && o.selection.map(c), it.mapEffects(o.effects, c), o.annotations, o.scrollIntoView);
  }
  let l = e.facet(vk);
  for (let s = l.length - 1; s >= 0; s--) {
    let c = l[s](o);
    c instanceof Pn ? o = c : Array.isArray(c) && c.length == 1 && c[0] instanceof Pn ? o = c[0] : o = xk(e, Rm(c), !1);
  }
  return o;
}
function J3(o) {
  let e = o.startState, n = e.facet(bk), l = o;
  for (let s = n.length - 1; s >= 0; s--) {
    let c = n[s](o);
    c && Object.keys(c).length && (l = Tk(l, fx(e, c, o.changes.newLength), !0));
  }
  return l == o ? o : Pn.create(e, o.changes, o.selection, l.effects, l.annotations, l.scrollIntoView);
}
const I3 = [];
function Rm(o) {
  return o == null ? I3 : Array.isArray(o) ? o : [o];
}
var yn = /* @__PURE__ */ function(o) {
  return o[o.Word = 0] = "Word", o[o.Space = 1] = "Space", o[o.Other = 2] = "Other", o;
}(yn || (yn = {}));
const eQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let hx;
try {
  hx = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function tQ(o) {
  if (hx)
    return hx.test(o);
  for (let e = 0; e < o.length; e++) {
    let n = o[e];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || eQ.test(n)))
      return !0;
  }
  return !1;
}
function nQ(o) {
  return (e) => {
    if (!/\S/.test(e))
      return yn.Space;
    if (tQ(e))
      return yn.Word;
    for (let n = 0; n < o.length; n++)
      if (e.indexOf(o[n]) > -1)
        return yn.Word;
    return yn.Other;
  };
}
class At {
  constructor(e, n, l, s, c, d) {
    this.config = e, this.doc = n, this.selection = l, this.values = s, this.status = e.statusTemplate.slice(), this.computeSlot = c, d && (d._state = this);
    for (let m = 0; m < this.config.dynamicSlots.length; m++)
      lO(this, m << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let l = this.config.address[e.id];
    if (l == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return lO(this, l), g1(this, l);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return xk(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let n = this.config, { base: l, compartments: s } = n;
    for (let m of e.effects)
      m.is(X1.reconfigure) ? (n && (s = /* @__PURE__ */ new Map(), n.compartments.forEach((y, b) => s.set(b, y)), n = null), s.set(m.value.compartment, m.value.extension)) : m.is(it.reconfigure) ? (n = null, l = m.value) : m.is(it.appendConfig) && (n = null, l = Rm(l).concat(m.value));
    let c;
    n ? c = e.startState.values.slice() : (n = m1.resolve(l, s, this), c = new At(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (y, b) => b.reconfigure(y, this), null).values);
    let d = e.startState.facet(cx) ? e.newSelection : e.newSelection.asSingle();
    new At(n, e.newDoc, d, c, (m, y) => y.update(m, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: ve.cursor(n.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let n = this.selection, l = e(n.ranges[0]), s = this.changes(l.changes), c = [l.range], d = Rm(l.effects);
    for (let m = 1; m < n.ranges.length; m++) {
      let y = e(n.ranges[m]), b = this.changes(y.changes), S = b.map(s);
      for (let w = 0; w < m; w++)
        c[w] = c[w].map(S);
      let A = s.mapDesc(b, !0);
      c.push(y.range.map(A)), s = s.compose(S), d = it.mapEffects(d, S).concat(it.mapEffects(Rm(y.effects), A));
    }
    return {
      changes: s,
      selection: ve.create(c, n.mainIndex),
      effects: d
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ri ? e : ri.of(e, this.doc.length, this.facet(At.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return kt.of(e.split(this.facet(At.lineSeparator) || ax));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (lO(this, n), g1(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let l in e) {
        let s = e[l];
        s instanceof Si && this.config.address[s.id] != null && (n[l] = s.spec.toJSON(this.field(e[l]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, n = {}, l) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (l) {
      for (let c in l)
        if (Object.prototype.hasOwnProperty.call(e, c)) {
          let d = l[c], m = e[c];
          s.push(d.init((y) => d.spec.fromJSON(m, y)));
        }
    }
    return At.create({
      doc: e.doc,
      selection: ve.fromJSON(e.selection),
      extensions: n.extensions ? s.concat([n.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let n = m1.resolve(e.extensions || [], /* @__PURE__ */ new Map()), l = e.doc instanceof kt ? e.doc : kt.of((e.doc || "").split(n.staticFacet(At.lineSeparator) || ax)), s = e.selection ? e.selection instanceof ve ? e.selection : ve.single(e.selection.anchor, e.selection.head) : ve.single(0);
    return pk(s, l.length), n.staticFacet(cx) || (s = s.asSingle()), new At(n, l, s, n.dynamicSlots.map(() => null), (c, d) => d.create(c), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(At.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(At.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Sk);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.

  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...n) {
    for (let l of this.facet(At.phrases))
      if (Object.prototype.hasOwnProperty.call(l, e)) {
        e = l[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (l, s) => {
      if (s == "$")
        return "$";
      let c = +(s || 1);
      return !c || c > n.length ? l : n[c - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.

  Examples of language data fields are...

  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, n, l = -1) {
    let s = [];
    for (let c of this.facet(gk))
      for (let d of c(this, n, l))
        Object.prototype.hasOwnProperty.call(d, e) && s.push(d[e]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:

   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return nQ(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: n, from: l, length: s } = this.doc.lineAt(e), c = this.charCategorizer(e), d = e - l, m = e - l;
    for (; d > 0; ) {
      let y = Ni(n, d, !1);
      if (c(n.slice(y, d)) != yn.Word)
        break;
      d = y;
    }
    for (; m < s; ) {
      let y = Ni(n, m);
      if (c(n.slice(m, y)) != yn.Word)
        break;
      m = y;
    }
    return d == m ? null : ve.range(d + l, m + l);
  }
}
At.allowMultipleSelections = cx;
At.tabSize = /* @__PURE__ */ Be.define({
  combine: (o) => o.length ? o[0] : 4
});
At.lineSeparator = yk;
At.readOnly = Sk;
At.phrases = /* @__PURE__ */ Be.define({
  compare(o, e) {
    let n = Object.keys(o), l = Object.keys(e);
    return n.length == l.length && n.every((s) => o[s] == e[s]);
  }
});
At.languageData = gk;
At.changeFilter = Ok;
At.transactionFilter = vk;
At.transactionExtender = bk;
X1.reconfigure = /* @__PURE__ */ it.define();
function sr(o, e, n = {}) {
  let l = {};
  for (let s of o)
    for (let c of Object.keys(s)) {
      let d = s[c], m = l[c];
      if (m === void 0)
        l[c] = d;
      else if (!(m === d || d === void 0)) if (Object.hasOwnProperty.call(n, c))
        l[c] = n[c](m, d);
      else
        throw new Error("Config merge conflict for field " + c);
    }
  for (let s in e)
    l[s] === void 0 && (l[s] = e[s]);
  return l;
}
class Jh {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, n = e) {
    return dx.create(e, n, this);
  }
}
Jh.prototype.startSide = Jh.prototype.endSide = 0;
Jh.prototype.point = !1;
Jh.prototype.mapMode = Qi.TrackDel;
let dx = class Ak {
  constructor(e, n, l) {
    this.from = e, this.to = n, this.value = l;
  }
  /**
  @internal
  */
  static create(e, n, l) {
    return new Ak(e, n, l);
  }
};
function px(o, e) {
  return o.from - e.from || o.value.startSide - e.value.startSide;
}
class iA {
  constructor(e, n, l, s) {
    this.from = e, this.to = n, this.value = l, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, n, l, s = 0) {
    let c = l ? this.to : this.from;
    for (let d = s, m = c.length; ; ) {
      if (d == m)
        return d;
      let y = d + m >> 1, b = c[y] - e || (l ? this.value[y].endSide : this.value[y].startSide) - n;
      if (y == d)
        return b >= 0 ? d : m;
      b >= 0 ? m = y : d = y + 1;
    }
  }
  between(e, n, l, s) {
    for (let c = this.findIndex(n, -1e9, !0), d = this.findIndex(l, 1e9, !1, c); c < d; c++)
      if (s(this.from[c] + e, this.to[c] + e, this.value[c]) === !1)
        return !1;
  }
  map(e, n) {
    let l = [], s = [], c = [], d = -1, m = -1;
    for (let y = 0; y < this.value.length; y++) {
      let b = this.value[y], S = this.from[y] + e, A = this.to[y] + e, w, E;
      if (S == A) {
        let z = n.mapPos(S, b.startSide, b.mapMode);
        if (z == null || (w = E = z, b.startSide != b.endSide && (E = n.mapPos(S, b.endSide), E < w)))
          continue;
      } else if (w = n.mapPos(S, b.startSide), E = n.mapPos(A, b.endSide), w > E || w == E && b.startSide > 0 && b.endSide <= 0)
        continue;
      (E - w || b.endSide - b.startSide) < 0 || (d < 0 && (d = w), b.point && (m = Math.max(m, E - w)), l.push(b), s.push(w - d), c.push(E - d));
    }
    return { mapped: l.length ? new iA(s, c, l, m) : null, pos: d };
  }
}
class Qt {
  constructor(e, n, l, s) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = l, this.maxPoint = s;
  }
  /**
  @internal
  */
  static create(e, n, l, s) {
    return new Qt(e, n, l, s);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.

  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: n = [], sort: l = !1, filterFrom: s = 0, filterTo: c = this.length } = e, d = e.filter;
    if (n.length == 0 && !d)
      return this;
    if (l && (n = n.slice().sort(px)), this.isEmpty)
      return n.length ? Qt.of(n) : this;
    let m = new wk(this, null, -1).goto(0), y = 0, b = [], S = new yu();
    for (; m.value || y < n.length; )
      if (y < n.length && (m.from - n[y].from || m.startSide - n[y].value.startSide) >= 0) {
        let A = n[y++];
        S.addInner(A.from, A.to, A.value) || b.push(A);
      } else m.rangeIndex == 1 && m.chunkIndex < this.chunk.length && (y == n.length || this.chunkEnd(m.chunkIndex) < n[y].from) && (!d || s > this.chunkEnd(m.chunkIndex) || c < this.chunkPos[m.chunkIndex]) && S.addChunk(this.chunkPos[m.chunkIndex], this.chunk[m.chunkIndex]) ? m.nextChunk() : ((!d || s > m.to || c < m.from || d(m.from, m.to, m.value)) && (S.addInner(m.from, m.to, m.value) || b.push(dx.create(m.from, m.to, m.value))), m.next());
    return S.finishInner(this.nextLayer.isEmpty && !b.length ? Qt.empty : this.nextLayer.update({ add: b, filter: d, filterFrom: s, filterTo: c }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], l = [], s = -1;
    for (let d = 0; d < this.chunk.length; d++) {
      let m = this.chunkPos[d], y = this.chunk[d], b = e.touchesRange(m, m + y.length);
      if (b === !1)
        s = Math.max(s, y.maxPoint), n.push(y), l.push(e.mapPos(m));
      else if (b === !0) {
        let { mapped: S, pos: A } = y.map(m, e);
        S && (s = Math.max(s, S.maxPoint), n.push(S), l.push(A));
      }
    }
    let c = this.nextLayer.map(e);
    return n.length == 0 ? c : new Qt(l, n, c || Qt.empty, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, n, l) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let c = this.chunkPos[s], d = this.chunk[s];
        if (n >= c && e <= c + d.length && d.between(c, e - c, n - c, l) === !1)
          return;
      }
      this.nextLayer.between(e, n, l);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return cO.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, n = 0) {
    return cO.from(e).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, n, l, s, c = -1) {
    let d = e.filter((A) => A.maxPoint > 0 || !A.isEmpty && A.maxPoint >= c), m = n.filter((A) => A.maxPoint > 0 || !A.isEmpty && A.maxPoint >= c), y = lC(d, m, l), b = new $y(d, y, c), S = new $y(m, y, c);
    l.iterGaps((A, w, E) => aC(b, A, S, w, E, s)), l.empty && l.length == 0 && aC(b, 0, S, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, n, l = 0, s) {
    s == null && (s = 999999999);
    let c = e.filter((S) => !S.isEmpty && n.indexOf(S) < 0), d = n.filter((S) => !S.isEmpty && e.indexOf(S) < 0);
    if (c.length != d.length)
      return !1;
    if (!c.length)
      return !0;
    let m = lC(c, d), y = new $y(c, m, 0).goto(l), b = new $y(d, m, 0).goto(l);
    for (; ; ) {
      if (y.to != b.to || !mx(y.active, b.active) || y.point && (!b.point || !y.point.eq(b.point)))
        return !1;
      if (y.to > s)
        return !0;
      y.next(), b.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, n, l, s, c = -1) {
    let d = new $y(e, null, c).goto(n), m = n, y = d.openStart;
    for (; ; ) {
      let b = Math.min(d.to, l);
      if (d.point) {
        let S = d.activeForPoint(d.to), A = d.pointFrom < n ? S.length + 1 : d.point.startSide < 0 ? S.length : Math.min(S.length, y);
        s.point(m, b, d.point, S, A, d.pointRank), y = Math.min(d.openEnd(b), S.length);
      } else b > m && (s.span(m, b, d.active, y), y = d.openEnd(b));
      if (d.to > l)
        return y + (d.point && d.to > l ? 1 : 0);
      m = d.to, d.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, n = !1) {
    let l = new yu();
    for (let s of e instanceof dx ? [e] : n ? iQ(e) : e)
      l.add(s.from, s.to, s.value);
    return l.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Qt.empty;
    let n = e[e.length - 1];
    for (let l = e.length - 2; l >= 0; l--)
      for (let s = e[l]; s != Qt.empty; s = s.nextLayer)
        n = new Qt(s.chunkPos, s.chunk, n, Math.max(s.maxPoint, n.maxPoint));
    return n;
  }
}
Qt.empty = /* @__PURE__ */ new Qt([], [], null, -1);
function iQ(o) {
  if (o.length > 1)
    for (let e = o[0], n = 1; n < o.length; n++) {
      let l = o[n];
      if (px(e, l) > 0)
        return o.slice().sort(px);
      e = l;
    }
  return o;
}
Qt.empty.nextLayer = Qt.empty;
class yu {
  finishChunk(e) {
    this.chunks.push(new iA(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, n, l) {
    this.addInner(e, n, l) || (this.nextLayer || (this.nextLayer = new yu())).add(e, n, l);
  }
  /**
  @internal
  */
  addInner(e, n, l) {
    let s = e - this.lastTo || l.startSide - this.last.endSide;
    if (s <= 0 && (e - this.lastFrom || l.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = l, this.lastFrom = e, this.lastTo = n, this.value.push(l), l.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let l = n.value.length - 1;
    return this.last = n.value[l], this.lastFrom = n.from[l] + e, this.lastTo = n.to[l] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Qt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = Qt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function lC(o, e, n) {
  let l = /* @__PURE__ */ new Map();
  for (let c of o)
    for (let d = 0; d < c.chunk.length; d++)
      c.chunk[d].maxPoint <= 0 && l.set(c.chunk[d], c.chunkPos[d]);
  let s = /* @__PURE__ */ new Set();
  for (let c of e)
    for (let d = 0; d < c.chunk.length; d++) {
      let m = l.get(c.chunk[d]);
      m != null && (n ? n.mapPos(m) : m) == c.chunkPos[d] && !(n != null && n.touchesRange(m, m + c.chunk[d].length)) && s.add(c.chunk[d]);
    }
  return s;
}
class wk {
  constructor(e, n, l, s = 0) {
    this.layer = e, this.skip = n, this.minPoint = l, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, l) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < e || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, l = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!l || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], l = e + n.from[this.rangeIndex];
        if (this.from = l, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class cO {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, l = -1) {
    let s = [];
    for (let c = 0; c < e.length; c++)
      for (let d = e[c]; !d.isEmpty; d = d.nextLayer)
        d.maxPoint >= l && s.push(new wk(d, n, l, c));
    return s.length == 1 ? s[0] : new cO(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let l of this.heap)
      l.goto(e, n);
    for (let l = this.heap.length >> 1; l >= 0; l--)
      AT(this.heap, l);
    return this.next(), this;
  }
  forward(e, n) {
    for (let l of this.heap)
      l.forward(e, n);
    for (let l = this.heap.length >> 1; l >= 0; l--)
      AT(this.heap, l);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), AT(this.heap, 0);
    }
  }
}
function AT(o, e) {
  for (let n = o[e]; ; ) {
    let l = (e << 1) + 1;
    if (l >= o.length)
      break;
    let s = o[l];
    if (l + 1 < o.length && s.compare(o[l + 1]) >= 0 && (s = o[l + 1], l++), n.compare(s) < 0)
      break;
    o[l] = n, o[e] = s, e = l;
  }
}
class $y {
  constructor(e, n, l) {
    this.minPoint = l, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = cO.from(e, n, l);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    Mb(this.active, e), Mb(this.activeTo, e), Mb(this.activeRank, e), this.minActive = oC(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: l, to: s, rank: c } = this.cursor;
    for (; n < this.activeRank.length && (c - this.activeRank[n] || s - this.activeTo[n]) > 0; )
      n++;
    zb(this.active, n, l), zb(this.activeTo, n, s), zb(this.activeRank, n, c), e && zb(e, n, this.cursor.from), this.minActive = oC(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let l = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s = this.minActive;
      if (s > -1 && (this.activeTo[s] - this.cursor.from || this.active[s].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[s] > e) {
          this.to = this.activeTo[s], this.endSide = this.active[s].endSide;
          break;
        }
        this.removeActive(s), l && Mb(l, s);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let c = this.cursor.value;
          if (!c.point)
            this.addActive(l), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = c, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = c.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (l) {
      this.openStart = 0;
      for (let s = l.length - 1; s >= 0 && l[s] < e; s--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let l = this.active.length - 1; l >= 0 && !(this.activeRank[l] < this.pointRank); l--)
      (this.activeTo[l] > e || this.activeTo[l] == e && this.active[l].endSide >= this.point.endSide) && n.push(this.active[l]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let l = this.activeTo.length - 1; l >= 0 && this.activeTo[l] > e; l--)
      n++;
    return n;
  }
}
function aC(o, e, n, l, s, c) {
  o.goto(e), n.goto(l);
  let d = l + s, m = l, y = l - e;
  for (; ; ) {
    let b = o.to + y - n.to, S = b || o.endSide - n.endSide, A = S < 0 ? o.to + y : n.to, w = Math.min(A, d);
    if (o.point || n.point ? o.point && n.point && (o.point == n.point || o.point.eq(n.point)) && mx(o.activeForPoint(o.to), n.activeForPoint(n.to)) || c.comparePoint(m, w, o.point, n.point) : w > m && !mx(o.active, n.active) && c.compareRange(m, w, o.active, n.active), A > d)
      break;
    (b || o.openEnd != n.openEnd) && c.boundChange && c.boundChange(A), m = A, S <= 0 && o.next(), S >= 0 && n.next();
  }
}
function mx(o, e) {
  if (o.length != e.length)
    return !1;
  for (let n = 0; n < o.length; n++)
    if (o[n] != e[n] && !o[n].eq(e[n]))
      return !1;
  return !0;
}
function Mb(o, e) {
  for (let n = e, l = o.length - 1; n < l; n++)
    o[n] = o[n + 1];
  o.pop();
}
function zb(o, e, n) {
  for (let l = o.length - 1; l >= e; l--)
    o[l + 1] = o[l];
  o[e] = n;
}
function oC(o, e) {
  let n = -1, l = 1e9;
  for (let s = 0; s < e.length; s++)
    (e[s] - l || o[s].endSide - o[n].endSide) < 0 && (n = s, l = e[s]);
  return n;
}
function jm(o, e, n = o.length) {
  let l = 0;
  for (let s = 0; s < n && s < o.length; )
    o.charCodeAt(s) == 9 ? (l += e - l % e, s++) : (l++, s = Ni(o, s));
  return l;
}
function gx(o, e, n, l) {
  for (let s = 0, c = 0; ; ) {
    if (c >= e)
      return s;
    if (s == o.length)
      break;
    c += o.charCodeAt(s) == 9 ? n - c % n : 1, s = Ni(o, s);
  }
  return l === !0 ? -1 : o.length;
}
const yx = "", sC = typeof Symbol > "u" ? "__" + yx : Symbol.for(yx), Ox = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), rC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Kc {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, n) {
    this.rules = [];
    let { finish: l } = n || {};
    function s(d) {
      return /^@/.test(d) ? [d] : d.split(/,\s*/);
    }
    function c(d, m, y, b) {
      let S = [], A = /^@(\w+)\b/.exec(d[0]), w = A && A[1] == "keyframes";
      if (A && m == null) return y.push(d[0] + ";");
      for (let E in m) {
        let z = m[E];
        if (/&/.test(E))
          c(
            E.split(/,\s*/).map((U) => d.map((V) => U.replace(/&/, V))).reduce((U, V) => U.concat(V)),
            z,
            y
          );
        else if (z && typeof z == "object") {
          if (!A) throw new RangeError("The value of a property (" + E + ") should be a primitive value.");
          c(s(E), z, S, w);
        } else z != null && S.push(E.replace(/_.*/, "").replace(/[A-Z]/g, (U) => "-" + U.toLowerCase()) + ": " + z + ";");
      }
      (S.length || w) && y.push((l && !A && !b ? d.map(l) : d).join(", ") + " {" + S.join(" ") + "}");
    }
    for (let d in e) c(s(d), e[d], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = rC[sC] || 1;
    return rC[sC] = e + 1, yx + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, n, l) {
    let s = e[Ox], c = l && l.nonce;
    s ? c && s.setNonce(c) : s = new lQ(e, c), s.mount(Array.isArray(n) ? n : [n], e);
  }
}
let uC = /* @__PURE__ */ new Map();
class lQ {
  constructor(e, n) {
    let l = e.ownerDocument || e, s = l.defaultView;
    if (!e.head && e.adoptedStyleSheets && s.CSSStyleSheet) {
      let c = uC.get(l);
      if (c) return e[Ox] = c;
      this.sheet = new s.CSSStyleSheet(), uC.set(l, this);
    } else
      this.styleTag = l.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], e[Ox] = this;
  }
  mount(e, n) {
    let l = this.sheet, s = 0, c = 0;
    for (let d = 0; d < e.length; d++) {
      let m = e[d], y = this.modules.indexOf(m);
      if (y < c && y > -1 && (this.modules.splice(y, 1), c--, y = -1), y == -1) {
        if (this.modules.splice(c++, 0, m), l) for (let b = 0; b < m.rules.length; b++)
          l.insertRule(m.rules[b], s++);
      } else {
        for (; c < y; ) s += this.modules[c++].rules.length;
        s += m.rules.length, c++;
      }
    }
    if (l)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let d = "";
      for (let y = 0; y < this.modules.length; y++)
        d += this.modules[y].getRules() + `
`;
      this.styleTag.textContent = d;
      let m = n.head || n;
      this.styleTag.parentNode != m && m.insertBefore(this.styleTag, m.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Jc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, fO = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, aQ = typeof navigator < "u" && /Mac/.test(navigator.platform), oQ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var zi = 0; zi < 10; zi++) Jc[48 + zi] = Jc[96 + zi] = String(zi);
for (var zi = 1; zi <= 24; zi++) Jc[zi + 111] = "F" + zi;
for (var zi = 65; zi <= 90; zi++)
  Jc[zi] = String.fromCharCode(zi + 32), fO[zi] = String.fromCharCode(zi);
for (var wT in Jc) fO.hasOwnProperty(wT) || (fO[wT] = Jc[wT]);
function sQ(o) {
  var e = aQ && o.metaKey && o.shiftKey && !o.ctrlKey && !o.altKey || oQ && o.shiftKey && o.key && o.key.length == 1 || o.key == "Unidentified", n = !e && o.key || (o.shiftKey ? fO : Jc)[o.keyCode] || o.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function hO(o) {
  let e;
  return o.nodeType == 11 ? e = o.getSelection ? o : o.ownerDocument : e = o, e.getSelection();
}
function vx(o, e) {
  return e ? o == e || o.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function i1(o, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return vx(o, e.anchorNode);
  } catch {
    return !1;
  }
}
function Um(o) {
  return o.nodeType == 3 ? ed(o, 0, o.nodeValue.length).getClientRects() : o.nodeType == 1 ? o.getClientRects() : [];
}
function aO(o, e, n, l) {
  return n ? cC(o, e, n, l, -1) || cC(o, e, n, l, 1) : !1;
}
function Ih(o) {
  for (var e = 0; ; e++)
    if (o = o.previousSibling, !o)
      return e;
}
function y1(o) {
  return o.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(o.nodeName);
}
function cC(o, e, n, l, s) {
  for (; ; ) {
    if (o == n && e == l)
      return !0;
    if (e == (s < 0 ? 0 : ar(o))) {
      if (o.nodeName == "DIV")
        return !1;
      let c = o.parentNode;
      if (!c || c.nodeType != 1)
        return !1;
      e = Ih(o) + (s < 0 ? 0 : 1), o = c;
    } else if (o.nodeType == 1) {
      if (o = o.childNodes[e + (s < 0 ? -1 : 0)], o.nodeType == 1 && o.contentEditable == "false")
        return !1;
      e = s < 0 ? ar(o) : 0;
    } else
      return !1;
  }
}
function ar(o) {
  return o.nodeType == 3 ? o.nodeValue.length : o.childNodes.length;
}
function EO(o, e) {
  let n = e ? o.left : o.right;
  return { left: n, right: n, top: o.top, bottom: o.bottom };
}
function rQ(o) {
  let e = o.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: o.innerWidth,
    top: 0,
    bottom: o.innerHeight
  };
}
function Ek(o, e) {
  let n = e.width / o.offsetWidth, l = e.height / o.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - o.offsetWidth) < 1) && (n = 1), (l > 0.995 && l < 1.005 || !isFinite(l) || Math.abs(e.height - o.offsetHeight) < 1) && (l = 1), { scaleX: n, scaleY: l };
}
function uQ(o, e, n, l, s, c, d, m) {
  let y = o.ownerDocument, b = y.defaultView || window;
  for (let S = o, A = !1; S && !A; )
    if (S.nodeType == 1) {
      let w, E = S == y.body, z = 1, U = 1;
      if (E)
        w = rQ(b);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(S).position) && (A = !0), S.scrollHeight <= S.clientHeight && S.scrollWidth <= S.clientWidth) {
          S = S.assignedSlot || S.parentNode;
          continue;
        }
        let ie = S.getBoundingClientRect();
        ({ scaleX: z, scaleY: U } = Ek(S, ie)), w = {
          left: ie.left,
          right: ie.left + S.clientWidth * z,
          top: ie.top,
          bottom: ie.top + S.clientHeight * U
        };
      }
      let V = 0, G = 0;
      if (s == "nearest")
        e.top < w.top ? (G = e.top - (w.top + d), n > 0 && e.bottom > w.bottom + G && (G = e.bottom - w.bottom + d)) : e.bottom > w.bottom && (G = e.bottom - w.bottom + d, n < 0 && e.top - G < w.top && (G = e.top - (w.top + d)));
      else {
        let ie = e.bottom - e.top, me = w.bottom - w.top;
        G = (s == "center" && ie <= me ? e.top + ie / 2 - me / 2 : s == "start" || s == "center" && n < 0 ? e.top - d : e.bottom - me + d) - w.top;
      }
      if (l == "nearest" ? e.left < w.left ? (V = e.left - (w.left + c), n > 0 && e.right > w.right + V && (V = e.right - w.right + c)) : e.right > w.right && (V = e.right - w.right + c, n < 0 && e.left < w.left + V && (V = e.left - (w.left + c))) : V = (l == "center" ? e.left + (e.right - e.left) / 2 - (w.right - w.left) / 2 : l == "start" == m ? e.left - c : e.right - (w.right - w.left) + c) - w.left, V || G)
        if (E)
          b.scrollBy(V, G);
        else {
          let ie = 0, me = 0;
          if (G) {
            let pe = S.scrollTop;
            S.scrollTop += G / U, me = (S.scrollTop - pe) * U;
          }
          if (V) {
            let pe = S.scrollLeft;
            S.scrollLeft += V / z, ie = (S.scrollLeft - pe) * z;
          }
          e = {
            left: e.left - ie,
            top: e.top - me,
            right: e.right - ie,
            bottom: e.bottom - me
          }, ie && Math.abs(ie - V) < 1 && (l = "nearest"), me && Math.abs(me - G) < 1 && (s = "nearest");
        }
      if (E)
        break;
      (e.top < w.top || e.bottom > w.bottom || e.left < w.left || e.right > w.right) && (e = {
        left: Math.max(e.left, w.left),
        right: Math.min(e.right, w.right),
        top: Math.max(e.top, w.top),
        bottom: Math.min(e.bottom, w.bottom)
      }), S = S.assignedSlot || S.parentNode;
    } else if (S.nodeType == 11)
      S = S.host;
    else
      break;
}
function cQ(o) {
  let e = o.ownerDocument, n, l;
  for (let s = o.parentNode; s && !(s == e.body || n && l); )
    if (s.nodeType == 1)
      !l && s.scrollHeight > s.clientHeight && (l = s), !n && s.scrollWidth > s.clientWidth && (n = s), s = s.assignedSlot || s.parentNode;
    else if (s.nodeType == 11)
      s = s.host;
    else
      break;
  return { x: n, y: l };
}
class fQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: l } = e;
    this.set(n, Math.min(e.anchorOffset, n ? ar(n) : 0), l, Math.min(e.focusOffset, l ? ar(l) : 0));
  }
  set(e, n, l, s) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = l, this.focusOffset = s;
  }
}
let Tm = null;
function Ck(o) {
  if (o.setActive)
    return o.setActive();
  if (Tm)
    return o.focus(Tm);
  let e = [];
  for (let n = o; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (o.focus(Tm == null ? {
    get preventScroll() {
      return Tm = { preventScroll: !0 }, !0;
    }
  } : void 0), !Tm) {
    Tm = !1;
    for (let n = 0; n < e.length; ) {
      let l = e[n++], s = e[n++], c = e[n++];
      l.scrollTop != s && (l.scrollTop = s), l.scrollLeft != c && (l.scrollLeft = c);
    }
  }
}
let fC;
function ed(o, e, n = e) {
  let l = fC || (fC = document.createRange());
  return l.setEnd(o, n), l.setStart(o, e), l;
}
function km(o, e, n, l) {
  let s = { key: e, code: e, keyCode: n, which: n, cancelable: !0 };
  l && ({ altKey: s.altKey, ctrlKey: s.ctrlKey, shiftKey: s.shiftKey, metaKey: s.metaKey } = l);
  let c = new KeyboardEvent("keydown", s);
  c.synthetic = !0, o.dispatchEvent(c);
  let d = new KeyboardEvent("keyup", s);
  return d.synthetic = !0, o.dispatchEvent(d), c.defaultPrevented || d.defaultPrevented;
}
function hQ(o) {
  for (; o; ) {
    if (o && (o.nodeType == 9 || o.nodeType == 11 && o.host))
      return o;
    o = o.assignedSlot || o.parentNode;
  }
  return null;
}
function Rk(o) {
  for (; o.attributes.length; )
    o.removeAttributeNode(o.attributes[0]);
}
function dQ(o, e) {
  let n = e.focusNode, l = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != l)
    return !1;
  for (l = Math.min(l, ar(n)); ; )
    if (l) {
      if (n.nodeType != 1)
        return !1;
      let s = n.childNodes[l - 1];
      s.contentEditable == "false" ? l-- : (n = s, l = ar(n));
    } else {
      if (n == o)
        return !0;
      l = Ih(n), n = n.parentNode;
    }
}
function kk(o) {
  return o.scrollTop > Math.max(1, o.scrollHeight - o.clientHeight - 4);
}
function Dk(o, e) {
  for (let n = o, l = e; ; ) {
    if (n.nodeType == 3 && l > 0)
      return { node: n, offset: l };
    if (n.nodeType == 1 && l > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[l - 1], l = ar(n);
    } else if (n.parentNode && !y1(n))
      l = Ih(n), n = n.parentNode;
    else
      return null;
  }
}
function Mk(o, e) {
  for (let n = o, l = e; ; ) {
    if (n.nodeType == 3 && l < n.nodeValue.length)
      return { node: n, offset: l };
    if (n.nodeType == 1 && l < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[l], l = 0;
    } else if (n.parentNode && !y1(n))
      l = Ih(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class al {
  constructor(e, n, l = !0) {
    this.node = e, this.offset = n, this.precise = l;
  }
  static before(e, n) {
    return new al(e.parentNode, Ih(e), n);
  }
  static after(e, n) {
    return new al(e.parentNode, Ih(e) + 1, n);
  }
}
const lA = [];
class ln {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let l of this.children) {
      if (l == e)
        return n;
      n += l.length + l.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let l = this.dom, s = null, c;
      for (let d of this.children) {
        if (d.flags & 7) {
          if (!d.dom && (c = s ? s.nextSibling : l.firstChild)) {
            let m = ln.get(c);
            (!m || !m.parent && m.canReuseDOM(d)) && d.reuseDOM(c);
          }
          d.sync(e, n), d.flags &= -8;
        }
        if (c = s ? s.nextSibling : l.firstChild, n && !n.written && n.node == l && c != d.dom && (n.written = !0), d.dom.parentNode == l)
          for (; c && c != d.dom; )
            c = hC(c);
        else
          l.insertBefore(d.dom, c);
        s = d.dom;
      }
      for (c = s ? s.nextSibling : l.firstChild, c && n && n.node == l && (n.written = !0); c; )
        c = hC(c);
    } else if (this.flags & 1)
      for (let l of this.children)
        l.flags & 7 && (l.sync(e, n), l.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let l;
    if (e == this.dom)
      l = this.dom.childNodes[n];
    else {
      let s = ar(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let c = e.parentNode;
        if (c == this.dom)
          break;
        s == 0 && c.firstChild != c.lastChild && (e == c.firstChild ? s = -1 : s = 1), e = c;
      }
      s < 0 ? l = e : l = e.nextSibling;
    }
    if (l == this.dom.firstChild)
      return 0;
    for (; l && !ln.get(l); )
      l = l.nextSibling;
    if (!l)
      return this.length;
    for (let s = 0, c = 0; ; s++) {
      let d = this.children[s];
      if (d.dom == l)
        return c;
      c += d.length + d.breakAfter;
    }
  }
  domBoundsAround(e, n, l = 0) {
    let s = -1, c = -1, d = -1, m = -1;
    for (let y = 0, b = l, S = l; y < this.children.length; y++) {
      let A = this.children[y], w = b + A.length;
      if (b < e && w > n)
        return A.domBoundsAround(e, n, b);
      if (w >= e && s == -1 && (s = y, c = b), b > n && A.dom.parentNode == this.dom) {
        d = y, m = S;
        break;
      }
      S = w, b = w + A.breakAfter;
    }
    return {
      from: c,
      to: m < 0 ? l + this.length : m,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: d < this.children.length && d >= 0 ? this.children[d].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, l = lA) {
    this.markDirty();
    for (let s = e; s < n; s++) {
      let c = this.children[s];
      c.parent == this && l.indexOf(c) < 0 && c.destroy();
    }
    l.length < 250 ? this.children.splice(e, n - e, ...l) : this.children = [].concat(this.children.slice(0, e), l, this.children.slice(n));
    for (let s = 0; s < l.length; s++)
      l[s].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new zk(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, l, s, c, d) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ln.prototype.breakAfter = 0;
function hC(o) {
  let e = o.nextSibling;
  return o.parentNode.removeChild(o), e;
}
class zk {
  constructor(e, n, l) {
    this.children = e, this.pos = n, this.i = l, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let l = this.children[--this.i];
      this.pos -= l.length + l.breakAfter;
    }
  }
}
function Qk(o, e, n, l, s, c, d, m, y) {
  let { children: b } = o, S = b.length ? b[e] : null, A = c.length ? c[c.length - 1] : null, w = A ? A.breakAfter : d;
  if (!(e == l && S && !d && !w && c.length < 2 && S.merge(n, s, c.length ? A : null, n == 0, m, y))) {
    if (l < b.length) {
      let E = b[l];
      E && (s < E.length || E.breakAfter && (A != null && A.breakAfter)) ? (e == l && (E = E.split(s), s = 0), !w && A && E.merge(0, s, A, !0, 0, y) ? c[c.length - 1] = E : ((s || E.children.length && !E.children[0].length) && E.merge(0, s, null, !1, 0, y), c.push(E))) : E != null && E.breakAfter && (A ? A.breakAfter = 1 : d = 1), l++;
    }
    for (S && (S.breakAfter = d, n > 0 && (!d && c.length && S.merge(n, S.length, c[0], !1, m, 0) ? S.breakAfter = c.shift().breakAfter : (n < S.length || S.children.length && S.children[S.children.length - 1].length == 0) && S.merge(n, S.length, null, !1, m, 0), e++)); e < l && c.length; )
      if (b[l - 1].become(c[c.length - 1]))
        l--, c.pop(), y = c.length ? 0 : m;
      else if (b[e].become(c[0]))
        e++, c.shift(), m = c.length ? 0 : y;
      else
        break;
    !c.length && e && l < b.length && !b[e - 1].breakAfter && b[l].merge(0, 0, b[e - 1], !1, m, y) && e--, (e < l || c.length) && o.replaceChildren(e, l, c);
  }
}
function Nk(o, e, n, l, s, c) {
  let d = o.childCursor(), { i: m, off: y } = d.findPos(n, 1), { i: b, off: S } = d.findPos(e, -1), A = e - n;
  for (let w of l)
    A += w.length;
  o.length += A, Qk(o, b, S, m, y, l, 0, s, c);
}
let Yl = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, bx = typeof document < "u" ? document : { documentElement: { style: {} } };
const Sx = /* @__PURE__ */ /Edge\/(\d+)/.exec(Yl.userAgent), Uk = /* @__PURE__ */ /MSIE \d/.test(Yl.userAgent), Tx = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Yl.userAgent), j1 = !!(Uk || Tx || Sx), dC = !j1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Yl.userAgent), ET = !j1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Yl.userAgent), pQ = "webkitFontSmoothing" in bx.documentElement.style, Bk = !j1 && /* @__PURE__ */ /Apple Computer/.test(Yl.vendor), pC = Bk && (/* @__PURE__ */ /Mobile\/\w+/.test(Yl.userAgent) || Yl.maxTouchPoints > 2);
var qe = {
  mac: pC || /* @__PURE__ */ /Mac/.test(Yl.platform),
  windows: /* @__PURE__ */ /Win/.test(Yl.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Yl.platform),
  ie: j1,
  ie_version: Uk ? bx.documentMode || 6 : Tx ? +Tx[1] : Sx ? +Sx[1] : 0,
  gecko: dC,
  gecko_version: dC ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Yl.userAgent) || [0, 0])[1] : 0,
  chrome: !!ET,
  chrome_version: ET ? +ET[1] : 0,
  ios: pC,
  android: /* @__PURE__ */ /Android\b/.test(Yl.userAgent),
  safari: Bk,
  webkit_version: pQ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Yl.userAgent) || [0, 0])[1] : 0,
  tabSize: bx.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const mQ = 256;
class ns extends ln {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, l) {
    return this.flags & 8 || l && (!(l instanceof ns) || this.length - (n - e) + l.length > mQ || l.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (l ? l.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new ns(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new al(this.dom, e);
  }
  domBoundsAround(e, n, l) {
    return { from: l, to: l + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return gQ(this.dom, e, n);
  }
}
class Ou extends ln {
  constructor(e, n = [], l = 0) {
    super(), this.mark = e, this.children = n, this.length = l;
    for (let s of n)
      s.setParent(this);
  }
  setAttrs(e) {
    if (Rk(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, l, s, c, d) {
    return l && (!(l instanceof Ou && l.mark.eq(this.mark)) || e && c <= 0 || n < this.length && d <= 0) ? !1 : (Nk(this, e, n, l ? l.children.slice() : [], c - 1, d - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], l = 0, s = -1, c = 0;
    for (let m of this.children) {
      let y = l + m.length;
      y > e && n.push(l < e ? m.split(e - l) : m), s < 0 && l >= e && (s = c), l = y, c++;
    }
    let d = this.length - e;
    return this.length = e, s > -1 && (this.children.length = s, this.markDirty()), new Ou(this.mark, n, d);
  }
  domAtPos(e) {
    return qk(this, e);
  }
  coordsAt(e, n) {
    return Hk(this, e, n);
  }
}
function gQ(o, e, n) {
  let l = o.nodeValue.length;
  e > l && (e = l);
  let s = e, c = e, d = 0;
  e == 0 && n < 0 || e == l && n >= 0 ? qe.chrome || qe.gecko || (e ? (s--, d = 1) : c < l && (c++, d = -1)) : n < 0 ? s-- : c < l && c++;
  let m = ed(o, s, c).getClientRects();
  if (!m.length)
    return null;
  let y = m[(d ? d < 0 : n >= 0) ? 0 : m.length - 1];
  return qe.safari && !d && y.width == 0 && (y = Array.prototype.find.call(m, (b) => b.width) || y), d ? EO(y, d < 0) : y || null;
}
class Pc extends ln {
  static create(e, n, l) {
    return new Pc(e, n, l);
  }
  constructor(e, n, l) {
    super(), this.widget = e, this.length = n, this.side = l, this.prevWidget = null;
  }
  split(e) {
    let n = Pc.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, n, l, s, c, d) {
    return l && (!(l instanceof Pc) || !this.widget.compare(l.widget) || e > 0 && c <= 0 || n < this.length && d <= 0) ? !1 : (this.length = e + (l ? l.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof Pc && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return kt.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, l = n && n.state.doc, s = this.posAtStart;
    return l ? l.slice(s, s + this.length) : kt.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? al.before(this.dom) : al.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let l = this.widget.coordsAt(this.dom, e, n);
    if (l)
      return l;
    let s = this.dom.getClientRects(), c = null;
    if (!s.length)
      return null;
    let d = this.side ? this.side < 0 : e > 0;
    for (let m = d ? s.length - 1 : 0; c = s[m], !(e > 0 ? m == 0 : m == s.length - 1 || c.top < c.bottom); m += d ? -1 : 1)
      ;
    return EO(c, !d);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Bm extends ln {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Bm && e.side == this.side;
  }
  split() {
    return new Bm(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? al.before(this.dom) : al.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return kt.empty;
  }
  get isHidden() {
    return !0;
  }
}
ns.prototype.children = Pc.prototype.children = Bm.prototype.children = lA;
function qk(o, e) {
  let n = o.dom, { children: l } = o, s = 0;
  for (let c = 0; s < l.length; s++) {
    let d = l[s], m = c + d.length;
    if (!(m == c && d.getSide() <= 0)) {
      if (e > c && e < m && d.dom.parentNode == n)
        return d.domAtPos(e - c);
      if (e <= c)
        break;
      c = m;
    }
  }
  for (let c = s; c > 0; c--) {
    let d = l[c - 1];
    if (d.dom.parentNode == n)
      return d.domAtPos(d.length);
  }
  for (let c = s; c < l.length; c++) {
    let d = l[c];
    if (d.dom.parentNode == n)
      return d.domAtPos(0);
  }
  return new al(n, 0);
}
function _k(o, e, n) {
  let l, { children: s } = o;
  n > 0 && e instanceof Ou && s.length && (l = s[s.length - 1]) instanceof Ou && l.mark.eq(e.mark) ? _k(l, e.children[0], n - 1) : (s.push(e), e.setParent(o)), o.length += e.length;
}
function Hk(o, e, n) {
  let l = null, s = -1, c = null, d = -1;
  function m(b, S) {
    for (let A = 0, w = 0; A < b.children.length && w <= S; A++) {
      let E = b.children[A], z = w + E.length;
      z >= S && (E.children.length ? m(E, S - w) : (!c || c.isHidden && (n > 0 || OQ(c, E))) && (z > S || w == z && E.getSide() > 0) ? (c = E, d = S - w) : (w < S || w == z && E.getSide() < 0 && !E.isHidden) && (l = E, s = S - w)), w = z;
    }
  }
  m(o, e);
  let y = (n < 0 ? l : c) || l || c;
  return y ? y.coordsAt(Math.max(0, y == l ? s : d), n) : yQ(o);
}
function yQ(o) {
  let e = o.dom.lastChild;
  if (!e)
    return o.dom.getBoundingClientRect();
  let n = Um(e);
  return n[n.length - 1] || null;
}
function OQ(o, e) {
  let n = o.coordsAt(0, 1), l = e.coordsAt(0, 1);
  return n && l && l.top < n.bottom;
}
function xx(o, e) {
  for (let n in o)
    n == "class" && e.class ? e.class += " " + o.class : n == "style" && e.style ? e.style += ";" + o.style : e[n] = o[n];
  return e;
}
const mC = /* @__PURE__ */ Object.create(null);
function O1(o, e, n) {
  if (o == e)
    return !0;
  o || (o = mC), e || (e = mC);
  let l = Object.keys(o), s = Object.keys(e);
  if (l.length - (n && l.indexOf(n) > -1 ? 1 : 0) != s.length - (n && s.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let c of l)
    if (c != n && (s.indexOf(c) == -1 || o[c] !== e[c]))
      return !1;
  return !0;
}
function Ax(o, e, n) {
  let l = !1;
  if (e)
    for (let s in e)
      n && s in n || (l = !0, s == "style" ? o.style.cssText = "" : o.removeAttribute(s));
  if (n)
    for (let s in n)
      e && e[s] == n[s] || (l = !0, s == "style" ? o.style.cssText = n[s] : o.setAttribute(s, n[s]));
  return l;
}
function vQ(o) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < o.attributes.length; n++) {
    let l = o.attributes[n];
    e[l.name] = l.value;
  }
  return e;
}
class rr {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, n, l) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Al = /* @__PURE__ */ function(o) {
  return o[o.Text = 0] = "Text", o[o.WidgetBefore = 1] = "WidgetBefore", o[o.WidgetAfter = 2] = "WidgetAfter", o[o.WidgetRange = 3] = "WidgetRange", o;
}(Al || (Al = {}));
class Ze extends Jh {
  constructor(e, n, l, s) {
    super(), this.startSide = e, this.endSide = n, this.widget = l, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new CO(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), l = !!e.block;
    return n += l && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Ic(e, n, n, l, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let n = !!e.block, l, s;
    if (e.isBlockGap)
      l = -5e8, s = 4e8;
    else {
      let { start: c, end: d } = Lk(e, n);
      l = (c ? n ? -3e8 : -1 : 5e8) - 1, s = (d ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new Ic(e, l, s, n, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new RO(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, n = !1) {
    return Qt.of(e, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Ze.none = Qt.empty;
class CO extends Ze {
  constructor(e) {
    let { start: n, end: l } = Lk(e);
    super(n ? -1 : 5e8, l ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, l;
    return this == e || e instanceof CO && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((l = e.attrs) === null || l === void 0 ? void 0 : l.class)) && O1(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
CO.prototype.point = !1;
class RO extends Ze {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof RO && this.spec.class == e.spec.class && O1(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
RO.prototype.mapMode = Qi.TrackBefore;
RO.prototype.point = !0;
class Ic extends Ze {
  constructor(e, n, l, s, c, d) {
    super(n, l, c, e), this.block = s, this.isReplace = d, this.mapMode = s ? n <= 0 ? Qi.TrackBefore : Qi.TrackAfter : Qi.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Al.WidgetRange : this.startSide <= 0 ? Al.WidgetBefore : Al.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Ic && bQ(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
Ic.prototype.point = !0;
function Lk(o, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: l } = o;
  return n == null && (n = o.inclusive), l == null && (l = o.inclusive), { start: n ?? e, end: l ?? e };
}
function bQ(o, e) {
  return o == e || !!(o && e && o.compare(e));
}
function l1(o, e, n, l = 0) {
  let s = n.length - 1;
  s >= 0 && n[s] + l >= o ? n[s] = Math.max(n[s], e) : n.push(o, e);
}
class $n extends ln {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, n, l, s, c, d) {
    if (l) {
      if (!(l instanceof $n))
        return !1;
      this.dom || l.transferDOM(this);
    }
    return s && this.setDeco(l ? l.attrs : null), Nk(this, e, n, l ? l.children.slice() : [], c, d), !0;
  }
  split(e) {
    let n = new $n();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: l, off: s } = this.childPos(e);
    s && (n.append(this.children[l].split(s), 0), this.children[l].merge(s, this.children[l].length, null, !1, 0, 0), l++);
    for (let c = l; c < this.children.length; c++)
      n.append(this.children[c], 0);
    for (; l > 0 && this.children[l - 1].length == 0; )
      this.children[--l].destroy();
    return this.children.length = l, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    O1(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    _k(this, e, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let n = e.spec.attributes, l = e.spec.class;
    n && (this.attrs = xx(n, this.attrs || {})), l && (this.attrs = xx({ class: l }, this.attrs || {}));
  }
  domAtPos(e) {
    return qk(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var l;
    this.dom ? this.flags & 4 && (Rk(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Ax(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let s = this.dom.lastChild;
    for (; s && ln.get(s) instanceof Ou; )
      s = s.lastChild;
    if (!s || !this.length || s.nodeName != "BR" && ((l = ln.get(s)) === null || l === void 0 ? void 0 : l.isEditable) == !1 && (!qe.ios || !this.children.some((c) => c instanceof ns))) {
      let c = document.createElement("BR");
      c.cmIgnore = !0, this.dom.appendChild(c);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let l of this.children) {
      if (!(l instanceof ns) || /[^ -~]/.test(l.text))
        return null;
      let s = Um(l.dom);
      if (s.length != 1)
        return null;
      e += s[0].width, n = s[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let l = Hk(this, e, n);
    if (!this.children.length && l && this.parent) {
      let { heightOracle: s } = this.parent.view.viewState, c = l.bottom - l.top;
      if (Math.abs(c - s.lineHeight) < 2 && s.textHeight < c) {
        let d = (c - s.textHeight) / 2;
        return { top: l.top + d, bottom: l.bottom - d, left: l.left, right: l.left };
      }
    }
    return l;
  }
  become(e) {
    return e instanceof $n && this.children.length == 0 && e.children.length == 0 && O1(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let l = 0, s = 0; l < e.children.length; l++) {
      let c = e.children[l], d = s + c.length;
      if (d >= n) {
        if (c instanceof $n)
          return c;
        if (d > n)
          break;
      }
      s = d + c.breakAfter;
    }
    return null;
  }
}
class gu extends ln {
  constructor(e, n, l) {
    super(), this.widget = e, this.length = n, this.deco = l, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, l, s, c, d) {
    return l && (!(l instanceof gu) || !this.widget.compare(l.widget) || e > 0 && c <= 0 || n < this.length && d <= 0) ? !1 : (this.length = e + (l ? l.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? al.before(this.dom) : al.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let l = new gu(this.widget, n, this.deco);
    return l.breakAfter = this.breakAfter, l;
  }
  get children() {
    return lA;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : kt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof gu && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    let l = this.widget.coordsAt(this.dom, e, n);
    return l || (this.widget instanceof wx ? null : EO(this.dom.getBoundingClientRect(), this.length ? e == 0 : n <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: l } = this.deco;
    return n == l ? !1 : e < 0 ? n < 0 : l > 0;
  }
}
class wx extends rr {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class oO {
  constructor(e, n, l, s) {
    this.doc = e, this.pos = n, this.end = l, this.disallowBlockEffectsFor = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof gu && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new $n()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Qb(new Bm(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof gu) && this.getLine();
  }
  buildText(e, n, l) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: c, lineBreak: d, done: m } = this.cursor.next(this.skip);
        if (this.skip = 0, m)
          throw new Error("Ran out of text content when drawing inline views");
        if (d) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = c, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - l)), this.getLine().append(Qb(new ns(this.text.slice(this.textOff, this.textOff + s)), n), l), this.atCursorPos = !0, this.textOff += s, e -= s, l = 0;
    }
  }
  span(e, n, l, s) {
    this.buildText(n - e, l, s), this.pos = n, this.openStart < 0 && (this.openStart = s);
  }
  point(e, n, l, s, c, d) {
    if (this.disallowBlockEffectsFor[d] && l instanceof Ic) {
      if (l.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let m = n - e;
    if (l instanceof Ic)
      if (l.block)
        l.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new gu(l.widget || qm.block, m, l));
      else {
        let y = Pc.create(l.widget || qm.inline, m, m ? 0 : l.startSide), b = this.atCursorPos && !y.isEditable && c <= s.length && (e < n || l.startSide > 0), S = !y.isEditable && (e < n || c > s.length || l.startSide <= 0), A = this.getLine();
        this.pendingBuffer == 2 && !b && !y.isEditable && (this.pendingBuffer = 0), this.flushBuffer(s), b && (A.append(Qb(new Bm(1), s), c), c = s.length + Math.max(0, c - s.length)), A.append(Qb(y, s), c), this.atCursorPos = S, this.pendingBuffer = S ? e < n || c > s.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(l);
    m && (this.textOff + m <= this.text.length ? this.textOff += m : (this.skip += m - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = c);
  }
  static build(e, n, l, s, c) {
    let d = new oO(e, n, l, c);
    return d.openEnd = Qt.spans(s, n, l, d), d.openStart < 0 && (d.openStart = d.openEnd), d.finish(d.openEnd), d;
  }
}
function Qb(o, e) {
  for (let n of e)
    o = new Ou(n, [o], o.length);
  return o;
}
class qm extends rr {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
qm.inline = /* @__PURE__ */ new qm("span");
qm.block = /* @__PURE__ */ new qm("div");
var fn = /* @__PURE__ */ function(o) {
  return o[o.LTR = 0] = "LTR", o[o.RTL = 1] = "RTL", o;
}(fn || (fn = {}));
const td = fn.LTR, aA = fn.RTL;
function Vk(o) {
  let e = [];
  for (let n = 0; n < o.length; n++)
    e.push(1 << +o[n]);
  return e;
}
const SQ = /* @__PURE__ */ Vk("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), TQ = /* @__PURE__ */ Vk("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ex = /* @__PURE__ */ Object.create(null), Zs = [];
for (let o of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ o.charCodeAt(0), n = /* @__PURE__ */ o.charCodeAt(1);
  Ex[e] = n, Ex[n] = -e;
}
function Xk(o) {
  return o <= 247 ? SQ[o] : 1424 <= o && o <= 1524 ? 2 : 1536 <= o && o <= 1785 ? TQ[o - 1536] : 1774 <= o && o <= 2220 ? 4 : 8192 <= o && o <= 8204 ? 256 : 64336 <= o && o <= 65023 ? 4 : 1;
}
const xQ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Wc {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? aA : td;
  }
  /**
  @internal
  */
  constructor(e, n, l) {
    this.from = e, this.to = n, this.level = l;
  }
  /**
  @internal
  */
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, n) {
    return e == (this.dir == n);
  }
  /**
  @internal
  */
  static find(e, n, l, s) {
    let c = -1;
    for (let d = 0; d < e.length; d++) {
      let m = e[d];
      if (m.from <= n && m.to >= n) {
        if (m.level == l)
          return d;
        (c < 0 || (s != 0 ? s < 0 ? m.from < n : m.to > n : e[c].level > m.level)) && (c = d);
      }
    }
    if (c < 0)
      throw new RangeError("Index out of range");
    return c;
  }
}
function jk(o, e) {
  if (o.length != e.length)
    return !1;
  for (let n = 0; n < o.length; n++) {
    let l = o[n], s = e[n];
    if (l.from != s.from || l.to != s.to || l.direction != s.direction || !jk(l.inner, s.inner))
      return !1;
  }
  return !0;
}
const nn = [];
function AQ(o, e, n, l, s) {
  for (let c = 0; c <= l.length; c++) {
    let d = c ? l[c - 1].to : e, m = c < l.length ? l[c].from : n, y = c ? 256 : s;
    for (let b = d, S = y, A = y; b < m; b++) {
      let w = Xk(o.charCodeAt(b));
      w == 512 ? w = S : w == 8 && A == 4 && (w = 16), nn[b] = w == 4 ? 2 : w, w & 7 && (A = w), S = w;
    }
    for (let b = d, S = y, A = y; b < m; b++) {
      let w = nn[b];
      if (w == 128)
        b < m - 1 && S == nn[b + 1] && S & 24 ? w = nn[b] = S : nn[b] = 256;
      else if (w == 64) {
        let E = b + 1;
        for (; E < m && nn[E] == 64; )
          E++;
        let z = b && S == 8 || E < n && nn[E] == 8 ? A == 1 ? 1 : 8 : 256;
        for (let U = b; U < E; U++)
          nn[U] = z;
        b = E - 1;
      } else w == 8 && A == 1 && (nn[b] = 1);
      S = w, w & 7 && (A = w);
    }
  }
}
function wQ(o, e, n, l, s) {
  let c = s == 1 ? 2 : 1;
  for (let d = 0, m = 0, y = 0; d <= l.length; d++) {
    let b = d ? l[d - 1].to : e, S = d < l.length ? l[d].from : n;
    for (let A = b, w, E, z; A < S; A++)
      if (E = Ex[w = o.charCodeAt(A)])
        if (E < 0) {
          for (let U = m - 3; U >= 0; U -= 3)
            if (Zs[U + 1] == -E) {
              let V = Zs[U + 2], G = V & 2 ? s : V & 4 ? V & 1 ? c : s : 0;
              G && (nn[A] = nn[Zs[U]] = G), m = U;
              break;
            }
        } else {
          if (Zs.length == 189)
            break;
          Zs[m++] = A, Zs[m++] = w, Zs[m++] = y;
        }
      else if ((z = nn[A]) == 2 || z == 1) {
        let U = z == s;
        y = U ? 0 : 1;
        for (let V = m - 3; V >= 0; V -= 3) {
          let G = Zs[V + 2];
          if (G & 2)
            break;
          if (U)
            Zs[V + 2] |= 2;
          else {
            if (G & 4)
              break;
            Zs[V + 2] |= 4;
          }
        }
      }
  }
}
function EQ(o, e, n, l) {
  for (let s = 0, c = l; s <= n.length; s++) {
    let d = s ? n[s - 1].to : o, m = s < n.length ? n[s].from : e;
    for (let y = d; y < m; ) {
      let b = nn[y];
      if (b == 256) {
        let S = y + 1;
        for (; ; )
          if (S == m) {
            if (s == n.length)
              break;
            S = n[s++].to, m = s < n.length ? n[s].from : e;
          } else if (nn[S] == 256)
            S++;
          else
            break;
        let A = c == 1, w = (S < e ? nn[S] : l) == 1, E = A == w ? A ? 1 : 2 : l;
        for (let z = S, U = s, V = U ? n[U - 1].to : o; z > y; )
          z == V && (z = n[--U].from, V = U ? n[U - 1].to : o), nn[--z] = E;
        y = S;
      } else
        c = b, y++;
    }
  }
}
function Cx(o, e, n, l, s, c, d) {
  let m = l % 2 ? 2 : 1;
  if (l % 2 == s % 2)
    for (let y = e, b = 0; y < n; ) {
      let S = !0, A = !1;
      if (b == c.length || y < c[b].from) {
        let U = nn[y];
        U != m && (S = !1, A = U == 16);
      }
      let w = !S && m == 1 ? [] : null, E = S ? l : l + 1, z = y;
      e: for (; ; )
        if (b < c.length && z == c[b].from) {
          if (A)
            break e;
          let U = c[b];
          if (!S)
            for (let V = U.to, G = b + 1; ; ) {
              if (V == n)
                break e;
              if (G < c.length && c[G].from == V)
                V = c[G++].to;
              else {
                if (nn[V] == m)
                  break e;
                break;
              }
            }
          if (b++, w)
            w.push(U);
          else {
            U.from > y && d.push(new Wc(y, U.from, E));
            let V = U.direction == td != !(E % 2);
            Rx(o, V ? l + 1 : l, s, U.inner, U.from, U.to, d), y = U.to;
          }
          z = U.to;
        } else {
          if (z == n || (S ? nn[z] != m : nn[z] == m))
            break;
          z++;
        }
      w ? Cx(o, y, z, l + 1, s, w, d) : y < z && d.push(new Wc(y, z, E)), y = z;
    }
  else
    for (let y = n, b = c.length; y > e; ) {
      let S = !0, A = !1;
      if (!b || y > c[b - 1].to) {
        let U = nn[y - 1];
        U != m && (S = !1, A = U == 16);
      }
      let w = !S && m == 1 ? [] : null, E = S ? l : l + 1, z = y;
      e: for (; ; )
        if (b && z == c[b - 1].to) {
          if (A)
            break e;
          let U = c[--b];
          if (!S)
            for (let V = U.from, G = b; ; ) {
              if (V == e)
                break e;
              if (G && c[G - 1].to == V)
                V = c[--G].from;
              else {
                if (nn[V - 1] == m)
                  break e;
                break;
              }
            }
          if (w)
            w.push(U);
          else {
            U.to < y && d.push(new Wc(U.to, y, E));
            let V = U.direction == td != !(E % 2);
            Rx(o, V ? l + 1 : l, s, U.inner, U.from, U.to, d), y = U.from;
          }
          z = U.from;
        } else {
          if (z == e || (S ? nn[z - 1] != m : nn[z - 1] == m))
            break;
          z--;
        }
      w ? Cx(o, z, y, l + 1, s, w, d) : z < y && d.push(new Wc(z, y, E)), y = z;
    }
}
function Rx(o, e, n, l, s, c, d) {
  let m = e % 2 ? 2 : 1;
  AQ(o, s, c, l, m), wQ(o, s, c, l, m), EQ(s, c, l, m), Cx(o, s, c, e, n, l, d);
}
function CQ(o, e, n) {
  if (!o)
    return [new Wc(0, 0, e == aA ? 1 : 0)];
  if (e == td && !n.length && !xQ.test(o))
    return Gk(o.length);
  if (n.length)
    for (; o.length > nn.length; )
      nn[nn.length] = 256;
  let l = [], s = e == td ? 0 : 1;
  return Rx(o, s, s, n, 0, o.length, l), l;
}
function Gk(o) {
  return [new Wc(0, o, 0)];
}
let Yk = "";
function RQ(o, e, n, l, s) {
  var c;
  let d = l.head - o.from, m = Wc.find(e, d, (c = l.bidiLevel) !== null && c !== void 0 ? c : -1, l.assoc), y = e[m], b = y.side(s, n);
  if (d == b) {
    let w = m += s ? 1 : -1;
    if (w < 0 || w >= e.length)
      return null;
    y = e[m = w], d = y.side(!s, n), b = y.side(s, n);
  }
  let S = Ni(o.text, d, y.forward(s, n));
  (S < y.from || S > y.to) && (S = b), Yk = o.text.slice(Math.min(d, S), Math.max(d, S));
  let A = m == (s ? e.length - 1 : 0) ? null : e[m + (s ? 1 : -1)];
  return A && S == b && A.level + (s ? 0 : 1) < y.level ? ve.cursor(A.side(!s, n) + o.from, A.forward(s, n) ? 1 : -1, A.level) : ve.cursor(S + o.from, y.forward(s, n) ? -1 : 1, y.level);
}
function kQ(o, e, n) {
  for (let l = e; l < n; l++) {
    let s = Xk(o.charCodeAt(l));
    if (s == 1)
      return td;
    if (s == 2 || s == 4)
      return aA;
  }
  return td;
}
const $k = /* @__PURE__ */ Be.define(), Zk = /* @__PURE__ */ Be.define(), Pk = /* @__PURE__ */ Be.define(), Wk = /* @__PURE__ */ Be.define(), kx = /* @__PURE__ */ Be.define(), Fk = /* @__PURE__ */ Be.define(), Kk = /* @__PURE__ */ Be.define(), oA = /* @__PURE__ */ Be.define(), sA = /* @__PURE__ */ Be.define(), Jk = /* @__PURE__ */ Be.define({
  combine: (o) => o.some((e) => e)
}), Ik = /* @__PURE__ */ Be.define({
  combine: (o) => o.some((e) => e)
}), eD = /* @__PURE__ */ Be.define();
class Dm {
  constructor(e, n = "nearest", l = "nearest", s = 5, c = 5, d = !1) {
    this.range = e, this.y = n, this.x = l, this.yMargin = s, this.xMargin = c, this.isSnapshot = d;
  }
  map(e) {
    return e.empty ? this : new Dm(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Dm(ve.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Nb = /* @__PURE__ */ it.define({ map: (o, e) => o.map(e) }), tD = /* @__PURE__ */ it.define();
function Zl(o, e, n) {
  let l = o.facet(Wk);
  l.length ? l[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const mu = /* @__PURE__ */ Be.define({ combine: (o) => o.length ? o[0] : !0 });
let DQ = 0;
const Jy = /* @__PURE__ */ Be.define();
class Bn {
  constructor(e, n, l, s, c) {
    this.id = e, this.create = n, this.domEventHandlers = l, this.domEventObservers = s, this.extension = c(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, n) {
    const { eventHandlers: l, eventObservers: s, provide: c, decorations: d } = n || {};
    return new Bn(DQ++, e, l, s, (m) => {
      let y = [Jy.of(m)];
      return d && y.push(dO.of((b) => {
        let S = b.plugin(m);
        return S ? d(S) : Ze.none;
      })), c && y.push(c(m)), y;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, n) {
    return Bn.define((l) => new e(l), n);
  }
}
class CT {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (l) {
            if (Zl(n.state, l, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Zl(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (l) {
        Zl(e.state, l, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const nD = /* @__PURE__ */ Be.define(), rA = /* @__PURE__ */ Be.define(), dO = /* @__PURE__ */ Be.define(), iD = /* @__PURE__ */ Be.define(), uA = /* @__PURE__ */ Be.define(), lD = /* @__PURE__ */ Be.define();
function gC(o, e) {
  let n = o.state.facet(lD);
  if (!n.length)
    return n;
  let l = n.map((c) => c instanceof Function ? c(o) : c), s = [];
  return Qt.spans(l, e.from, e.to, {
    point() {
    },
    span(c, d, m, y) {
      let b = c - e.from, S = d - e.from, A = s;
      for (let w = m.length - 1; w >= 0; w--, y--) {
        let E = m[w].spec.bidiIsolate, z;
        if (E == null && (E = kQ(e.text, b, S)), y > 0 && A.length && (z = A[A.length - 1]).to == b && z.direction == E)
          z.to = S, A = z.inner;
        else {
          let U = { from: b, to: S, direction: E, inner: [] };
          A.push(U), A = U.inner;
        }
      }
    }
  }), s;
}
const aD = /* @__PURE__ */ Be.define();
function cA(o) {
  let e = 0, n = 0, l = 0, s = 0;
  for (let c of o.state.facet(aD)) {
    let d = c(o);
    d && (d.left != null && (e = Math.max(e, d.left)), d.right != null && (n = Math.max(n, d.right)), d.top != null && (l = Math.max(l, d.top)), d.bottom != null && (s = Math.max(s, d.bottom)));
  }
  return { left: e, right: n, top: l, bottom: s };
}
const Iy = /* @__PURE__ */ Be.define();
class uo {
  constructor(e, n, l, s) {
    this.fromA = e, this.toA = n, this.fromB = l, this.toB = s;
  }
  join(e) {
    return new uo(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, l = this;
    for (; n > 0; n--) {
      let s = e[n - 1];
      if (!(s.fromA > l.toA)) {
        if (s.toA < l.fromA)
          break;
        l = l.join(s), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, l), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let l = [];
    for (let s = 0, c = 0, d = 0, m = 0; ; s++) {
      let y = s == e.length ? null : e[s], b = d - m, S = y ? y.fromB : 1e9;
      for (; c < n.length && n[c] < S; ) {
        let A = n[c], w = n[c + 1], E = Math.max(m, A), z = Math.min(S, w);
        if (E <= z && new uo(E + b, z + b, E, z).addToSet(l), w > S)
          break;
        c += 2;
      }
      if (!y)
        return l;
      new uo(y.fromA, y.toA, y.fromB, y.toB).addToSet(l), d = y.toA, m = y.toB;
    }
  }
}
class v1 {
  constructor(e, n, l) {
    this.view = e, this.state = n, this.transactions = l, this.flags = 0, this.startState = e.state, this.changes = ri.empty(this.startState.doc.length);
    for (let c of l)
      this.changes = this.changes.compose(c.changes);
    let s = [];
    this.changes.iterChangedRanges((c, d, m, y) => s.push(new uo(c, d, m, y))), this.changedRanges = s;
  }
  /**
  @internal
  */
  static create(e, n, l) {
    return new v1(e, n, l);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class yC extends ln {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Ze.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new $n()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new uo(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var n;
    let l = e.changedRanges;
    this.minWidth > 0 && l.length && (l.every(({ fromA: b, toA: S }) => S < this.minWidthFrom || b > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let s = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? s = this.domChanged.newSel.head : !qQ(e.changes, this.hasComposition) && !e.selectionSet && (s = e.state.selection.main.head));
    let c = s > -1 ? zQ(this.view, e.changes, s) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: b, to: S } = this.hasComposition;
      l = new uo(b, S, e.changes.mapPos(b, -1), e.changes.mapPos(S, 1)).addToSet(l.slice());
    }
    this.hasComposition = c ? { from: c.range.fromB, to: c.range.toB } : null, (qe.ie || qe.chrome) && !c && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let d = this.decorations, m = this.updateDeco(), y = UQ(d, m, e.changes);
    return l = uo.extendWithRanges(l, y), !(this.flags & 7) && l.length == 0 ? !1 : (this.updateInner(l, e.startState.doc.length, c), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, n, l) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, l);
    let { observer: s } = this.view;
    s.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let d = qe.chrome || qe.ios ? { node: s.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, d), this.flags &= -8, d && (d.written || s.selectionRange.focusNode != d.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (d) => d.flags &= -9
      /* ViewFlag.Composition */
    );
    let c = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let d of this.children)
        d instanceof gu && d.widget instanceof wx && c.push(d.dom);
    s.updateGaps(c);
  }
  updateChildren(e, n, l) {
    let s = l ? l.range.addToSet(e.slice()) : e, c = this.childCursor(n);
    for (let d = s.length - 1; ; d--) {
      let m = d >= 0 ? s[d] : null;
      if (!m)
        break;
      let { fromA: y, toA: b, fromB: S, toB: A } = m, w, E, z, U;
      if (l && l.range.fromB < A && l.range.toB > S) {
        let pe = oO.build(this.view.state.doc, S, l.range.fromB, this.decorations, this.dynamicDecorationMap), ne = oO.build(this.view.state.doc, l.range.toB, A, this.decorations, this.dynamicDecorationMap);
        E = pe.breakAtStart, z = pe.openStart, U = ne.openEnd;
        let ye = this.compositionView(l);
        ne.breakAtStart ? ye.breakAfter = 1 : ne.content.length && ye.merge(ye.length, ye.length, ne.content[0], !1, ne.openStart, 0) && (ye.breakAfter = ne.content[0].breakAfter, ne.content.shift()), pe.content.length && ye.merge(0, 0, pe.content[pe.content.length - 1], !0, 0, pe.openEnd) && pe.content.pop(), w = pe.content.concat(ye).concat(ne.content);
      } else
        ({ content: w, breakAtStart: E, openStart: z, openEnd: U } = oO.build(this.view.state.doc, S, A, this.decorations, this.dynamicDecorationMap));
      let { i: V, off: G } = c.findPos(b, 1), { i: ie, off: me } = c.findPos(y, -1);
      Qk(this, ie, me, V, G, w, E, z, U);
    }
    l && this.fixCompositionDOM(l);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let n of e.transactions)
      for (let l of n.effects)
        l.is(tD) && (this.editContextFormatting = l.value);
  }
  compositionView(e) {
    let n = new ns(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: s } of e.marks)
      n = new Ou(s, [n], n.length);
    let l = new $n();
    return l.append(n, 0), l;
  }
  fixCompositionDOM(e) {
    let n = (c, d) => {
      d.flags |= 8 | (d.children.some(
        (y) => y.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(d);
      let m = ln.get(c);
      m && m != d && (m.dom = null), d.setDOM(c);
    }, l = this.childPos(e.range.fromB, 1), s = this.children[l.i];
    n(e.line, s);
    for (let c = e.marks.length - 1; c >= -1; c--)
      l = s.childPos(l.off, 1), s = s.children[l.i], n(c >= 0 ? e.marks[c].node : e.text, s);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let l = this.view.root.activeElement, s = l == this.dom, c = !s && !(this.view.state.facet(mu) || this.dom.tabIndex > -1) && i1(this.dom, this.view.observer.selectionRange) && !(l && this.dom.contains(l));
    if (!(s || n || c))
      return;
    let d = this.forceSelection;
    this.forceSelection = !1;
    let m = this.view.state.selection.main, y = this.moveToLine(this.domAtPos(m.anchor)), b = m.empty ? y : this.moveToLine(this.domAtPos(m.head));
    if (qe.gecko && m.empty && !this.hasComposition && MQ(y)) {
      let A = document.createTextNode("");
      this.view.observer.ignore(() => y.node.insertBefore(A, y.node.childNodes[y.offset] || null)), y = b = new al(A, 0), d = !0;
    }
    let S = this.view.observer.selectionRange;
    (d || !S.focusNode || (!aO(y.node, y.offset, S.anchorNode, S.anchorOffset) || !aO(b.node, b.offset, S.focusNode, S.focusOffset)) && !this.suppressWidgetCursorChange(S, m)) && (this.view.observer.ignore(() => {
      qe.android && qe.chrome && this.dom.contains(S.focusNode) && BQ(S.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let A = hO(this.view.root);
      if (A) if (m.empty) {
        if (qe.gecko) {
          let w = QQ(y.node, y.offset);
          if (w && w != 3) {
            let E = (w == 1 ? Dk : Mk)(y.node, y.offset);
            E && (y = new al(E.node, E.offset));
          }
        }
        A.collapse(y.node, y.offset), m.bidiLevel != null && A.caretBidiLevel !== void 0 && (A.caretBidiLevel = m.bidiLevel);
      } else if (A.extend) {
        A.collapse(y.node, y.offset);
        try {
          A.extend(b.node, b.offset);
        } catch {
        }
      } else {
        let w = document.createRange();
        m.anchor > m.head && ([y, b] = [b, y]), w.setEnd(b.node, b.offset), w.setStart(y.node, y.offset), A.removeAllRanges(), A.addRange(w);
      }
      c && this.view.root.activeElement == this.dom && (this.dom.blur(), l && l.focus());
    }), this.view.observer.setSelectionRange(y, b)), this.impreciseAnchor = y.precise ? null : new al(S.anchorNode, S.anchorOffset), this.impreciseHead = b.precise ? null : new al(S.focusNode, S.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, n) {
    return this.hasComposition && n.empty && aO(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, l = hO(e.root), { anchorNode: s, anchorOffset: c } = e.observer.selectionRange;
    if (!l || !n.empty || !n.assoc || !l.modify)
      return;
    let d = $n.find(this, n.head);
    if (!d)
      return;
    let m = d.posAtStart;
    if (n.head == m || n.head == m + d.length)
      return;
    let y = this.coordsAt(n.head, -1), b = this.coordsAt(n.head, 1);
    if (!y || !b || y.bottom > b.top)
      return;
    let S = this.domAtPos(n.head + n.assoc);
    l.collapse(S.node, S.offset), l.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let A = e.observer.selectionRange;
    e.docView.posFromDOM(A.anchorNode, A.anchorOffset) != n.from && l.collapse(s, c);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let n = this.dom, l;
    if (e.node != n)
      return e;
    for (let s = e.offset; !l && s < n.childNodes.length; s++) {
      let c = ln.get(n.childNodes[s]);
      c instanceof $n && (l = c.domAtPos(0));
    }
    for (let s = e.offset - 1; !l && s >= 0; s--) {
      let c = ln.get(n.childNodes[s]);
      c instanceof $n && (l = c.domAtPos(c.length));
    }
    return l ? new al(l.node, l.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let l = ln.get(n);
      if (l && l.rootView == this)
        return l;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let l = this.nearest(e);
    if (!l)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return l.localPosFromDOM(e, n) + l.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: l } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let s = this.children[n];
      if (l < s.length || s instanceof $n)
        break;
      n++, l = 0;
    }
    return this.children[n].domAtPos(l);
  }
  coordsAt(e, n) {
    let l = null, s = 0;
    for (let c = this.length, d = this.children.length - 1; d >= 0; d--) {
      let m = this.children[d], y = c - m.breakAfter, b = y - m.length;
      if (y < e)
        break;
      if (b <= e && (b < e || m.covers(-1)) && (y > e || m.covers(1)) && (!l || m instanceof $n && !(l instanceof $n && n >= 0)))
        l = m, s = b;
      else if (l && b == e && y == e && m instanceof gu && Math.abs(n) < 2) {
        if (m.deco.startSide < 0)
          break;
        d && (l = null);
      }
      c = b;
    }
    return l ? l.coordsAt(e - s, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: l } = this.childPos(e, 1), s = this.children[n];
    if (!(s instanceof $n))
      return null;
    for (; s.children.length; ) {
      let { i: m, off: y } = s.childPos(l, 1);
      for (; ; m++) {
        if (m == s.children.length)
          return null;
        if ((s = s.children[m]).length)
          break;
      }
      l = y;
    }
    if (!(s instanceof ns))
      return null;
    let c = Ni(s.text, l);
    if (c == l)
      return null;
    let d = ed(s.dom, l, c).getClientRects();
    for (let m = 0; m < d.length; m++) {
      let y = d[m];
      if (m == d.length - 1 || y.top < y.bottom && y.left < y.right)
        return y;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: l, to: s } = e, c = this.view.contentDOM.clientWidth, d = c > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, m = -1, y = this.view.textDirection == fn.LTR;
    for (let b = 0, S = 0; S < this.children.length; S++) {
      let A = this.children[S], w = b + A.length;
      if (w > s)
        break;
      if (b >= l) {
        let E = A.dom.getBoundingClientRect();
        if (n.push(E.height), d) {
          let z = A.dom.lastChild, U = z ? Um(z) : [];
          if (U.length) {
            let V = U[U.length - 1], G = y ? V.right - E.left : E.right - V.left;
            G > m && (m = G, this.minWidth = c, this.minWidthFrom = b, this.minWidthTo = w);
          }
        }
      }
      b = w + A.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? fn.RTL : fn.LTR;
  }
  measureTextSize() {
    for (let c of this.children)
      if (c instanceof $n) {
        let d = c.measureTextSize();
        if (d)
          return d;
      }
    let e = document.createElement("div"), n, l, s;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let c = Um(e.firstChild)[0];
      n = e.getBoundingClientRect().height, l = c ? c.width / 27 : 7, s = c ? c.height : n, e.remove();
    }), { lineHeight: n, charWidth: l, textHeight: s };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new zk(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let l = 0, s = 0; ; s++) {
      let c = s == n.viewports.length ? null : n.viewports[s], d = c ? c.from - 1 : this.length;
      if (d > l) {
        let m = (n.lineBlockAt(d).bottom - n.lineBlockAt(l).top) / this.view.scaleY;
        e.push(Ze.replace({
          widget: new wx(m),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(l, d));
      }
      if (!c)
        break;
      l = c.to + 1;
    }
    return Ze.set(e);
  }
  updateDeco() {
    let e = 1, n = this.view.state.facet(dO).map((c) => (this.dynamicDecorationMap[e++] = typeof c == "function") ? c(this.view) : c), l = !1, s = this.view.state.facet(iD).map((c, d) => {
      let m = typeof c == "function";
      return m && (l = !0), m ? c(this.view) : c;
    });
    for (s.length && (this.dynamicDecorationMap[e++] = l, n.push(Qt.join(s))), this.decorations = [
      this.editContextFormatting,
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let b = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = b.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let b of this.view.state.facet(eD))
      try {
        if (b(this.view, e.range, e))
          return !0;
      } catch (S) {
        Zl(this.view.state, S, "scroll handler");
      }
    let { range: n } = e, l = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), s;
    if (!l)
      return;
    !n.empty && (s = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (l = {
      left: Math.min(l.left, s.left),
      top: Math.min(l.top, s.top),
      right: Math.max(l.right, s.right),
      bottom: Math.max(l.bottom, s.bottom)
    });
    let c = cA(this.view), d = {
      left: l.left - c.left,
      top: l.top - c.top,
      right: l.right + c.right,
      bottom: l.bottom + c.bottom
    }, { offsetWidth: m, offsetHeight: y } = this.view.scrollDOM;
    uQ(this.view.scrollDOM, d, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, m), -m), Math.max(Math.min(e.yMargin, y), -y), this.view.textDirection == fn.LTR);
  }
}
function MQ(o) {
  return o.node.nodeType == 1 && o.node.firstChild && (o.offset == 0 || o.node.childNodes[o.offset - 1].contentEditable == "false") && (o.offset == o.node.childNodes.length || o.node.childNodes[o.offset].contentEditable == "false");
}
function oD(o, e) {
  let n = o.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let l = Dk(n.focusNode, n.focusOffset), s = Mk(n.focusNode, n.focusOffset), c = l || s;
  if (s && l && s.node != l.node) {
    let m = ln.get(s.node);
    if (!m || m instanceof ns && m.text != s.node.nodeValue)
      c = s;
    else if (o.docView.lastCompositionAfterCursor) {
      let y = ln.get(l.node);
      !y || y instanceof ns && y.text != l.node.nodeValue || (c = s);
    }
  }
  if (o.docView.lastCompositionAfterCursor = c != l, !c)
    return null;
  let d = e - c.offset;
  return { from: d, to: d + c.node.nodeValue.length, node: c.node };
}
function zQ(o, e, n) {
  let l = oD(o, n);
  if (!l)
    return null;
  let { node: s, from: c, to: d } = l, m = s.nodeValue;
  if (/[\n\r]/.test(m) || o.state.doc.sliceString(l.from, l.to) != m)
    return null;
  let y = e.invertedDesc, b = new uo(y.mapPos(c), y.mapPos(d), c, d), S = [];
  for (let A = s.parentNode; ; A = A.parentNode) {
    let w = ln.get(A);
    if (w instanceof Ou)
      S.push({ node: A, deco: w.mark });
    else {
      if (w instanceof $n || A.nodeName == "DIV" && A.parentNode == o.contentDOM)
        return { range: b, text: s, marks: S, line: A };
      if (A != o.contentDOM)
        S.push({ node: A, deco: new CO({
          inclusive: !0,
          attributes: vQ(A),
          tagName: A.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function QQ(o, e) {
  return o.nodeType != 1 ? 0 : (e && o.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < o.childNodes.length && o.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let NQ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    l1(e, n, this.changes);
  }
  comparePoint(e, n) {
    l1(e, n, this.changes);
  }
  boundChange(e) {
    l1(e, e, this.changes);
  }
};
function UQ(o, e, n) {
  let l = new NQ();
  return Qt.compare(o, e, n, l), l.changes;
}
function BQ(o, e) {
  for (let n = o; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function qQ(o, e) {
  let n = !1;
  return e && o.iterChangedRanges((l, s) => {
    l < e.to && s > e.from && (n = !0);
  }), n;
}
function _Q(o, e, n = 1) {
  let l = o.charCategorizer(e), s = o.doc.lineAt(e), c = e - s.from;
  if (s.length == 0)
    return ve.cursor(e);
  c == 0 ? n = 1 : c == s.length && (n = -1);
  let d = c, m = c;
  n < 0 ? d = Ni(s.text, c, !1) : m = Ni(s.text, c);
  let y = l(s.text.slice(d, m));
  for (; d > 0; ) {
    let b = Ni(s.text, d, !1);
    if (l(s.text.slice(b, d)) != y)
      break;
    d = b;
  }
  for (; m < s.length; ) {
    let b = Ni(s.text, m);
    if (l(s.text.slice(m, b)) != y)
      break;
    m = b;
  }
  return ve.range(d + s.from, m + s.from);
}
function HQ(o, e) {
  return e.left > o ? e.left - o : Math.max(0, o - e.right);
}
function LQ(o, e) {
  return e.top > o ? e.top - o : Math.max(0, o - e.bottom);
}
function RT(o, e) {
  return o.top < e.bottom - 1 && o.bottom > e.top + 1;
}
function OC(o, e) {
  return e < o.top ? { top: e, left: o.left, right: o.right, bottom: o.bottom } : o;
}
function vC(o, e) {
  return e > o.bottom ? { top: o.top, left: o.left, right: o.right, bottom: e } : o;
}
function Dx(o, e, n) {
  let l, s, c, d, m = !1, y, b, S, A;
  for (let z = o.firstChild; z; z = z.nextSibling) {
    let U = Um(z);
    for (let V = 0; V < U.length; V++) {
      let G = U[V];
      s && RT(s, G) && (G = OC(vC(G, s.bottom), s.top));
      let ie = HQ(e, G), me = LQ(n, G);
      if (ie == 0 && me == 0)
        return z.nodeType == 3 ? bC(z, e, n) : Dx(z, e, n);
      if (!l || d > me || d == me && c > ie) {
        l = z, s = G, c = ie, d = me;
        let pe = me ? n < G.top ? -1 : 1 : ie ? e < G.left ? -1 : 1 : 0;
        m = !pe || (pe > 0 ? V < U.length - 1 : V > 0);
      }
      ie == 0 ? n > G.bottom && (!S || S.bottom < G.bottom) ? (y = z, S = G) : n < G.top && (!A || A.top > G.top) && (b = z, A = G) : S && RT(S, G) ? S = vC(S, G.bottom) : A && RT(A, G) && (A = OC(A, G.top));
    }
  }
  if (S && S.bottom >= n ? (l = y, s = S) : A && A.top <= n && (l = b, s = A), !l)
    return { node: o, offset: 0 };
  let w = Math.max(s.left, Math.min(s.right, e));
  if (l.nodeType == 3)
    return bC(l, w, n);
  if (m && l.contentEditable != "false")
    return Dx(l, w, n);
  let E = Array.prototype.indexOf.call(o.childNodes, l) + (e >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: o, offset: E };
}
function bC(o, e, n) {
  let l = o.nodeValue.length, s = -1, c = 1e9, d = 0;
  for (let m = 0; m < l; m++) {
    let y = ed(o, m, m + 1).getClientRects();
    for (let b = 0; b < y.length; b++) {
      let S = y[b];
      if (S.top == S.bottom)
        continue;
      d || (d = e - S.left);
      let A = (S.top > n ? S.top - n : n - S.bottom) - 1;
      if (S.left - 1 <= e && S.right + 1 >= e && A < c) {
        let w = e >= (S.left + S.right) / 2, E = w;
        if ((qe.chrome || qe.gecko) && ed(o, m).getBoundingClientRect().left == S.right && (E = !w), A <= 0)
          return { node: o, offset: m + (E ? 1 : 0) };
        s = m + (E ? 1 : 0), c = A;
      }
    }
  }
  return { node: o, offset: s > -1 ? s : d > 0 ? o.nodeValue.length : 0 };
}
function sD(o, e, n, l = -1) {
  var s, c;
  let d = o.contentDOM.getBoundingClientRect(), m = d.top + o.viewState.paddingTop, y, { docHeight: b } = o.viewState, { x: S, y: A } = e, w = A - m;
  if (w < 0)
    return 0;
  if (w > b)
    return o.state.doc.length;
  for (let pe = o.viewState.heightOracle.textHeight / 2, ne = !1; y = o.elementAtHeight(w), y.type != Al.Text; )
    for (; w = l > 0 ? y.bottom + pe : y.top - pe, !(w >= 0 && w <= b); ) {
      if (ne)
        return n ? null : 0;
      ne = !0, l = -l;
    }
  A = m + w;
  let E = y.from;
  if (E < o.viewport.from)
    return o.viewport.from == 0 ? 0 : n ? null : SC(o, d, y, S, A);
  if (E > o.viewport.to)
    return o.viewport.to == o.state.doc.length ? o.state.doc.length : n ? null : SC(o, d, y, S, A);
  let z = o.dom.ownerDocument, U = o.root.elementFromPoint ? o.root : z, V = U.elementFromPoint(S, A);
  V && !o.contentDOM.contains(V) && (V = null), V || (S = Math.max(d.left + 1, Math.min(d.right - 1, S)), V = U.elementFromPoint(S, A), V && !o.contentDOM.contains(V) && (V = null));
  let G, ie = -1;
  if (V && ((s = o.docView.nearest(V)) === null || s === void 0 ? void 0 : s.isEditable) != !1) {
    if (z.caretPositionFromPoint) {
      let pe = z.caretPositionFromPoint(S, A);
      pe && ({ offsetNode: G, offset: ie } = pe);
    } else if (z.caretRangeFromPoint) {
      let pe = z.caretRangeFromPoint(S, A);
      pe && ({ startContainer: G, startOffset: ie } = pe, (!o.contentDOM.contains(G) || qe.safari && VQ(G, ie, S) || qe.chrome && XQ(G, ie, S)) && (G = void 0));
    }
    G && (ie = Math.min(ar(G), ie));
  }
  if (!G || !o.docView.dom.contains(G)) {
    let pe = $n.find(o.docView, E);
    if (!pe)
      return w > y.top + y.height / 2 ? y.to : y.from;
    ({ node: G, offset: ie } = Dx(pe.dom, S, A));
  }
  let me = o.docView.nearest(G);
  if (!me)
    return null;
  if (me.isWidget && ((c = me.dom) === null || c === void 0 ? void 0 : c.nodeType) == 1) {
    let pe = me.dom.getBoundingClientRect();
    return e.y < pe.top || e.y <= pe.bottom && e.x <= (pe.left + pe.right) / 2 ? me.posAtStart : me.posAtEnd;
  } else
    return me.localPosFromDOM(G, ie) + me.posAtStart;
}
function SC(o, e, n, l, s) {
  let c = Math.round((l - e.left) * o.defaultCharacterWidth);
  if (o.lineWrapping && n.height > o.defaultLineHeight * 1.5) {
    let m = o.viewState.heightOracle.textHeight, y = Math.floor((s - n.top - (o.defaultLineHeight - m) * 0.5) / m);
    c += y * o.viewState.heightOracle.lineLength;
  }
  let d = o.state.sliceDoc(n.from, n.to);
  return n.from + gx(d, c, o.state.tabSize);
}
function VQ(o, e, n) {
  let l;
  if (o.nodeType != 3 || e != (l = o.nodeValue.length))
    return !1;
  for (let s = o.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return ed(o, l - 1, l).getBoundingClientRect().left > n;
}
function XQ(o, e, n) {
  if (e != 0)
    return !1;
  for (let s = o; ; ) {
    let c = s.parentNode;
    if (!c || c.nodeType != 1 || c.firstChild != s)
      return !1;
    if (c.classList.contains("cm-line"))
      break;
    s = c;
  }
  let l = o.nodeType == 1 ? o.getBoundingClientRect() : ed(o, 0, Math.max(o.nodeValue.length, 1)).getBoundingClientRect();
  return n - l.left > 5;
}
function Mx(o, e, n) {
  let l = o.lineBlockAt(e);
  if (Array.isArray(l.type)) {
    let s;
    for (let c of l.type) {
      if (c.from > e)
        break;
      if (!(c.to < e)) {
        if (c.from < e && c.to > e)
          return c;
        (!s || c.type == Al.Text && (s.type != c.type || (n < 0 ? c.from < e : c.to > e))) && (s = c);
      }
    }
    return s || l;
  }
  return l;
}
function jQ(o, e, n, l) {
  let s = Mx(o, e.head, e.assoc || -1), c = !l || s.type != Al.Text || !(o.lineWrapping || s.widgetLineBreaks) ? null : o.coordsAtPos(e.assoc < 0 && e.head > s.from ? e.head - 1 : e.head);
  if (c) {
    let d = o.dom.getBoundingClientRect(), m = o.textDirectionAt(s.from), y = o.posAtCoords({
      x: n == (m == fn.LTR) ? d.right - 1 : d.left + 1,
      y: (c.top + c.bottom) / 2
    });
    if (y != null)
      return ve.cursor(y, n ? -1 : 1);
  }
  return ve.cursor(n ? s.to : s.from, n ? -1 : 1);
}
function TC(o, e, n, l) {
  let s = o.state.doc.lineAt(e.head), c = o.bidiSpans(s), d = o.textDirectionAt(s.from);
  for (let m = e, y = null; ; ) {
    let b = RQ(s, c, d, m, n), S = Yk;
    if (!b) {
      if (s.number == (n ? o.state.doc.lines : 1))
        return m;
      S = `
`, s = o.state.doc.line(s.number + (n ? 1 : -1)), c = o.bidiSpans(s), b = o.visualLineSide(s, !n);
    }
    if (y) {
      if (!y(S))
        return m;
    } else {
      if (!l)
        return b;
      y = l(S);
    }
    m = b;
  }
}
function GQ(o, e, n) {
  let l = o.state.charCategorizer(e), s = l(n);
  return (c) => {
    let d = l(c);
    return s == yn.Space && (s = d), s == d;
  };
}
function YQ(o, e, n, l) {
  let s = e.head, c = n ? 1 : -1;
  if (s == (n ? o.state.doc.length : 0))
    return ve.cursor(s, e.assoc);
  let d = e.goalColumn, m, y = o.contentDOM.getBoundingClientRect(), b = o.coordsAtPos(s, e.assoc || -1), S = o.documentTop;
  if (b)
    d == null && (d = b.left - y.left), m = c < 0 ? b.top : b.bottom;
  else {
    let E = o.viewState.lineBlockAt(s);
    d == null && (d = Math.min(y.right - y.left, o.defaultCharacterWidth * (s - E.from))), m = (c < 0 ? E.top : E.bottom) + S;
  }
  let A = y.left + d, w = l ?? o.viewState.heightOracle.textHeight >> 1;
  for (let E = 0; ; E += 10) {
    let z = m + (w + E) * c, U = sD(o, { x: A, y: z }, !1, c);
    if (z < y.top || z > y.bottom || (c < 0 ? U < s : U > s)) {
      let V = o.docView.coordsForChar(U), G = !V || z < V.top ? -1 : 1;
      return ve.cursor(U, G, void 0, d);
    }
  }
}
function a1(o, e, n) {
  for (; ; ) {
    let l = 0;
    for (let s of o)
      s.between(e - 1, e + 1, (c, d, m) => {
        if (e > c && e < d) {
          let y = l || n || (e - c < d - e ? -1 : 1);
          e = y < 0 ? c : d, l = y;
        }
      });
    if (!l)
      return e;
  }
}
function kT(o, e, n) {
  let l = a1(o.state.facet(uA).map((s) => s(o)), n.from, e.head > n.from ? -1 : 1);
  return l == n.from ? n : ve.cursor(l, l < n.from ? 1 : -1);
}
const eO = "";
class $Q {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(At.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += eO;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let l = e.parentNode;
    for (let s = e; ; ) {
      this.findPointBefore(l, s);
      let c = this.text.length;
      this.readNode(s);
      let d = s.nextSibling;
      if (d == n)
        break;
      let m = ln.get(s), y = ln.get(d);
      (m && y ? m.breakAfter : (m ? m.breakAfter : y1(s)) || y1(d) && (s.nodeName != "BR" || s.cmIgnore) && this.text.length > c) && this.lineBreak(), s = d;
    }
    return this.findPointBefore(l, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let l of this.points)
      l.node == e && (l.pos = this.text.length + Math.min(l.offset, n.length));
    for (let l = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let c = -1, d = 1, m;
      if (this.lineSeparator ? (c = n.indexOf(this.lineSeparator, l), d = this.lineSeparator.length) : (m = s.exec(n)) && (c = m.index, d = m[0].length), this.append(n.slice(l, c < 0 ? n.length : c)), c < 0)
        break;
      if (this.lineBreak(), d > 1)
        for (let y of this.points)
          y.node == e && y.pos > this.text.length && (y.pos -= d - 1);
      l = c + d;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = ln.get(e), l = n && n.overrideDOMText;
    if (l != null) {
      this.findPointInside(e, l.length);
      for (let s = l.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let l of this.points)
      l.node == e && e.childNodes[l.offset] == n && (l.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let l of this.points)
      (e.nodeType == 3 ? l.node == e : e.contains(l.node)) && (l.pos = this.text.length + (ZQ(e, l.node, l.offset) ? n : 0));
  }
}
function ZQ(o, e, n) {
  for (; ; ) {
    if (!e || n < ar(e))
      return !1;
    if (e == o)
      return !0;
    n = Ih(e) + 1, e = e.parentNode;
  }
}
class xC {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class PQ {
  constructor(e, n, l, s) {
    this.typeOver = s, this.bounds = null, this.text = "", this.domChanged = n > -1;
    let { impreciseHead: c, impreciseAnchor: d } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, l, 0))) {
      let m = c || d ? [] : KQ(e), y = new $Q(m, e.state);
      y.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = y.text, this.newSel = JQ(m, this.bounds.from);
    } else {
      let m = e.observer.selectionRange, y = c && c.node == m.focusNode && c.offset == m.focusOffset || !vx(e.contentDOM, m.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(m.focusNode, m.focusOffset), b = d && d.node == m.anchorNode && d.offset == m.anchorOffset || !vx(e.contentDOM, m.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(m.anchorNode, m.anchorOffset), S = e.viewport;
      if ((qe.ios || qe.chrome) && e.state.selection.main.empty && y != b && (S.from > 0 || S.to < e.state.doc.length)) {
        let A = Math.min(y, b), w = Math.max(y, b), E = S.from - A, z = S.to - w;
        (E == 0 || E == 1 || A == 0) && (z == 0 || z == -1 || w == e.state.doc.length) && (y = 0, b = e.state.doc.length);
      }
      this.newSel = ve.single(b, y);
    }
  }
}
function rD(o, e) {
  let n, { newSel: l } = e, s = o.state.selection.main, c = o.inputState.lastKeyTime > Date.now() - 100 ? o.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: d, to: m } = e.bounds, y = s.from, b = null;
    (c === 8 || qe.android && e.text.length < m - d) && (y = s.to, b = "end");
    let S = FQ(o.state.doc.sliceString(d, m, eO), e.text, y - d, b);
    S && (qe.chrome && c == 13 && S.toB == S.from + 2 && e.text.slice(S.from, S.toB) == eO + eO && S.toB--, n = {
      from: d + S.from,
      to: d + S.toA,
      insert: kt.of(e.text.slice(S.from, S.toB).split(eO))
    });
  } else l && (!o.hasFocus && o.state.facet(mu) || l.main.eq(s)) && (l = null);
  if (!n && !l)
    return !1;
  if (!n && e.typeOver && !s.empty && l && l.main.empty ? n = { from: s.from, to: s.to, insert: o.state.doc.slice(s.from, s.to) } : (qe.mac || qe.android) && n && n.from == n.to && n.from == s.head - 1 && /^\. ?$/.test(n.insert.toString()) && o.contentDOM.getAttribute("autocorrect") == "off" ? (l && n.insert.length == 2 && (l = ve.single(l.main.anchor - 1, l.main.head - 1)), n = { from: n.from, to: n.to, insert: kt.of([n.insert.toString().replace(".", " ")]) }) : n && n.from >= s.from && n.to <= s.to && (n.from != s.from || n.to != s.to) && s.to - s.from - (n.to - n.from) <= 4 ? n = {
    from: s.from,
    to: s.to,
    insert: o.state.doc.slice(s.from, n.from).append(n.insert).append(o.state.doc.slice(n.to, s.to))
  } : qe.chrome && n && n.from == n.to && n.from == s.head && n.insert.toString() == `
 ` && o.lineWrapping && (l && (l = ve.single(l.main.anchor - 1, l.main.head - 1)), n = { from: s.from, to: s.to, insert: kt.of([" "]) }), n)
    return fA(o, n, l, c);
  if (l && !l.main.eq(s)) {
    let d = !1, m = "select";
    return o.inputState.lastSelectionTime > Date.now() - 50 && (o.inputState.lastSelectionOrigin == "select" && (d = !0), m = o.inputState.lastSelectionOrigin), o.dispatch({ selection: l, scrollIntoView: d, userEvent: m }), !0;
  } else
    return !1;
}
function fA(o, e, n, l = -1) {
  if (qe.ios && o.inputState.flushIOSKey(e))
    return !0;
  let s = o.state.selection.main;
  if (qe.android && (e.to == s.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == s.from || e.from == s.from - 1 && o.state.sliceDoc(e.from, s.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && km(o.contentDOM, "Enter", 13) || (e.from == s.from - 1 && e.to == s.to && e.insert.length == 0 || l == 8 && e.insert.length < e.to - e.from && e.to > s.head) && km(o.contentDOM, "Backspace", 8) || e.from == s.from && e.to == s.to + 1 && e.insert.length == 0 && km(o.contentDOM, "Delete", 46)))
    return !0;
  let c = e.insert.toString();
  o.inputState.composing >= 0 && o.inputState.composing++;
  let d, m = () => d || (d = WQ(o, e, n));
  return o.state.facet(Fk).some((y) => y(o, e.from, e.to, c, m)) || o.dispatch(m()), !0;
}
function WQ(o, e, n) {
  let l, s = o.state, c = s.selection.main;
  if (e.from >= c.from && e.to <= c.to && e.to - e.from >= (c.to - c.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && o.inputState.composing < 0) {
    let m = c.from < e.from ? s.sliceDoc(c.from, e.from) : "", y = c.to > e.to ? s.sliceDoc(e.to, c.to) : "";
    l = s.replaceSelection(o.state.toText(m + e.insert.sliceString(0, void 0, o.state.lineBreak) + y));
  } else {
    let m = s.changes(e), y = n && n.main.to <= m.newLength ? n.main : void 0;
    if (s.selection.ranges.length > 1 && o.inputState.composing >= 0 && e.to <= c.to && e.to >= c.to - 10) {
      let b = o.state.sliceDoc(e.from, e.to), S, A = n && oD(o, n.main.head);
      if (A) {
        let z = e.insert.length - (e.to - e.from);
        S = { from: A.from, to: A.to - z };
      } else
        S = o.state.doc.lineAt(c.head);
      let w = c.to - e.to, E = c.to - c.from;
      l = s.changeByRange((z) => {
        if (z.from == c.from && z.to == c.to)
          return { changes: m, range: y || z.map(m) };
        let U = z.to - w, V = U - b.length;
        if (z.to - z.from != E || o.state.sliceDoc(V, U) != b || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        z.to >= S.from && z.from <= S.to)
          return { range: z };
        let G = s.changes({ from: V, to: U, insert: e.insert }), ie = z.to - c.to;
        return {
          changes: G,
          range: y ? ve.range(Math.max(0, y.anchor + ie), Math.max(0, y.head + ie)) : z.map(G)
        };
      });
    } else
      l = {
        changes: m,
        selection: y && s.selection.replaceRange(y)
      };
  }
  let d = "input.type";
  return (o.composing || o.inputState.compositionPendingChange && o.inputState.compositionEndedAt > Date.now() - 50) && (o.inputState.compositionPendingChange = !1, d += ".compose", o.inputState.compositionFirstChange && (d += ".start", o.inputState.compositionFirstChange = !1)), s.update(l, { userEvent: d, scrollIntoView: !0 });
}
function FQ(o, e, n, l) {
  let s = Math.min(o.length, e.length), c = 0;
  for (; c < s && o.charCodeAt(c) == e.charCodeAt(c); )
    c++;
  if (c == s && o.length == e.length)
    return null;
  let d = o.length, m = e.length;
  for (; d > 0 && m > 0 && o.charCodeAt(d - 1) == e.charCodeAt(m - 1); )
    d--, m--;
  if (l == "end") {
    let y = Math.max(0, c - Math.min(d, m));
    n -= d + y - c;
  }
  if (d < c && o.length < e.length) {
    let y = n <= c && n >= d ? c - n : 0;
    c -= y, m = c + (m - d), d = c;
  } else if (m < c) {
    let y = n <= c && n >= m ? c - n : 0;
    c -= y, d = c + (d - m), m = c;
  }
  return { from: c, toA: d, toB: m };
}
function KQ(o) {
  let e = [];
  if (o.root.activeElement != o.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: l, focusNode: s, focusOffset: c } = o.observer.selectionRange;
  return n && (e.push(new xC(n, l)), (s != n || c != l) && e.push(new xC(s, c))), e;
}
function JQ(o, e) {
  if (o.length == 0)
    return null;
  let n = o[0].pos, l = o.length == 2 ? o[1].pos : n;
  return n > -1 && l > -1 ? ve.single(n + e, l + e) : null;
}
class IQ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, qe.safari && e.contentDOM.addEventListener("input", () => null), qe.gecko && m4(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !s4(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, n) {
    let l = this.handlers[e];
    if (l) {
      for (let s of l.observers)
        s(this.view, n);
      for (let s of l.handlers) {
        if (n.defaultPrevented)
          break;
        if (s(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = e4(e), l = this.handlers, s = this.view.contentDOM;
    for (let c in n)
      if (c != "scroll") {
        let d = !n[c].handlers.length, m = l[c];
        m && d != !m.handlers.length && (s.removeEventListener(c, this.handleEvent), m = null), m || s.addEventListener(c, this.handleEvent, { passive: d });
      }
    for (let c in l)
      c != "scroll" && !n[c] && s.removeEventListener(c, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && cD.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), qe.android && qe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return qe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = uD.find((l) => l.keyCode == e.keyCode)) && !e.ctrlKey || t4.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, km(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : qe.safari && !qe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function AC(o, e) {
  return (n, l) => {
    try {
      return e.call(o, l, n);
    } catch (s) {
      Zl(n.state, s);
    }
  };
}
function e4(o) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(l) {
    return e[l] || (e[l] = { observers: [], handlers: [] });
  }
  for (let l of o) {
    let s = l.spec;
    if (s && s.domEventHandlers)
      for (let c in s.domEventHandlers) {
        let d = s.domEventHandlers[c];
        d && n(c).handlers.push(AC(l.value, d));
      }
    if (s && s.domEventObservers)
      for (let c in s.domEventObservers) {
        let d = s.domEventObservers[c];
        d && n(c).observers.push(AC(l.value, d));
      }
  }
  for (let l in is)
    n(l).handlers.push(is[l]);
  for (let l in co)
    n(l).observers.push(co[l]);
  return e;
}
const uD = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], t4 = "dthko", cD = [16, 17, 18, 20, 91, 92, 224, 225], Ub = 6;
function Bb(o) {
  return Math.max(0, o) * 0.7 + 8;
}
function n4(o, e) {
  return Math.max(Math.abs(o.clientX - e.clientX), Math.abs(o.clientY - e.clientY));
}
class i4 {
  constructor(e, n, l, s) {
    this.view = e, this.startEvent = n, this.style = l, this.mustSelect = s, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParents = cQ(e.contentDOM), this.atoms = e.state.facet(uA).map((d) => d(e));
    let c = e.contentDOM.ownerDocument;
    c.addEventListener("mousemove", this.move = this.move.bind(this)), c.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(At.allowMultipleSelections) && l4(e, n), this.dragging = o4(e, n) && dD(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && n4(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, l = 0, s = 0, c = 0, d = this.view.win.innerWidth, m = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: s, right: d } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: c, bottom: m } = this.scrollParents.y.getBoundingClientRect());
    let y = cA(this.view);
    e.clientX - y.left <= s + Ub ? n = -Bb(s - e.clientX) : e.clientX + y.right >= d - Ub && (n = Bb(e.clientX - d)), e.clientY - y.top <= c + Ub ? l = -Bb(c - e.clientY) : e.clientY + y.bottom >= m - Ub && (l = Bb(e.clientY - m)), this.setScrollSpeed(n, l);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: n } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), n && this.scrollParents.y && (this.scrollParents.y.scrollTop += n, n = 0), (e || n) && this.view.win.scrollBy(e, n), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let l = 0; l < e.ranges.length; l++) {
      let s = e.ranges[l], c = null;
      if (s.empty) {
        let d = a1(this.atoms, s.from, 0);
        d != s.from && (c = ve.cursor(d, -1));
      } else {
        let d = a1(this.atoms, s.from, -1), m = a1(this.atoms, s.to, 1);
        (d != s.from || m != s.to) && (c = ve.range(s.from == s.anchor ? d : m, s.from == s.head ? d : m));
      }
      c && (n || (n = e.ranges.slice()), n[l] = c);
    }
    return n ? ve.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, l = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !l.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: l,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((n) => n.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function l4(o, e) {
  let n = o.state.facet($k);
  return n.length ? n[0](e) : qe.mac ? e.metaKey : e.ctrlKey;
}
function a4(o, e) {
  let n = o.state.facet(Zk);
  return n.length ? n[0](e) : qe.mac ? !e.altKey : !e.ctrlKey;
}
function o4(o, e) {
  let { main: n } = o.state.selection;
  if (n.empty)
    return !1;
  let l = hO(o.root);
  if (!l || l.rangeCount == 0)
    return !0;
  let s = l.getRangeAt(0).getClientRects();
  for (let c = 0; c < s.length; c++) {
    let d = s[c];
    if (d.left <= e.clientX && d.right >= e.clientX && d.top <= e.clientY && d.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function s4(o, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, l; n != o.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (l = ln.get(n)) && l.ignoreEvent(e))
      return !1;
  return !0;
}
const is = /* @__PURE__ */ Object.create(null), co = /* @__PURE__ */ Object.create(null), fD = qe.ie && qe.ie_version < 15 || qe.ios && qe.webkit_version < 604;
function r4(o) {
  let e = o.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    o.focus(), n.remove(), hD(o, n.value);
  }, 50);
}
function G1(o, e, n) {
  for (let l of o.facet(e))
    n = l(n, o);
  return n;
}
function hD(o, e) {
  e = G1(o.state, oA, e);
  let { state: n } = o, l, s = 1, c = n.toText(e), d = c.lines == n.selection.ranges.length;
  if (zx != null && n.selection.ranges.every((y) => y.empty) && zx == c.toString()) {
    let y = -1;
    l = n.changeByRange((b) => {
      let S = n.doc.lineAt(b.from);
      if (S.from == y)
        return { range: b };
      y = S.from;
      let A = n.toText((d ? c.line(s++).text : e) + n.lineBreak);
      return {
        changes: { from: S.from, insert: A },
        range: ve.cursor(b.from + A.length)
      };
    });
  } else d ? l = n.changeByRange((y) => {
    let b = c.line(s++);
    return {
      changes: { from: y.from, to: y.to, insert: b.text },
      range: ve.cursor(y.from + b.length)
    };
  }) : l = n.replaceSelection(c);
  o.dispatch(l, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
co.scroll = (o) => {
  o.inputState.lastScrollTop = o.scrollDOM.scrollTop, o.inputState.lastScrollLeft = o.scrollDOM.scrollLeft;
};
is.keydown = (o, e) => (o.inputState.setSelectionOrigin("select"), e.keyCode == 27 && o.inputState.tabFocusMode != 0 && (o.inputState.tabFocusMode = Date.now() + 2e3), !1);
co.touchstart = (o, e) => {
  o.inputState.lastTouchTime = Date.now(), o.inputState.setSelectionOrigin("select.pointer");
};
co.touchmove = (o) => {
  o.inputState.setSelectionOrigin("select.pointer");
};
is.mousedown = (o, e) => {
  if (o.observer.flush(), o.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let l of o.state.facet(Pk))
    if (n = l(o, e), n)
      break;
  if (!n && e.button == 0 && (n = f4(o, e)), n) {
    let l = !o.hasFocus;
    o.inputState.startMouseSelection(new i4(o, e, n, l)), l && o.observer.ignore(() => {
      Ck(o.contentDOM);
      let c = o.root.activeElement;
      c && !c.contains(o.contentDOM) && c.blur();
    });
    let s = o.inputState.mouseSelection;
    if (s)
      return s.start(e), s.dragging === !1;
  }
  return !1;
};
function wC(o, e, n, l) {
  if (l == 1)
    return ve.cursor(e, n);
  if (l == 2)
    return _Q(o.state, e, n);
  {
    let s = $n.find(o.docView, e), c = o.state.doc.lineAt(s ? s.posAtEnd : e), d = s ? s.posAtStart : c.from, m = s ? s.posAtEnd : c.to;
    return m < o.state.doc.length && m == c.to && m++, ve.range(d, m);
  }
}
let EC = (o, e, n) => e >= n.top && e <= n.bottom && o >= n.left && o <= n.right;
function u4(o, e, n, l) {
  let s = $n.find(o.docView, e);
  if (!s)
    return 1;
  let c = e - s.posAtStart;
  if (c == 0)
    return 1;
  if (c == s.length)
    return -1;
  let d = s.coordsAt(c, -1);
  if (d && EC(n, l, d))
    return -1;
  let m = s.coordsAt(c, 1);
  return m && EC(n, l, m) ? 1 : d && d.bottom >= l ? -1 : 1;
}
function CC(o, e) {
  let n = o.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: u4(o, n, e.clientX, e.clientY) };
}
const c4 = qe.ie && qe.ie_version <= 11;
let RC = null, kC = 0, DC = 0;
function dD(o) {
  if (!c4)
    return o.detail;
  let e = RC, n = DC;
  return RC = o, DC = Date.now(), kC = !e || n > Date.now() - 400 && Math.abs(e.clientX - o.clientX) < 2 && Math.abs(e.clientY - o.clientY) < 2 ? (kC + 1) % 3 : 1;
}
function f4(o, e) {
  let n = CC(o, e), l = dD(e), s = o.state.selection;
  return {
    update(c) {
      c.docChanged && (n.pos = c.changes.mapPos(n.pos), s = s.map(c.changes));
    },
    get(c, d, m) {
      let y = CC(o, c), b, S = wC(o, y.pos, y.bias, l);
      if (n.pos != y.pos && !d) {
        let A = wC(o, n.pos, n.bias, l), w = Math.min(A.from, S.from), E = Math.max(A.to, S.to);
        S = w < S.from ? ve.range(w, E) : ve.range(E, w);
      }
      return d ? s.replaceRange(s.main.extend(S.from, S.to)) : m && l == 1 && s.ranges.length > 1 && (b = h4(s, y.pos)) ? b : m ? s.addRange(S) : ve.create([S]);
    }
  };
}
function h4(o, e) {
  for (let n = 0; n < o.ranges.length; n++) {
    let { from: l, to: s } = o.ranges[n];
    if (l <= e && s >= e)
      return ve.create(o.ranges.slice(0, n).concat(o.ranges.slice(n + 1)), o.mainIndex == n ? 0 : o.mainIndex - (o.mainIndex > n ? 1 : 0));
  }
  return null;
}
is.dragstart = (o, e) => {
  let { selection: { main: n } } = o.state;
  if (e.target.draggable) {
    let s = o.docView.nearest(e.target);
    if (s && s.isWidget) {
      let c = s.posAtStart, d = c + s.length;
      (c >= n.to || d <= n.from) && (n = ve.range(c, d));
    }
  }
  let { inputState: l } = o;
  return l.mouseSelection && (l.mouseSelection.dragging = !0), l.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", G1(o.state, sA, o.state.sliceDoc(n.from, n.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
is.dragend = (o) => (o.inputState.draggedContent = null, !1);
function MC(o, e, n, l) {
  if (n = G1(o.state, oA, n), !n)
    return;
  let s = o.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: c } = o.inputState, d = l && c && a4(o, e) ? { from: c.from, to: c.to } : null, m = { from: s, insert: n }, y = o.state.changes(d ? [d, m] : m);
  o.focus(), o.dispatch({
    changes: y,
    selection: { anchor: y.mapPos(s, -1), head: y.mapPos(s, 1) },
    userEvent: d ? "move.drop" : "input.drop"
  }), o.inputState.draggedContent = null;
}
is.drop = (o, e) => {
  if (!e.dataTransfer)
    return !1;
  if (o.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let l = Array(n.length), s = 0, c = () => {
      ++s == n.length && MC(o, e, l.filter((d) => d != null).join(o.state.lineBreak), !1);
    };
    for (let d = 0; d < n.length; d++) {
      let m = new FileReader();
      m.onerror = c, m.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(m.result) || (l[d] = m.result), c();
      }, m.readAsText(n[d]);
    }
    return !0;
  } else {
    let l = e.dataTransfer.getData("Text");
    if (l)
      return MC(o, e, l, !0), !0;
  }
  return !1;
};
is.paste = (o, e) => {
  if (o.state.readOnly)
    return !0;
  o.observer.flush();
  let n = fD ? null : e.clipboardData;
  return n ? (hD(o, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (r4(o), !1);
};
function d4(o, e) {
  let n = o.dom.parentNode;
  if (!n)
    return;
  let l = n.appendChild(document.createElement("textarea"));
  l.style.cssText = "position: fixed; left: -10000px; top: 10px", l.value = e, l.focus(), l.selectionEnd = e.length, l.selectionStart = 0, setTimeout(() => {
    l.remove(), o.focus();
  }, 50);
}
function p4(o) {
  let e = [], n = [], l = !1;
  for (let s of o.selection.ranges)
    s.empty || (e.push(o.sliceDoc(s.from, s.to)), n.push(s));
  if (!e.length) {
    let s = -1;
    for (let { from: c } of o.selection.ranges) {
      let d = o.doc.lineAt(c);
      d.number > s && (e.push(d.text), n.push({ from: d.from, to: Math.min(o.doc.length, d.to + 1) })), s = d.number;
    }
    l = !0;
  }
  return { text: G1(o, sA, e.join(o.lineBreak)), ranges: n, linewise: l };
}
let zx = null;
is.copy = is.cut = (o, e) => {
  let { text: n, ranges: l, linewise: s } = p4(o.state);
  if (!n && !s)
    return !1;
  zx = s ? n : null, e.type == "cut" && !o.state.readOnly && o.dispatch({
    changes: l,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let c = fD ? null : e.clipboardData;
  return c ? (c.clearData(), c.setData("text/plain", n), !0) : (d4(o, n), !1);
};
const pD = /* @__PURE__ */ or.define();
function mD(o, e) {
  let n = [];
  for (let l of o.facet(Kk)) {
    let s = l(o, e);
    s && n.push(s);
  }
  return n.length ? o.update({ effects: n, annotations: pD.of(!0) }) : null;
}
function gD(o) {
  setTimeout(() => {
    let e = o.hasFocus;
    if (e != o.inputState.notifiedFocused) {
      let n = mD(o.state, e);
      n ? o.dispatch(n) : o.update([]);
    }
  }, 10);
}
co.focus = (o) => {
  o.inputState.lastFocusTime = Date.now(), !o.scrollDOM.scrollTop && (o.inputState.lastScrollTop || o.inputState.lastScrollLeft) && (o.scrollDOM.scrollTop = o.inputState.lastScrollTop, o.scrollDOM.scrollLeft = o.inputState.lastScrollLeft), gD(o);
};
co.blur = (o) => {
  o.observer.clearSelectionRange(), gD(o);
};
co.compositionstart = co.compositionupdate = (o) => {
  o.observer.editContext || (o.inputState.compositionFirstChange == null && (o.inputState.compositionFirstChange = !0), o.inputState.composing < 0 && (o.inputState.composing = 0));
};
co.compositionend = (o) => {
  o.observer.editContext || (o.inputState.composing = -1, o.inputState.compositionEndedAt = Date.now(), o.inputState.compositionPendingKey = !0, o.inputState.compositionPendingChange = o.observer.pendingRecords().length > 0, o.inputState.compositionFirstChange = null, qe.chrome && qe.android ? o.observer.flushSoon() : o.inputState.compositionPendingChange ? Promise.resolve().then(() => o.observer.flush()) : setTimeout(() => {
    o.inputState.composing < 0 && o.docView.hasComposition && o.update([]);
  }, 50));
};
co.contextmenu = (o) => {
  o.inputState.lastContextMenu = Date.now();
};
is.beforeinput = (o, e) => {
  var n, l;
  if (e.inputType == "insertReplacementText" && o.observer.editContext) {
    let c = (n = e.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain"), d = e.getTargetRanges();
    if (c && d.length) {
      let m = d[0], y = o.posAtDOM(m.startContainer, m.startOffset), b = o.posAtDOM(m.endContainer, m.endOffset);
      return fA(o, { from: y, to: b, insert: o.state.toText(c) }, null), !0;
    }
  }
  let s;
  if (qe.chrome && qe.android && (s = uD.find((c) => c.inputType == e.inputType)) && (o.observer.delayAndroidKey(s.key, s.keyCode), s.key == "Backspace" || s.key == "Delete")) {
    let c = ((l = window.visualViewport) === null || l === void 0 ? void 0 : l.height) || 0;
    setTimeout(() => {
      var d;
      (((d = window.visualViewport) === null || d === void 0 ? void 0 : d.height) || 0) > c + 10 && o.hasFocus && (o.contentDOM.blur(), o.focus());
    }, 100);
  }
  return qe.ios && e.inputType == "deleteContentForward" && o.observer.flushSoon(), qe.safari && e.inputType == "insertText" && o.inputState.composing >= 0 && setTimeout(() => co.compositionend(o, e), 20), !1;
};
const zC = /* @__PURE__ */ new Set();
function m4(o) {
  zC.has(o) || (zC.add(o), o.addEventListener("copy", () => {
  }), o.addEventListener("cut", () => {
  }));
}
const QC = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let _m = !1;
function NC() {
  _m = !1;
}
class g4 {
  constructor(e) {
    this.lineWrapping = e, this.doc = kt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, n) {
    let l = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (l += Math.max(0, Math.ceil((n - e - l * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * l;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return QC.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let l = 0; l < e.length; l++) {
      let s = e[l];
      s < 0 ? l++ : this.heightSamples[Math.floor(s * 10)] || (n = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, l, s, c, d) {
    let m = QC.indexOf(e) > -1, y = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != m;
    if (this.lineWrapping = m, this.lineHeight = n, this.charWidth = l, this.textHeight = s, this.lineLength = c, y) {
      this.heightSamples = {};
      for (let b = 0; b < d.length; b++) {
        let S = d[b];
        S < 0 ? b++ : this.heightSamples[Math.floor(S * 10)] = !0;
      }
    }
    return y;
  }
}
class y4 {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class er {
  /**
  @internal
  */
  constructor(e, n, l, s, c) {
    this.from = e, this.length = n, this.top = l, this.height = s, this._content = c;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Al.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Ic ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new er(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var cn = /* @__PURE__ */ function(o) {
  return o[o.ByPos = 0] = "ByPos", o[o.ByHeight = 1] = "ByHeight", o[o.ByPosNoHeight = 2] = "ByPosNoHeight", o;
}(cn || (cn = {}));
const o1 = 1e-3;
class wl {
  constructor(e, n, l = 2) {
    this.length = e, this.height = n, this.flags = l;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > o1 && (_m = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, n, l) {
    return wl.of(l);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, l, s) {
    let c = this, d = l.doc;
    for (let m = s.length - 1; m >= 0; m--) {
      let { fromA: y, toA: b, fromB: S, toB: A } = s[m], w = c.lineAt(y, cn.ByPosNoHeight, l.setDoc(n), 0, 0), E = w.to >= b ? w : c.lineAt(b, cn.ByPosNoHeight, l, 0, 0);
      for (A += E.to - b, b = E.to; m > 0 && w.from <= s[m - 1].toA; )
        y = s[m - 1].fromA, S = s[m - 1].fromB, m--, y < w.from && (w = c.lineAt(y, cn.ByPosNoHeight, l, 0, 0));
      S += w.from - y, y = w.from;
      let z = hA.build(l.setDoc(d), e, S, A);
      c = b1(c, c.replace(y, b, z));
    }
    return c.updateHeight(l, 0);
  }
  static empty() {
    return new Ra(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, l = e.length, s = 0, c = 0;
    for (; ; )
      if (n == l)
        if (s > c * 2) {
          let m = e[n - 1];
          m.break ? e.splice(--n, 1, m.left, null, m.right) : e.splice(--n, 1, m.left, m.right), l += 1 + m.break, s -= m.size;
        } else if (c > s * 2) {
          let m = e[l];
          m.break ? e.splice(l, 1, m.left, null, m.right) : e.splice(l, 1, m.left, m.right), l += 2 + m.break, c -= m.size;
        } else
          break;
      else if (s < c) {
        let m = e[n++];
        m && (s += m.size);
      } else {
        let m = e[--l];
        m && (c += m.size);
      }
    let d = 0;
    return e[n - 1] == null ? (d = 1, n--) : e[n] == null && (d = 1, l++), new O4(wl.of(e.slice(0, n)), d, wl.of(e.slice(l)));
  }
}
function b1(o, e) {
  return o == e ? o : (o.constructor != e.constructor && (_m = !0), e);
}
wl.prototype.size = 1;
class yD extends wl {
  constructor(e, n, l) {
    super(e, n), this.deco = l;
  }
  blockAt(e, n, l, s) {
    return new er(s, this.length, l, this.height, this.deco || 0);
  }
  lineAt(e, n, l, s, c) {
    return this.blockAt(0, l, s, c);
  }
  forEachLine(e, n, l, s, c, d) {
    e <= c + this.length && n >= c && d(this.blockAt(0, l, s, c));
  }
  updateHeight(e, n = 0, l = !1, s) {
    return s && s.from <= n && s.more && this.setHeight(s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ra extends yD {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, l, s) {
    return new er(s, this.length, l, this.height, this.breaks);
  }
  replace(e, n, l) {
    let s = l[0];
    return l.length == 1 && (s instanceof Ra || s instanceof Mi && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof Mi ? s = new Ra(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : wl.of(l);
  }
  updateHeight(e, n = 0, l = !1, s) {
    return s && s.from <= n && s.more ? this.setHeight(s.heights[s.index++]) : (l || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Mi extends wl {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let l = e.doc.lineAt(n).number, s = e.doc.lineAt(n + this.length).number, c = s - l + 1, d, m = 0;
    if (e.lineWrapping) {
      let y = Math.min(this.height, e.lineHeight * c);
      d = y / c, this.length > c + 1 && (m = (this.height - y) / (this.length - c - 1));
    } else
      d = this.height / c;
    return { firstLine: l, lastLine: s, perLine: d, perChar: m };
  }
  blockAt(e, n, l, s) {
    let { firstLine: c, lastLine: d, perLine: m, perChar: y } = this.heightMetrics(n, s);
    if (n.lineWrapping) {
      let b = s + (e < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - l) / this.height)) * this.length)), S = n.doc.lineAt(b), A = m + S.length * y, w = Math.max(l, e - A / 2);
      return new er(S.from, S.length, w, A, 0);
    } else {
      let b = Math.max(0, Math.min(d - c, Math.floor((e - l) / m))), { from: S, length: A } = n.doc.line(c + b);
      return new er(S, A, l + m * b, m, 0);
    }
  }
  lineAt(e, n, l, s, c) {
    if (n == cn.ByHeight)
      return this.blockAt(e, l, s, c);
    if (n == cn.ByPosNoHeight) {
      let { from: E, to: z } = l.doc.lineAt(e);
      return new er(E, z - E, 0, 0, 0);
    }
    let { firstLine: d, perLine: m, perChar: y } = this.heightMetrics(l, c), b = l.doc.lineAt(e), S = m + b.length * y, A = b.number - d, w = s + m * A + y * (b.from - c - A);
    return new er(b.from, b.length, Math.max(s, Math.min(w, s + this.height - S)), S, 0);
  }
  forEachLine(e, n, l, s, c, d) {
    e = Math.max(e, c), n = Math.min(n, c + this.length);
    let { firstLine: m, perLine: y, perChar: b } = this.heightMetrics(l, c);
    for (let S = e, A = s; S <= n; ) {
      let w = l.doc.lineAt(S);
      if (S == e) {
        let z = w.number - m;
        A += y * z + b * (e - c - z);
      }
      let E = y + b * w.length;
      d(new er(w.from, w.length, A, E, 0)), A += E, S = w.to + 1;
    }
  }
  replace(e, n, l) {
    let s = this.length - n;
    if (s > 0) {
      let c = l[l.length - 1];
      c instanceof Mi ? l[l.length - 1] = new Mi(c.length + s) : l.push(null, new Mi(s - 1));
    }
    if (e > 0) {
      let c = l[0];
      c instanceof Mi ? l[0] = new Mi(e + c.length) : l.unshift(new Mi(e - 1), null);
    }
    return wl.of(l);
  }
  decomposeLeft(e, n) {
    n.push(new Mi(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new Mi(this.length - e - 1));
  }
  updateHeight(e, n = 0, l = !1, s) {
    let c = n + this.length;
    if (s && s.from <= n + this.length && s.more) {
      let d = [], m = Math.max(n, s.from), y = -1;
      for (s.from > n && d.push(new Mi(s.from - n - 1).updateHeight(e, n)); m <= c && s.more; ) {
        let S = e.doc.lineAt(m).length;
        d.length && d.push(null);
        let A = s.heights[s.index++];
        y == -1 ? y = A : Math.abs(A - y) >= o1 && (y = -2);
        let w = new Ra(S, A);
        w.outdated = !1, d.push(w), m += S + 1;
      }
      m <= c && d.push(null, new Mi(c - m).updateHeight(e, m));
      let b = wl.of(d);
      return (y < 0 || Math.abs(b.height - this.height) >= o1 || Math.abs(y - this.heightMetrics(e, n).perLine) >= o1) && (_m = !0), b1(this, b);
    } else (l || this.outdated) && (this.setHeight(e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class O4 extends wl {
  constructor(e, n, l) {
    super(e.length + n + l.length, e.height + l.height, n | (e.outdated || l.outdated ? 2 : 0)), this.left = e, this.right = l, this.size = e.size + l.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, l, s) {
    let c = l + this.left.height;
    return e < c ? this.left.blockAt(e, n, l, s) : this.right.blockAt(e, n, c, s + this.left.length + this.break);
  }
  lineAt(e, n, l, s, c) {
    let d = s + this.left.height, m = c + this.left.length + this.break, y = n == cn.ByHeight ? e < d : e < m, b = y ? this.left.lineAt(e, n, l, s, c) : this.right.lineAt(e, n, l, d, m);
    if (this.break || (y ? b.to < m : b.from > m))
      return b;
    let S = n == cn.ByPosNoHeight ? cn.ByPosNoHeight : cn.ByPos;
    return y ? b.join(this.right.lineAt(m, S, l, d, m)) : this.left.lineAt(m, S, l, s, c).join(b);
  }
  forEachLine(e, n, l, s, c, d) {
    let m = s + this.left.height, y = c + this.left.length + this.break;
    if (this.break)
      e < y && this.left.forEachLine(e, n, l, s, c, d), n >= y && this.right.forEachLine(e, n, l, m, y, d);
    else {
      let b = this.lineAt(y, cn.ByPos, l, s, c);
      e < b.from && this.left.forEachLine(e, b.from - 1, l, s, c, d), b.to >= e && b.from <= n && d(b), n > b.to && this.right.forEachLine(b.to + 1, n, l, m, y, d);
    }
  }
  replace(e, n, l) {
    let s = this.left.length + this.break;
    if (n < s)
      return this.balanced(this.left.replace(e, n, l), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - s, n - s, l));
    let c = [];
    e > 0 && this.decomposeLeft(e, c);
    let d = c.length;
    for (let m of l)
      c.push(m);
    if (e > 0 && UC(c, d - 1), n < this.length) {
      let m = c.length;
      this.decomposeRight(n, c), UC(c, m);
    }
    return wl.of(c);
  }
  decomposeLeft(e, n) {
    let l = this.left.length;
    if (e <= l)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (l++, e >= l && n.push(null)), e > l && this.right.decomposeLeft(e - l, n);
  }
  decomposeRight(e, n) {
    let l = this.left.length, s = l + this.break;
    if (e >= s)
      return this.right.decomposeRight(e - s, n);
    e < l && this.left.decomposeRight(e, n), this.break && e < s && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? wl.of(this.break ? [e, null, n] : [e, n]) : (this.left = b1(this.left, e), this.right = b1(this.right, n), this.setHeight(e.height + n.height), this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, l = !1, s) {
    let { left: c, right: d } = this, m = n + c.length + this.break, y = null;
    return s && s.from <= n + c.length && s.more ? y = c = c.updateHeight(e, n, l, s) : c.updateHeight(e, n, l), s && s.from <= m + d.length && s.more ? y = d = d.updateHeight(e, m, l, s) : d.updateHeight(e, m, l), y ? this.balanced(c, d) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function UC(o, e) {
  let n, l;
  o[e] == null && (n = o[e - 1]) instanceof Mi && (l = o[e + 1]) instanceof Mi && o.splice(e - 1, 3, new Mi(n.length + 1 + l.length));
}
const v4 = 5;
class hA {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let l = Math.min(n, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Ra ? s.length += l - this.pos : (l > this.pos || !this.isCovered) && this.nodes.push(new Ra(l - this.pos, -1)), this.writtenTo = l, n > l && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, l) {
    if (e < n || l.heightRelevant) {
      let s = l.widget ? l.widget.estimatedHeight : 0, c = l.widget ? l.widget.lineBreaks : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let d = n - e;
      l.block ? this.addBlock(new yD(d, s, l)) : (d || c || s >= v4) && this.addLineDeco(s, c, d);
    } else n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Ra(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let l = new Mi(n - e);
    return this.oracle.doc.lineAt(e).to == n && (l.flags |= 4), l;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Ra)
      return e;
    let n = new Ra(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, l) {
    let s = this.ensureLine();
    s.length += l, s.collapsed += l, s.widgetHeight = Math.max(s.widgetHeight, e), s.breaks += n, this.writtenTo = this.pos = this.pos + l;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Ra) && !this.isCovered ? this.nodes.push(new Ra(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let l = e;
    for (let s of this.nodes)
      s instanceof Ra && s.updateHeight(this.oracle, l), l += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, n, l, s) {
    let c = new hA(l, e);
    return Qt.spans(n, l, s, c, 0), c.finish(l);
  }
}
function b4(o, e, n) {
  let l = new S4();
  return Qt.compare(o, e, n, l, 0), l.changes;
}
class S4 {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, l, s) {
    (e < n || l && l.heightRelevant || s && s.heightRelevant) && l1(e, n, this.changes, 5);
  }
}
function T4(o, e) {
  let n = o.getBoundingClientRect(), l = o.ownerDocument, s = l.defaultView || window, c = Math.max(0, n.left), d = Math.min(s.innerWidth, n.right), m = Math.max(0, n.top), y = Math.min(s.innerHeight, n.bottom);
  for (let b = o.parentNode; b && b != l.body; )
    if (b.nodeType == 1) {
      let S = b, A = window.getComputedStyle(S);
      if ((S.scrollHeight > S.clientHeight || S.scrollWidth > S.clientWidth) && A.overflow != "visible") {
        let w = S.getBoundingClientRect();
        c = Math.max(c, w.left), d = Math.min(d, w.right), m = Math.max(m, w.top), y = Math.min(b == o.parentNode ? s.innerHeight : y, w.bottom);
      }
      b = A.position == "absolute" || A.position == "fixed" ? S.offsetParent : S.parentNode;
    } else if (b.nodeType == 11)
      b = b.host;
    else
      break;
  return {
    left: c - n.left,
    right: Math.max(c, d) - n.left,
    top: m - (n.top + e),
    bottom: Math.max(m, y) - (n.top + e)
  };
}
function x4(o) {
  let e = o.getBoundingClientRect(), n = o.ownerDocument.defaultView || window;
  return e.left < n.innerWidth && e.right > 0 && e.top < n.innerHeight && e.bottom > 0;
}
function A4(o, e) {
  let n = o.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class DT {
  constructor(e, n, l, s) {
    this.from = e, this.to = n, this.size = l, this.displaySize = s;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let l = 0; l < e.length; l++) {
      let s = e[l], c = n[l];
      if (s.from != c.from || s.to != c.to || s.size != c.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return Ze.replace({
      widget: new w4(this.displaySize * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class w4 extends rr {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class BC {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = qC, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = fn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(rA).some((l) => typeof l != "function" && l.class == "cm-lineWrapping");
    this.heightOracle = new g4(n), this.stateDeco = e.facet(dO).filter((l) => typeof l != "function"), this.heightMap = wl.empty().applyChanges(this.stateDeco, kt.empty, this.heightOracle.setDoc(e.doc), [new uo(0, 0, 0, e.doc.length)]);
    for (let l = 0; l < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); l++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Ze.set(this.lineGaps.map((l) => l.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let l = 0; l <= 1; l++) {
      let s = l ? n.head : n.anchor;
      if (!e.some(({ from: c, to: d }) => s >= c && s <= d)) {
        let { from: c, to: d } = this.lineBlockAt(s);
        e.push(new qb(c, d));
      }
    }
    return this.viewports = e.sort((l, s) => l.from - s.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? qC : new dA(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(tO(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let l = this.stateDeco;
    this.stateDeco = this.state.facet(dO).filter((S) => typeof S != "function");
    let s = e.changedRanges, c = uo.extendWithRanges(s, b4(l, this.stateDeco, e ? e.changes : ri.empty(this.state.doc.length))), d = this.heightMap.height, m = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    NC(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), c), (this.heightMap.height != d || _m) && (e.flags |= 2), m ? (this.scrollAnchorPos = e.changes.mapPos(m.from, -1), this.scrollAnchorHeight = m.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = d);
    let y = c.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < y.from || n.range.head > y.to) || !this.viewportIsAppropriate(y)) && (y = this.getViewport(0, n));
    let b = y.from != this.viewport.from || y.to != this.viewport.to;
    this.viewport = y, e.flags |= this.updateForViewport(), (b || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Ik) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, l = window.getComputedStyle(n), s = this.heightOracle, c = l.whiteSpace;
    this.defaultTextDirection = l.direction == "rtl" ? fn.RTL : fn.LTR;
    let d = this.heightOracle.mustRefreshForWrapping(c), m = n.getBoundingClientRect(), y = d || this.mustMeasureContent || this.contentDOMHeight != m.height;
    this.contentDOMHeight = m.height, this.mustMeasureContent = !1;
    let b = 0, S = 0;
    if (m.width && m.height) {
      let { scaleX: pe, scaleY: ne } = Ek(n, m);
      (pe > 5e-3 && Math.abs(this.scaleX - pe) > 5e-3 || ne > 5e-3 && Math.abs(this.scaleY - ne) > 5e-3) && (this.scaleX = pe, this.scaleY = ne, b |= 16, d = y = !0);
    }
    let A = (parseInt(l.paddingTop) || 0) * this.scaleY, w = (parseInt(l.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != A || this.paddingBottom != w) && (this.paddingTop = A, this.paddingBottom = w, b |= 18), this.editorWidth != e.scrollDOM.clientWidth && (s.lineWrapping && (y = !0), this.editorWidth = e.scrollDOM.clientWidth, b |= 16);
    let E = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != E && (this.scrollAnchorHeight = -1, this.scrollTop = E), this.scrolledToBottom = kk(e.scrollDOM);
    let z = (this.printing ? A4 : T4)(n, this.paddingTop), U = z.top - this.pixelViewport.top, V = z.bottom - this.pixelViewport.bottom;
    this.pixelViewport = z;
    let G = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (G != this.inView && (this.inView = G, G && (y = !0)), !this.inView && !this.scrollTarget && !x4(e.dom))
      return 0;
    let ie = m.width;
    if ((this.contentDOMWidth != ie || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = m.width, this.editorHeight = e.scrollDOM.clientHeight, b |= 16), y) {
      let pe = e.docView.measureVisibleLineHeights(this.viewport);
      if (s.mustRefreshForHeights(pe) && (d = !0), d || s.lineWrapping && Math.abs(ie - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: ne, charWidth: ye, textHeight: Oe } = e.docView.measureTextSize();
        d = ne > 0 && s.refresh(c, ne, ye, Oe, ie / ye, pe), d && (e.docView.minWidth = 0, b |= 16);
      }
      U > 0 && V > 0 ? S = Math.max(U, V) : U < 0 && V < 0 && (S = Math.min(U, V)), NC();
      for (let ne of this.viewports) {
        let ye = ne.from == this.viewport.from ? pe : e.docView.measureVisibleLineHeights(ne);
        this.heightMap = (d ? wl.empty().applyChanges(this.stateDeco, kt.empty, this.heightOracle, [new uo(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(s, 0, d, new y4(ne.from, ye));
      }
      _m && (b |= 2);
    }
    let me = !this.viewportIsAppropriate(this.viewport, S) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return me && (b & 2 && (b |= this.updateScaler()), this.viewport = this.getViewport(S, this.scrollTarget), b |= this.updateForViewport()), (b & 2 || me) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(d ? [] : this.lineGaps, e)), b |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), b;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let l = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), s = this.heightMap, c = this.heightOracle, { visibleTop: d, visibleBottom: m } = this, y = new qb(s.lineAt(d - l * 1e3, cn.ByHeight, c, 0, 0).from, s.lineAt(m + (1 - l) * 1e3, cn.ByHeight, c, 0, 0).to);
    if (n) {
      let { head: b } = n.range;
      if (b < y.from || b > y.to) {
        let S = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), A = s.lineAt(b, cn.ByPos, c, 0, 0), w;
        n.y == "center" ? w = (A.top + A.bottom) / 2 - S / 2 : n.y == "start" || n.y == "nearest" && b < y.from ? w = A.top : w = A.bottom - S, y = new qb(s.lineAt(w - 1e3 / 2, cn.ByHeight, c, 0, 0).from, s.lineAt(w + S + 1e3 / 2, cn.ByHeight, c, 0, 0).to);
      }
    }
    return y;
  }
  mapViewport(e, n) {
    let l = n.mapPos(e.from, -1), s = n.mapPos(e.to, 1);
    return new qb(this.heightMap.lineAt(l, cn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s, cn.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: n }, l = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(e, cn.ByPos, this.heightOracle, 0, 0), { bottom: c } = this.heightMap.lineAt(n, cn.ByPos, this.heightOracle, 0, 0), { visibleTop: d, visibleBottom: m } = this;
    return (e == 0 || s <= d - Math.max(10, Math.min(
      -l,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || c >= m + Math.max(10, Math.min(
      l,
      250
      /* VP.MaxCoverMargin */
    ))) && s > d - 2 * 1e3 && c < m + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let l = [];
    for (let s of e)
      n.touchesRange(s.from, s.to) || l.push(new DT(n.mapPos(s.from), n.mapPos(s.to), s.size, s.displaySize));
    return l;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, n) {
    let l = this.heightOracle.lineWrapping, s = l ? 1e4 : 2e3, c = s >> 1, d = s << 1;
    if (this.defaultTextDirection != fn.LTR && !l)
      return [];
    let m = [], y = (S, A, w, E) => {
      if (A - S < c)
        return;
      let z = this.state.selection.main, U = [z.from];
      z.empty || U.push(z.to);
      for (let G of U)
        if (G > S && G < A) {
          y(S, G - 10, w, E), y(G + 10, A, w, E);
          return;
        }
      let V = C4(e, (G) => G.from >= w.from && G.to <= w.to && Math.abs(G.from - S) < c && Math.abs(G.to - A) < c && !U.some((ie) => G.from < ie && G.to > ie));
      if (!V) {
        if (A < w.to && n && l && n.visibleRanges.some((me) => me.from <= A && me.to >= A)) {
          let me = n.moveToLineBoundary(ve.cursor(A), !1, !0).head;
          me > S && (A = me);
        }
        let G = this.gapSize(w, S, A, E), ie = l || G < 2e6 ? G : 2e6;
        V = new DT(S, A, G, ie);
      }
      m.push(V);
    }, b = (S) => {
      if (S.length < d || S.type != Al.Text)
        return;
      let A = E4(S.from, S.to, this.stateDeco);
      if (A.total < d)
        return;
      let w = this.scrollTarget ? this.scrollTarget.range.head : null, E, z;
      if (l) {
        let U = s / this.heightOracle.lineLength * this.heightOracle.lineHeight, V, G;
        if (w != null) {
          let ie = Hb(A, w), me = ((this.visibleBottom - this.visibleTop) / 2 + U) / S.height;
          V = ie - me, G = ie + me;
        } else
          V = (this.visibleTop - S.top - U) / S.height, G = (this.visibleBottom - S.top + U) / S.height;
        E = _b(A, V), z = _b(A, G);
      } else {
        let U = A.total * this.heightOracle.charWidth, V = s * this.heightOracle.charWidth, G = 0;
        if (U > 2e6)
          for (let ye of e)
            ye.from >= S.from && ye.from < S.to && ye.size != ye.displaySize && ye.from * this.heightOracle.charWidth + G < this.pixelViewport.left && (G = ye.size - ye.displaySize);
        let ie = this.pixelViewport.left + G, me = this.pixelViewport.right + G, pe, ne;
        if (w != null) {
          let ye = Hb(A, w), Oe = ((me - ie) / 2 + V) / U;
          pe = ye - Oe, ne = ye + Oe;
        } else
          pe = (ie - V) / U, ne = (me + V) / U;
        E = _b(A, pe), z = _b(A, ne);
      }
      E > S.from && y(S.from, E, S, A), z < S.to && y(z, S.to, S, A);
    };
    for (let S of this.viewportLines)
      Array.isArray(S.type) ? S.type.forEach(b) : b(S);
    return m;
  }
  gapSize(e, n, l, s) {
    let c = Hb(s, l) - Hb(s, n);
    return this.heightOracle.lineWrapping ? e.height * c : s.total * this.heightOracle.charWidth * c;
  }
  updateLineGaps(e) {
    DT.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Ze.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let n = this.stateDeco;
    this.lineGaps.length && (n = n.concat(this.lineGapDeco));
    let l = [];
    Qt.spans(n, this.viewport.from, this.viewport.to, {
      span(c, d) {
        l.push({ from: c, to: d });
      },
      point() {
      }
    }, 20);
    let s = 0;
    if (l.length != this.visibleRanges.length)
      s = 12;
    else
      for (let c = 0; c < l.length && !(s & 8); c++) {
        let d = this.visibleRanges[c], m = l[c];
        (d.from != m.from || d.to != m.to) && (s |= 4, e && e.mapPos(d.from, -1) == m.from && e.mapPos(d.to, 1) == m.to || (s |= 8));
      }
    return this.visibleRanges = l, s;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || tO(this.heightMap.lineAt(e, cn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((n) => n.top <= e && n.bottom >= e) || tO(this.heightMap.lineAt(this.scaler.fromDOM(e), cn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return tO(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class qb {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function E4(o, e, n) {
  let l = [], s = o, c = 0;
  return Qt.spans(n, o, e, {
    span() {
    },
    point(d, m) {
      d > s && (l.push({ from: s, to: d }), c += d - s), s = m;
    }
  }, 20), s < e && (l.push({ from: s, to: e }), c += e - s), { total: c, ranges: l };
}
function _b({ total: o, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let l = Math.floor(o * n);
  for (let s = 0; ; s++) {
    let { from: c, to: d } = e[s], m = d - c;
    if (l <= m)
      return c + l;
    l -= m;
  }
}
function Hb(o, e) {
  let n = 0;
  for (let { from: l, to: s } of o.ranges) {
    if (e <= s) {
      n += e - l;
      break;
    }
    n += s - l;
  }
  return n / o.total;
}
function C4(o, e) {
  for (let n of o)
    if (e(n))
      return n;
}
const qC = {
  toDOM(o) {
    return o;
  },
  fromDOM(o) {
    return o;
  },
  scale: 1,
  eq(o) {
    return o == this;
  }
};
class dA {
  constructor(e, n, l) {
    let s = 0, c = 0, d = 0;
    this.viewports = l.map(({ from: m, to: y }) => {
      let b = n.lineAt(m, cn.ByPos, e, 0, 0).top, S = n.lineAt(y, cn.ByPos, e, 0, 0).bottom;
      return s += S - b, { from: m, to: y, top: b, bottom: S, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (n.height - s);
    for (let m of this.viewports)
      m.domTop = d + (m.top - c) * this.scale, d = m.domBottom = m.domTop + (m.bottom - m.top), c = m.bottom;
  }
  toDOM(e) {
    for (let n = 0, l = 0, s = 0; ; n++) {
      let c = n < this.viewports.length ? this.viewports[n] : null;
      if (!c || e < c.top)
        return s + (e - l) * this.scale;
      if (e <= c.bottom)
        return c.domTop + (e - c.top);
      l = c.bottom, s = c.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, l = 0, s = 0; ; n++) {
      let c = n < this.viewports.length ? this.viewports[n] : null;
      if (!c || e < c.domTop)
        return l + (e - s) / this.scale;
      if (e <= c.domBottom)
        return c.top + (e - c.domTop);
      l = c.bottom, s = c.domBottom;
    }
  }
  eq(e) {
    return e instanceof dA ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((n, l) => n.from == e.viewports[l].from && n.to == e.viewports[l].to) : !1;
  }
}
function tO(o, e) {
  if (e.scale == 1)
    return o;
  let n = e.toDOM(o.top), l = e.toDOM(o.bottom);
  return new er(o.from, o.length, n, l - n, Array.isArray(o._content) ? o._content.map((s) => tO(s, e)) : o._content);
}
const Lb = /* @__PURE__ */ Be.define({ combine: (o) => o.join(" ") }), Qx = /* @__PURE__ */ Be.define({ combine: (o) => o.indexOf(!0) > -1 }), Nx = /* @__PURE__ */ Kc.newName(), OD = /* @__PURE__ */ Kc.newName(), vD = /* @__PURE__ */ Kc.newName(), bD = { "&light": "." + OD, "&dark": "." + vD };
function Ux(o, e, n) {
  return new Kc(e, {
    finish(l) {
      return /&/.test(l) ? l.replace(/&\w*/, (s) => {
        if (s == "&")
          return o;
        if (!n || !n[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return n[s];
      }) : o + " " + l;
    }
  });
}
const R4 = /* @__PURE__ */ Ux("." + Nx, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, bD), k4 = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, MT = qe.ie && qe.ie_version <= 11;
class D4 {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new fQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let l of n)
        this.queue.push(l);
      (qe.ie && qe.ie_version <= 11 || qe.ios && e.composing) && n.some((l) => l.type == "childList" && l.removedNodes.length || l.type == "characterData" && l.oldValue.length > l.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(qe.chrome && qe.chrome_version < 126) && (this.editContext = new z4(e), e.state.facet(mu) && (e.contentDOM.editContext = this.editContext.editContext)), MT && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, l) => n != e[l]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: l } = this, s = this.selectionRange;
    if (l.state.facet(mu) ? l.root.activeElement != this.dom : !i1(this.dom, s))
      return;
    let c = s.anchorNode && l.docView.nearest(s.anchorNode);
    if (c && c.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (qe.ie && qe.ie_version <= 11 || qe.android && qe.chrome) && !l.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    s.focusNode && aO(s.focusNode, s.focusOffset, s.anchorNode, s.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = hO(e.root);
    if (!n)
      return !1;
    let l = qe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && M4(this.view, n) || n;
    if (!l || this.selectionRange.eq(l))
      return !1;
    let s = i1(this.dom, l);
    return s && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && dQ(this.dom, l) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(l), s && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let l = this.dom; l; )
      if (l.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == l ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(l), l = l.assignedSlot || l.parentNode;
      else if (l.nodeType == 11)
        l = l.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let l of this.scrollTargets)
        l.removeEventListener("scroll", this.onScroll);
      for (let l of this.scrollTargets = n)
        l.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, k4), MT && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), MT && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, n) {
    var l;
    if (!this.delayedAndroidKey) {
      let s = () => {
        let c = this.delayedAndroidKey;
        c && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = c.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && c.force && km(this.dom, c.key, c.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(s);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((l = this.delayedAndroidKey) === null || l === void 0) && l.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, l = -1, s = !1;
    for (let c of e) {
      let d = this.readMutation(c);
      d && (d.typeOver && (s = !0), n == -1 ? { from: n, to: l } = d : (n = Math.min(d.from, n), l = Math.max(d.to, l)));
    }
    return { from: n, to: l, typeOver: s };
  }
  readChange() {
    let { from: e, to: n, typeOver: l } = this.processRecords(), s = this.selectionChanged && i1(this.dom, this.selectionRange);
    if (e < 0 && !s)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let c = new PQ(this.view, e, n, l);
    return this.view.docView.domChanged = { newSel: c.newSel ? c.newSel.main : null }, c;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let l = this.view.state, s = rD(this.view, n);
    return this.view.state == l && (n.domChanged || n.newSel && !n.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let l = _C(n, e.previousSibling || e.target.previousSibling, -1), s = _C(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: l ? n.posAfter(l) : n.posAtStart,
        to: s ? n.posBefore(s) : n.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(mu) != e.state.facet(mu) && (e.view.contentDOM.editContext = e.state.facet(mu) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, n, l;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (l = this.resizeScroll) === null || l === void 0 || l.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function _C(o, e, n) {
  for (; e; ) {
    let l = ln.get(e);
    if (l && l.parent == o)
      return l;
    let s = e.parentNode;
    e = s != o.dom ? s : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function HC(o, e) {
  let n = e.startContainer, l = e.startOffset, s = e.endContainer, c = e.endOffset, d = o.docView.domAtPos(o.state.selection.main.anchor);
  return aO(d.node, d.offset, s, c) && ([n, l, s, c] = [s, c, n, l]), { anchorNode: n, anchorOffset: l, focusNode: s, focusOffset: c };
}
function M4(o, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(o.root)[0];
    if (s)
      return HC(o, s);
  }
  let n = null;
  function l(s) {
    s.preventDefault(), s.stopImmediatePropagation(), n = s.getTargetRanges()[0];
  }
  return o.contentDOM.addEventListener("beforeinput", l, !0), o.dom.ownerDocument.execCommand("indent"), o.contentDOM.removeEventListener("beforeinput", l, !0), n ? HC(o, n) : null;
}
class z4 {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let n = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (l) => {
      let s = e.state.selection.main, { anchor: c, head: d } = s, m = this.toEditorPos(l.updateRangeStart), y = this.toEditorPos(l.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: l.updateRangeStart, editorBase: m, drifted: !1 });
      let b = { from: m, to: y, insert: kt.of(l.text.split(`
`)) };
      if (b.from == this.from && c < this.from ? b.from = c : b.to == this.to && c > this.to && (b.to = c), b.from == b.to && !b.insert.length) {
        let S = ve.single(this.toEditorPos(l.selectionStart), this.toEditorPos(l.selectionEnd));
        S.main.eq(s) || e.dispatch({ selection: S, userEvent: "select" });
        return;
      }
      if ((qe.mac || qe.android) && b.from == d - 1 && /^\. ?$/.test(l.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (b = { from: m, to: y, insert: kt.of([l.text.replace(".", " ")]) }), this.pendingContextChange = b, !e.state.readOnly) {
        let S = this.to - this.from + (b.to - b.from + b.insert.length);
        fA(e, b, ve.single(this.toEditorPos(l.selectionStart, S), this.toEditorPos(l.selectionEnd, S)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state));
    }, this.handlers.characterboundsupdate = (l) => {
      let s = [], c = null;
      for (let d = this.toEditorPos(l.rangeStart), m = this.toEditorPos(l.rangeEnd); d < m; d++) {
        let y = e.coordsForChar(d);
        c = y && new DOMRect(y.left, y.top, y.right - y.left, y.bottom - y.top) || c || new DOMRect(), s.push(c);
      }
      n.updateCharacterBounds(l.rangeStart, s);
    }, this.handlers.textformatupdate = (l) => {
      let s = [];
      for (let c of l.getTextFormats()) {
        let d = c.underlineStyle, m = c.underlineThickness;
        if (d != "None" && m != "None") {
          let y = this.toEditorPos(c.rangeStart), b = this.toEditorPos(c.rangeEnd);
          if (y < b) {
            let S = `text-decoration: underline ${d == "Dashed" ? "dashed " : d == "Squiggle" ? "wavy " : ""}${m == "Thin" ? 1 : 2}px`;
            s.push(Ze.mark({ attributes: { style: S } }).range(y, b));
          }
        }
      }
      e.dispatch({ effects: tD.of(Ze.set(s)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: l } = this.composing;
        this.composing = null, l && this.reset(e.state);
      }
    };
    for (let l in this.handlers)
      n.addEventListener(l, this.handlers[l]);
    this.measureReq = { read: (l) => {
      this.editContext.updateControlBounds(l.contentDOM.getBoundingClientRect());
      let s = hO(l.root);
      s && s.rangeCount && this.editContext.updateSelectionBounds(s.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let n = 0, l = !1, s = this.pendingContextChange;
    return e.changes.iterChanges((c, d, m, y, b) => {
      if (l)
        return;
      let S = b.length - (d - c);
      if (s && d >= s.to)
        if (s.from == c && s.to == d && s.insert.eq(b)) {
          s = this.pendingContextChange = null, n += S, this.to += S;
          return;
        } else
          s = null, this.revertPending(e.state);
      if (c += n, d += n, d <= this.from)
        this.from += S, this.to += S;
      else if (c < this.to) {
        if (c < this.from || d > this.to || this.to - this.from + b.length > 3e4) {
          l = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(c), this.toContextPos(d), b.toString()), this.to += S;
      }
      n += S;
    }), s && !l && this.revertPending(e.state), !l;
  }
  update(e) {
    let n = this.pendingContextChange, l = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(l.from, l.to) && e.transactions.some((s) => !s.isUserEvent("input.type") && s.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || n) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: n } = e.selection.main;
    this.from = Math.max(
      0,
      n - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      n + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let n = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(n.from), this.toContextPos(n.from + n.insert.length), e.doc.sliceString(n.from, n.to));
  }
  setSelection(e) {
    let { main: n } = e.selection, l = this.toContextPos(Math.max(this.from, Math.min(this.to, n.anchor))), s = this.toContextPos(n.head);
    (this.editContext.selectionStart != l || this.editContext.selectionEnd != s) && this.editContext.updateSelection(l, s);
  }
  rangeIsValid(e) {
    let { head: n } = e.selection.main;
    return !(this.from > 0 && n - this.from < 500 || this.to < e.doc.length && this.to - n < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, n = this.to - this.from) {
    e = Math.min(e, n);
    let l = this.composing;
    return l && l.drifted ? l.editorBase + (e - l.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let n = this.composing;
    return n && n.drifted ? n.contextBase + (e - n.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class Me {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var n;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: l } = e;
    this.dispatchTransactions = e.dispatchTransactions || l && ((s) => s.forEach((c) => l(c, this))) || ((s) => this.update(s)), this.dispatch = this.dispatch.bind(this), this._root = e.root || hQ(e.parent) || document, this.viewState = new BC(e.state || At.create(e)), e.scrollTo && e.scrollTo.is(Nb) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Jy).map((s) => new CT(s));
    for (let s of this.plugins)
      s.update(this);
    this.observer = new D4(this), this.inputState = new IQ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new yC(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((n = document.fonts) === null || n === void 0) && n.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof Pn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, l = !1, s, c = this.state;
    for (let w of e) {
      if (w.startState != c)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      c = w.state;
    }
    if (this.destroyed) {
      this.viewState.state = c;
      return;
    }
    let d = this.hasFocus, m = 0, y = null;
    e.some((w) => w.annotation(pD)) ? (this.inputState.notifiedFocused = d, m = 1) : d != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = d, y = mD(c, d), y || (m = 1));
    let b = this.observer.delayedAndroidKey, S = null;
    if (b ? (this.observer.clearDelayedAndroidKey(), S = this.observer.readChange(), (S && !this.state.doc.eq(c.doc) || !this.state.selection.eq(c.selection)) && (S = null)) : this.observer.clear(), c.facet(At.phrases) != this.state.facet(At.phrases))
      return this.setState(c);
    s = v1.create(this, c, e), s.flags |= m;
    let A = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let w of e) {
        if (A && (A = A.map(w.changes)), w.scrollIntoView) {
          let { main: E } = w.state.selection;
          A = new Dm(E.empty ? E : ve.cursor(E.head, E.head > E.anchor ? -1 : 1));
        }
        for (let E of w.effects)
          E.is(Nb) && (A = E.value.clip(this.state));
      }
      this.viewState.update(s, A), this.bidiCache = S1.update(this.bidiCache, s.changes), s.empty || (this.updatePlugins(s), this.inputState.update(s)), n = this.docView.update(s), this.state.facet(Iy) != this.styleModules && this.mountStyles(), l = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((w) => w.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s.startState.facet(Lb) != s.state.facet(Lb) && (this.viewState.mustMeasureContent = !0), (n || l || A || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !s.empty)
      for (let w of this.state.facet(kx))
        try {
          w(s);
        } catch (E) {
          Zl(this.state, E, "update listener");
        }
    (y || S) && Promise.resolve().then(() => {
      y && this.state == y.startState && this.dispatch(y), S && !rD(this, S) && b.force && km(this.contentDOM, b.key, b.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let l of this.plugins)
        l.destroy(this);
      this.viewState = new BC(e), this.plugins = e.facet(Jy).map((l) => new CT(l)), this.pluginMap.clear();
      for (let l of this.plugins)
        l.update(this);
      this.docView.destroy(), this.docView = new yC(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(Jy), l = e.state.facet(Jy);
    if (n != l) {
      let s = [];
      for (let c of l) {
        let d = n.indexOf(c);
        if (d < 0)
          s.push(new CT(c));
        else {
          let m = this.plugins[d];
          m.mustUpdate = e, s.push(m);
        }
      }
      for (let c of this.plugins)
        c.mustUpdate != e && c.destroy(this);
      this.plugins = s, this.pluginMap.clear();
    } else
      for (let s of this.plugins)
        s.mustUpdate = e;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
    n != l && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let n = e.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (l) {
          Zl(this.state, l, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, l = this.scrollDOM, s = l.scrollTop * this.scaleY, { scrollAnchorPos: c, scrollAnchorHeight: d } = this.viewState;
    Math.abs(s - this.viewState.scrollTop) > 1 && (d = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let m = 0; ; m++) {
        if (d < 0)
          if (kk(l))
            c = -1, d = this.viewState.heightMap.height;
          else {
            let E = this.viewState.scrollAnchorAt(s);
            c = E.from, d = E.top;
          }
        this.updateState = 1;
        let y = this.viewState.measure(this);
        if (!y && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (m > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let b = [];
        y & 4 || ([this.measureRequests, b] = [b, this.measureRequests]);
        let S = b.map((E) => {
          try {
            return E.read(this);
          } catch (z) {
            return Zl(this.state, z), LC;
          }
        }), A = v1.create(this, this.state, []), w = !1;
        A.flags |= y, n ? n.flags |= y : n = A, this.updateState = 2, A.empty || (this.updatePlugins(A), this.inputState.update(A), this.updateAttrs(), w = this.docView.update(A), w && this.docViewUpdate());
        for (let E = 0; E < b.length; E++)
          if (S[E] != LC)
            try {
              let z = b[E];
              z.write && z.write(S[E], this);
            } catch (z) {
              Zl(this.state, z);
            }
        if (w && this.docView.updateSelection(!0), !A.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, d = -1;
              continue;
            } else {
              let z = (c < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(c).top) - d;
              if (z > 1 || z < -1) {
                s = s + z, l.scrollTop = s / this.scaleY, d = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let m of this.state.facet(kx))
        m(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Nx + " " + (this.state.facet(Qx) ? vD : OD) + " " + this.state.facet(Lb);
  }
  updateAttrs() {
    let e = VC(this, nD, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(mu) ? "true" : "false",
      class: "cm-content",
      style: `${qe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), VC(this, rA, n);
    let l = this.observer.ignore(() => {
      let s = Ax(this.contentDOM, this.contentAttrs, n), c = Ax(this.dom, this.editorAttrs, e);
      return s || c;
    });
    return this.editorAttrs = e, this.contentAttrs = n, l;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let l of e)
      for (let s of l.effects)
        if (s.is(Me.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let c = this.announceDOM.appendChild(document.createElement("div"));
          c.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Iy);
    let e = this.state.facet(Me.cspNonce);
    Kc.mount(this.root, this.styleModules.concat(R4).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((l) => l.spec == e) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.

  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, n, l) {
    return kT(this, e, TC(this, e, n, l));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, n) {
    return kT(this, e, TC(this, e, n, (l) => GQ(this, e.head, l)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, n) {
    let l = this.bidiSpans(e), s = this.textDirectionAt(e.from), c = l[n ? l.length - 1 : 0];
    return ve.cursor(c.side(n, s) + e.from, c.forward(!n, s) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, n, l = !0) {
    return jQ(this, e, n, l);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.

  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, n, l) {
    return kT(this, e, YQ(this, e, n, l));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.

  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), sD(this, e, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let l = this.docView.coordsAt(e, n);
    if (!l || l.left == l.right)
      return l;
    let s = this.state.doc.lineAt(e), c = this.bidiSpans(s), d = c[Wc.find(c, e - s.from, -1, n)];
    return EO(l, d.dir == fn.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Jk) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Q4)
      return Gk(e.length);
    let n = this.textDirectionAt(e.from), l;
    for (let c of this.bidiCache)
      if (c.from == e.from && c.dir == n && (c.fresh || jk(c.isolates, l = gC(this, e))))
        return c.order;
    l || (l = gC(this, e));
    let s = CQ(e.text, n, l);
    return this.bidiCache.push(new S1(e.from, e.to, n, l, !0, s)), s;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || qe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Ck(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, n = {}) {
    return Nb.of(new Dm(typeof e == "number" ? ve.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).

  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, l = this.viewState.scrollAnchorAt(e);
    return Nb.of(new Dm(ve.cursor(l.from), "start", "start", l.top - e, n, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.

  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Bn.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Bn.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.

  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.

  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, n) {
    let l = Kc.newName(), s = [Lb.of(l), Iy.of(Ux(`.${l}`, e))];
    return n && n.dark && s.push(Qx.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return nf.lowest(Iy.of(Ux("." + Nx, e, bD)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var n;
    let l = e.querySelector(".cm-content"), s = l && ln.get(l) || ln.get(e);
    return ((n = s == null ? void 0 : s.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
Me.styleModule = Iy;
Me.inputHandler = Fk;
Me.clipboardInputFilter = oA;
Me.clipboardOutputFilter = sA;
Me.scrollHandler = eD;
Me.focusChangeEffect = Kk;
Me.perLineTextDirection = Jk;
Me.exceptionSink = Wk;
Me.updateListener = kx;
Me.editable = mu;
Me.mouseSelectionStyle = Pk;
Me.dragMovesSelection = Zk;
Me.clickAddsSelectionRange = $k;
Me.decorations = dO;
Me.outerDecorations = iD;
Me.atomicRanges = uA;
Me.bidiIsolatedRanges = lD;
Me.scrollMargins = aD;
Me.darkTheme = Qx;
Me.cspNonce = /* @__PURE__ */ Be.define({ combine: (o) => o.length ? o[0] : "" });
Me.contentAttributes = rA;
Me.editorAttributes = nD;
Me.lineWrapping = /* @__PURE__ */ Me.contentAttributes.of({ class: "cm-lineWrapping" });
Me.announce = /* @__PURE__ */ it.define();
const Q4 = 4096, LC = {};
class S1 {
  constructor(e, n, l, s, c, d) {
    this.from = e, this.to = n, this.dir = l, this.isolates = s, this.fresh = c, this.order = d;
  }
  static update(e, n) {
    if (n.empty && !e.some((c) => c.fresh))
      return e;
    let l = [], s = e.length ? e[e.length - 1].dir : fn.LTR;
    for (let c = Math.max(0, e.length - 10); c < e.length; c++) {
      let d = e[c];
      d.dir == s && !n.touchesRange(d.from, d.to) && l.push(new S1(n.mapPos(d.from, 1), n.mapPos(d.to, -1), d.dir, d.isolates, !1, d.order));
    }
    return l;
  }
}
function VC(o, e, n) {
  for (let l = o.state.facet(e), s = l.length - 1; s >= 0; s--) {
    let c = l[s], d = typeof c == "function" ? c(o) : c;
    d && xx(d, n);
  }
  return n;
}
const N4 = qe.mac ? "mac" : qe.windows ? "win" : qe.linux ? "linux" : "key";
function U4(o, e) {
  const n = o.split(/-(?!$)/);
  let l = n[n.length - 1];
  l == "Space" && (l = " ");
  let s, c, d, m;
  for (let y = 0; y < n.length - 1; ++y) {
    const b = n[y];
    if (/^(cmd|meta|m)$/i.test(b))
      m = !0;
    else if (/^a(lt)?$/i.test(b))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(b))
      c = !0;
    else if (/^s(hift)?$/i.test(b))
      d = !0;
    else if (/^mod$/i.test(b))
      e == "mac" ? m = !0 : c = !0;
    else
      throw new Error("Unrecognized modifier name: " + b);
  }
  return s && (l = "Alt-" + l), c && (l = "Ctrl-" + l), m && (l = "Meta-" + l), d && (l = "Shift-" + l), l;
}
function Vb(o, e, n) {
  return e.altKey && (o = "Alt-" + o), e.ctrlKey && (o = "Ctrl-" + o), e.metaKey && (o = "Meta-" + o), n !== !1 && e.shiftKey && (o = "Shift-" + o), o;
}
const B4 = /* @__PURE__ */ nf.default(/* @__PURE__ */ Me.domEventHandlers({
  keydown(o, e) {
    return TD(SD(e.state), o, e, "editor");
  }
})), kO = /* @__PURE__ */ Be.define({ enables: B4 }), XC = /* @__PURE__ */ new WeakMap();
function SD(o) {
  let e = o.facet(kO), n = XC.get(e);
  return n || XC.set(e, n = H4(e.reduce((l, s) => l.concat(s), []))), n;
}
function q4(o, e, n) {
  return TD(SD(o.state), e, o, n);
}
let $c = null;
const _4 = 4e3;
function H4(o, e = N4) {
  let n = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null), s = (d, m) => {
    let y = l[d];
    if (y == null)
      l[d] = m;
    else if (y != m)
      throw new Error("Key binding " + d + " is used both as a regular binding and as a multi-stroke prefix");
  }, c = (d, m, y, b, S) => {
    var A, w;
    let E = n[d] || (n[d] = /* @__PURE__ */ Object.create(null)), z = m.split(/ (?!$)/).map((G) => U4(G, e));
    for (let G = 1; G < z.length; G++) {
      let ie = z.slice(0, G).join(" ");
      s(ie, !0), E[ie] || (E[ie] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(me) => {
          let pe = $c = { view: me, prefix: ie, scope: d };
          return setTimeout(() => {
            $c == pe && ($c = null);
          }, _4), !0;
        }]
      });
    }
    let U = z.join(" ");
    s(U, !1);
    let V = E[U] || (E[U] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((w = (A = E._any) === null || A === void 0 ? void 0 : A.run) === null || w === void 0 ? void 0 : w.slice()) || []
    });
    y && V.run.push(y), b && (V.preventDefault = !0), S && (V.stopPropagation = !0);
  };
  for (let d of o) {
    let m = d.scope ? d.scope.split(" ") : ["editor"];
    if (d.any)
      for (let b of m) {
        let S = n[b] || (n[b] = /* @__PURE__ */ Object.create(null));
        S._any || (S._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: A } = d;
        for (let w in S)
          S[w].run.push((E) => A(E, Bx));
      }
    let y = d[e] || d.key;
    if (y)
      for (let b of m)
        c(b, y, d.run, d.preventDefault, d.stopPropagation), d.shift && c(b, "Shift-" + y, d.shift, d.preventDefault, d.stopPropagation);
  }
  return n;
}
let Bx = null;
function TD(o, e, n, l) {
  Bx = e;
  let s = sQ(e), c = Gl(s, 0), d = Is(c) == s.length && s != " ", m = "", y = !1, b = !1, S = !1;
  $c && $c.view == n && $c.scope == l && (m = $c.prefix + " ", cD.indexOf(e.keyCode) < 0 && (b = !0, $c = null));
  let A = /* @__PURE__ */ new Set(), w = (V) => {
    if (V) {
      for (let G of V.run)
        if (!A.has(G) && (A.add(G), G(n)))
          return V.stopPropagation && (S = !0), !0;
      V.preventDefault && (V.stopPropagation && (S = !0), b = !0);
    }
    return !1;
  }, E = o[l], z, U;
  return E && (w(E[m + Vb(s, e, !d)]) ? y = !0 : d && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(qe.windows && e.ctrlKey && e.altKey) && (z = Jc[e.keyCode]) && z != s ? (w(E[m + Vb(z, e, !0)]) || e.shiftKey && (U = fO[e.keyCode]) != s && U != z && w(E[m + Vb(U, e, !1)])) && (y = !0) : d && e.shiftKey && w(E[m + Vb(s, e, !0)]) && (y = !0), !y && w(E._any) && (y = !0)), b && (y = !0), y && S && e.stopPropagation(), Bx = null, y;
}
class DO {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, n, l, s, c) {
    this.className = e, this.left = n, this.top = l, this.width = s, this.height = c;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, n, l) {
    if (l.empty) {
      let s = e.coordsAtPos(l.head, l.assoc || 1);
      if (!s)
        return [];
      let c = xD(e);
      return [new DO(n, s.left - c.left, s.top - c.top, null, s.bottom - s.top)];
    } else
      return L4(e, n, l);
  }
}
function xD(o) {
  let e = o.scrollDOM.getBoundingClientRect();
  return { left: (o.textDirection == fn.LTR ? e.left : e.right - o.scrollDOM.clientWidth * o.scaleX) - o.scrollDOM.scrollLeft * o.scaleX, top: e.top - o.scrollDOM.scrollTop * o.scaleY };
}
function jC(o, e, n, l) {
  let s = o.coordsAtPos(e, n * 2);
  if (!s)
    return l;
  let c = o.dom.getBoundingClientRect(), d = (s.top + s.bottom) / 2, m = o.posAtCoords({ x: c.left + 1, y: d }), y = o.posAtCoords({ x: c.right - 1, y: d });
  return m == null || y == null ? l : { from: Math.max(l.from, Math.min(m, y)), to: Math.min(l.to, Math.max(m, y)) };
}
function L4(o, e, n) {
  if (n.to <= o.viewport.from || n.from >= o.viewport.to)
    return [];
  let l = Math.max(n.from, o.viewport.from), s = Math.min(n.to, o.viewport.to), c = o.textDirection == fn.LTR, d = o.contentDOM, m = d.getBoundingClientRect(), y = xD(o), b = d.querySelector(".cm-line"), S = b && window.getComputedStyle(b), A = m.left + (S ? parseInt(S.paddingLeft) + Math.min(0, parseInt(S.textIndent)) : 0), w = m.right - (S ? parseInt(S.paddingRight) : 0), E = Mx(o, l, 1), z = Mx(o, s, -1), U = E.type == Al.Text ? E : null, V = z.type == Al.Text ? z : null;
  if (U && (o.lineWrapping || E.widgetLineBreaks) && (U = jC(o, l, 1, U)), V && (o.lineWrapping || z.widgetLineBreaks) && (V = jC(o, s, -1, V)), U && V && U.from == V.from && U.to == V.to)
    return ie(me(n.from, n.to, U));
  {
    let ne = U ? me(n.from, null, U) : pe(E, !1), ye = V ? me(null, n.to, V) : pe(z, !0), Oe = [];
    return (U || E).to < (V || z).from - (U && V ? 1 : 0) || E.widgetLineBreaks > 1 && ne.bottom + o.defaultLineHeight / 2 < ye.top ? Oe.push(G(A, ne.bottom, w, ye.top)) : ne.bottom < ye.top && o.elementAtHeight((ne.bottom + ye.top) / 2).type == Al.Text && (ne.bottom = ye.top = (ne.bottom + ye.top) / 2), ie(ne).concat(Oe).concat(ie(ye));
  }
  function G(ne, ye, Oe, we) {
    return new DO(e, ne - y.left, ye - y.top, Oe - ne, we - ye);
  }
  function ie({ top: ne, bottom: ye, horizontal: Oe }) {
    let we = [];
    for (let Re = 0; Re < Oe.length; Re += 2)
      we.push(G(Oe[Re], ne, Oe[Re + 1], ye));
    return we;
  }
  function me(ne, ye, Oe) {
    let we = 1e9, Re = -1e9, Te = [];
    function ze(Ve, Xe, F, Z, ge) {
      let Se = o.coordsAtPos(Ve, Ve == Oe.to ? -2 : 2), B = o.coordsAtPos(F, F == Oe.from ? 2 : -2);
      !Se || !B || (we = Math.min(Se.top, B.top, we), Re = Math.max(Se.bottom, B.bottom, Re), ge == fn.LTR ? Te.push(c && Xe ? A : Se.left, c && Z ? w : B.right) : Te.push(!c && Z ? A : B.left, !c && Xe ? w : Se.right));
    }
    let fe = ne ?? Oe.from, Qe = ye ?? Oe.to;
    for (let Ve of o.visibleRanges)
      if (Ve.to > fe && Ve.from < Qe)
        for (let Xe = Math.max(Ve.from, fe), F = Math.min(Ve.to, Qe); ; ) {
          let Z = o.state.doc.lineAt(Xe);
          for (let ge of o.bidiSpans(Z)) {
            let Se = ge.from + Z.from, B = ge.to + Z.from;
            if (Se >= F)
              break;
            B > Xe && ze(Math.max(Se, Xe), ne == null && Se <= fe, Math.min(B, F), ye == null && B >= Qe, ge.dir);
          }
          if (Xe = Z.to + 1, Xe >= F)
            break;
        }
    return Te.length == 0 && ze(fe, ne == null, Qe, ye == null, o.textDirection), { top: we, bottom: Re, horizontal: Te };
  }
  function pe(ne, ye) {
    let Oe = m.top + (ye ? ne.top : ne.bottom);
    return { top: Oe, bottom: Oe, horizontal: [] };
  }
}
function V4(o, e) {
  return o.constructor == e.constructor && o.eq(e);
}
class X4 {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(s1) != e.state.facet(s1) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let n = 0, l = e.facet(s1);
    for (; n < l.length && l[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, l) => !V4(n, this.drawn[l]))) {
      let n = this.dom.firstChild, l = 0;
      for (let s of e)
        s.update && n && s.constructor && this.drawn[l].constructor && s.update(n, this.drawn[l]) ? (n = n.nextSibling, l++) : this.dom.insertBefore(s.draw(), n);
      for (; n; ) {
        let s = n.nextSibling;
        n.remove(), n = s;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const s1 = /* @__PURE__ */ Be.define();
function AD(o) {
  return [
    Bn.define((e) => new X4(e, o)),
    s1.of(o)
  ];
}
const pO = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function j4(o = {}) {
  return [
    pO.of(o),
    G4,
    Y4,
    $4,
    Ik.of(!0)
  ];
}
function wD(o) {
  return o.startState.facet(pO) != o.state.facet(pO);
}
const G4 = /* @__PURE__ */ AD({
  above: !0,
  markers(o) {
    let { state: e } = o, n = e.facet(pO), l = [];
    for (let s of e.selection.ranges) {
      let c = s == e.selection.main;
      if (s.empty || n.drawRangeCursor) {
        let d = c ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", m = s.empty ? s : ve.cursor(s.head, s.head > s.anchor ? -1 : 1);
        for (let y of DO.forRange(o, d, m))
          l.push(y);
      }
    }
    return l;
  },
  update(o, e) {
    o.transactions.some((l) => l.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = wD(o);
    return n && GC(o.state, e), o.docChanged || o.selectionSet || n;
  },
  mount(o, e) {
    GC(e.state, o);
  },
  class: "cm-cursorLayer"
});
function GC(o, e) {
  e.style.animationDuration = o.facet(pO).cursorBlinkRate + "ms";
}
const Y4 = /* @__PURE__ */ AD({
  above: !1,
  markers(o) {
    return o.state.selection.ranges.map((e) => e.empty ? [] : DO.forRange(o, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(o, e) {
    return o.docChanged || o.selectionSet || o.viewportChanged || wD(o);
  },
  class: "cm-selectionLayer"
}), $4 = /* @__PURE__ */ nf.highest(/* @__PURE__ */ Me.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), ED = /* @__PURE__ */ it.define({
  map(o, e) {
    return o == null ? null : e.mapPos(o);
  }
}), nO = /* @__PURE__ */ Si.define({
  create() {
    return null;
  },
  update(o, e) {
    return o != null && (o = e.changes.mapPos(o)), e.effects.reduce((n, l) => l.is(ED) ? l.value : n, o);
  }
}), Z4 = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.view = o, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(o) {
    var e;
    let n = o.state.field(nO);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (o.startState.field(nO) != n || o.docChanged || o.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: o } = this, e = o.state.field(nO), n = e != null && o.coordsAtPos(e);
    if (!n)
      return null;
    let l = o.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - l.left + o.scrollDOM.scrollLeft * o.scaleX,
      top: n.top - l.top + o.scrollDOM.scrollTop * o.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(o) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      o ? (this.cursor.style.left = o.left / e + "px", this.cursor.style.top = o.top / n + "px", this.cursor.style.height = o.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(o) {
    this.view.state.field(nO) != o && this.view.dispatch({ effects: ED.of(o) });
  }
}, {
  eventObservers: {
    dragover(o) {
      this.setDropPos(this.view.posAtCoords({ x: o.clientX, y: o.clientY }));
    },
    dragleave(o) {
      (o.target == this.view.contentDOM || !this.view.contentDOM.contains(o.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function P4() {
  return [nO, Z4];
}
function YC(o, e, n, l, s) {
  e.lastIndex = 0;
  for (let c = o.iterRange(n, l), d = n, m; !c.next().done; d += c.value.length)
    if (!c.lineBreak)
      for (; m = e.exec(c.value); )
        s(d + m.index, m);
}
function W4(o, e) {
  let n = o.visibleRanges;
  if (n.length == 1 && n[0].from == o.viewport.from && n[0].to == o.viewport.to)
    return n;
  let l = [];
  for (let { from: s, to: c } of n)
    s = Math.max(o.state.doc.lineAt(s).from, s - e), c = Math.min(o.state.doc.lineAt(c).to, c + e), l.length && l[l.length - 1].to >= s ? l[l.length - 1].to = c : l.push({ from: s, to: c });
  return l;
}
class F4 {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: n, decoration: l, decorate: s, boundary: c, maxLength: d = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, s)
      this.addMatch = (m, y, b, S) => s(S, b, b + m[0].length, m, y);
    else if (typeof l == "function")
      this.addMatch = (m, y, b, S) => {
        let A = l(m, y, b);
        A && S(b, b + m[0].length, A);
      };
    else if (l)
      this.addMatch = (m, y, b, S) => S(b, b + m[0].length, l);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = c, this.maxLength = d;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let n = new yu(), l = n.add.bind(n);
    for (let { from: s, to: c } of W4(e, this.maxLength))
      YC(e.state.doc, this.regexp, s, c, (d, m) => this.addMatch(m, e, d, l));
    return n.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, n) {
    let l = 1e9, s = -1;
    return e.docChanged && e.changes.iterChanges((c, d, m, y) => {
      y >= e.view.viewport.from && m <= e.view.viewport.to && (l = Math.min(m, l), s = Math.max(y, s));
    }), e.viewportMoved || s - l > 1e3 ? this.createDeco(e.view) : s > -1 ? this.updateRange(e.view, n.map(e.changes), l, s) : n;
  }
  updateRange(e, n, l, s) {
    for (let c of e.visibleRanges) {
      let d = Math.max(c.from, l), m = Math.min(c.to, s);
      if (m > d) {
        let y = e.state.doc.lineAt(d), b = y.to < m ? e.state.doc.lineAt(m) : y, S = Math.max(c.from, y.from), A = Math.min(c.to, b.to);
        if (this.boundary) {
          for (; d > y.from; d--)
            if (this.boundary.test(y.text[d - 1 - y.from])) {
              S = d;
              break;
            }
          for (; m < b.to; m++)
            if (this.boundary.test(b.text[m - b.from])) {
              A = m;
              break;
            }
        }
        let w = [], E, z = (U, V, G) => w.push(G.range(U, V));
        if (y == b)
          for (this.regexp.lastIndex = S - y.from; (E = this.regexp.exec(y.text)) && E.index < A - y.from; )
            this.addMatch(E, e, E.index + y.from, z);
        else
          YC(e.state.doc, this.regexp, S, A, (U, V) => this.addMatch(V, e, U, z));
        n = n.update({ filterFrom: S, filterTo: A, filter: (U, V) => U < S || V > A, add: w });
      }
    }
    return n;
  }
}
const qx = /x/.unicode != null ? "gu" : "g", K4 = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, qx), J4 = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let zT = null;
function I4() {
  var o;
  if (zT == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    zT = ((o = e.tabSize) !== null && o !== void 0 ? o : e.MozTabSize) != null;
  }
  return zT || !1;
}
const r1 = /* @__PURE__ */ Be.define({
  combine(o) {
    let e = sr(o, {
      render: null,
      specialChars: K4,
      addSpecialChars: null
    });
    return (e.replaceTabs = !I4()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, qx)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, qx)), e;
  }
});
function e5(o = {}) {
  return [r1.of(o), t5()];
}
let $C = null;
function t5() {
  return $C || ($C = Bn.fromClass(class {
    constructor(o) {
      this.view = o, this.decorations = Ze.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(o.state.facet(r1)), this.decorations = this.decorator.createDeco(o);
    }
    makeDecorator(o) {
      return new F4({
        regexp: o.specialChars,
        decoration: (e, n, l) => {
          let { doc: s } = n.state, c = Gl(e[0], 0);
          if (c == 9) {
            let d = s.lineAt(l), m = n.state.tabSize, y = jm(d.text, m, l - d.from);
            return Ze.replace({
              widget: new a5((m - y % m) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[c] || (this.decorationCache[c] = Ze.replace({ widget: new l5(o, c) }));
        },
        boundary: o.replaceTabs ? void 0 : /[^]/
      });
    }
    update(o) {
      let e = o.state.facet(r1);
      o.startState.facet(r1) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(o.view)) : this.decorations = this.decorator.updateDeco(o, this.decorations);
    }
  }, {
    decorations: (o) => o.decorations
  }));
}
const n5 = "";
function i5(o) {
  return o >= 32 ? n5 : o == 10 ? "" : String.fromCharCode(9216 + o);
}
class l5 extends rr {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = i5(this.code), l = e.state.phrase("Control character") + " " + (J4[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, l, n);
    if (s)
      return s;
    let c = document.createElement("span");
    return c.textContent = n, c.title = l, c.setAttribute("aria-label", l), c.className = "cm-specialChar", c;
  }
  ignoreEvent() {
    return !1;
  }
}
class a5 extends rr {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function o5() {
  return r5;
}
const s5 = /* @__PURE__ */ Ze.line({ class: "cm-activeLine" }), r5 = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.decorations = this.getDeco(o);
  }
  update(o) {
    (o.docChanged || o.selectionSet) && (this.decorations = this.getDeco(o.view));
  }
  getDeco(o) {
    let e = -1, n = [];
    for (let l of o.state.selection.ranges) {
      let s = o.lineBlockAt(l.head);
      s.from > e && (n.push(s5.range(s.from)), e = s.from);
    }
    return Ze.set(n);
  }
}, {
  decorations: (o) => o.decorations
});
class u5 extends rr {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM(e) {
    let n = document.createElement("span");
    return n.className = "cm-placeholder", n.style.pointerEvents = "none", n.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(e) : this.content.cloneNode(!0)), n.setAttribute("aria-hidden", "true"), n;
  }
  coordsAt(e) {
    let n = e.firstChild ? Um(e.firstChild) : [];
    if (!n.length)
      return null;
    let l = window.getComputedStyle(e.parentNode), s = EO(n[0], l.direction != "rtl"), c = parseInt(l.lineHeight);
    return s.bottom - s.top > c * 1.5 ? { left: s.left, right: s.right, top: s.top, bottom: s.top + c } : s;
  }
  ignoreEvent() {
    return !1;
  }
}
function c5(o) {
  let e = Bn.fromClass(class {
    constructor(n) {
      this.view = n, this.placeholder = o ? Ze.set([Ze.widget({ widget: new u5(o), side: 1 }).range(0)]) : Ze.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Ze.none : this.placeholder;
    }
  }, { decorations: (n) => n.decorations });
  return typeof o == "string" ? [
    e,
    Me.contentAttributes.of({ "aria-placeholder": o })
  ] : e;
}
const _x = 2e3;
function f5(o, e, n) {
  let l = Math.min(e.line, n.line), s = Math.max(e.line, n.line), c = [];
  if (e.off > _x || n.off > _x || e.col < 0 || n.col < 0) {
    let d = Math.min(e.off, n.off), m = Math.max(e.off, n.off);
    for (let y = l; y <= s; y++) {
      let b = o.doc.line(y);
      b.length <= m && c.push(ve.range(b.from + d, b.to + m));
    }
  } else {
    let d = Math.min(e.col, n.col), m = Math.max(e.col, n.col);
    for (let y = l; y <= s; y++) {
      let b = o.doc.line(y), S = gx(b.text, d, o.tabSize, !0);
      if (S < 0)
        c.push(ve.cursor(b.to));
      else {
        let A = gx(b.text, m, o.tabSize);
        c.push(ve.range(b.from + S, b.from + A));
      }
    }
  }
  return c;
}
function h5(o, e) {
  let n = o.coordsAtPos(o.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / o.defaultCharacterWidth)) : -1;
}
function ZC(o, e) {
  let n = o.posAtCoords({ x: e.clientX, y: e.clientY }, !1), l = o.state.doc.lineAt(n), s = n - l.from, c = s > _x ? -1 : s == l.length ? h5(o, e.clientX) : jm(l.text, o.state.tabSize, n - l.from);
  return { line: l.number, col: c, off: s };
}
function d5(o, e) {
  let n = ZC(o, e), l = o.state.selection;
  return n ? {
    update(s) {
      if (s.docChanged) {
        let c = s.changes.mapPos(s.startState.doc.line(n.line).from), d = s.state.doc.lineAt(c);
        n = { line: d.number, col: n.col, off: Math.min(n.off, d.length) }, l = l.map(s.changes);
      }
    },
    get(s, c, d) {
      let m = ZC(o, s);
      if (!m)
        return l;
      let y = f5(o.state, n, m);
      return y.length ? d ? ve.create(y.concat(l.ranges)) : ve.create(y) : l;
    }
  } : null;
}
function p5(o) {
  let e = (n) => n.altKey && n.button == 0;
  return Me.mouseSelectionStyle.of((n, l) => e(l) ? d5(n, l) : null);
}
const m5 = {
  Alt: [18, (o) => !!o.altKey],
  Control: [17, (o) => !!o.ctrlKey],
  Shift: [16, (o) => !!o.shiftKey],
  Meta: [91, (o) => !!o.metaKey]
}, g5 = { style: "cursor: crosshair" };
function y5(o = {}) {
  let [e, n] = m5[o.key || "Alt"], l = Bn.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(s) {
        this.set(s.keyCode == e || n(s));
      },
      keyup(s) {
        (s.keyCode == e || !n(s)) && this.set(!1);
      },
      mousemove(s) {
        this.set(n(s));
      }
    }
  });
  return [
    l,
    Me.contentAttributes.of((s) => {
      var c;
      return !((c = s.plugin(l)) === null || c === void 0) && c.isDown ? g5 : null;
    })
  ];
}
const Zy = "-10000px";
class CD {
  constructor(e, n, l, s) {
    this.facet = n, this.createTooltipView = l, this.removeTooltipView = s, this.input = e.state.facet(n), this.tooltips = this.input.filter((d) => d);
    let c = null;
    this.tooltipViews = this.tooltips.map((d) => c = l(d, c));
  }
  update(e, n) {
    var l;
    let s = e.state.facet(this.facet), c = s.filter((y) => y);
    if (s === this.input) {
      for (let y of this.tooltipViews)
        y.update && y.update(e);
      return !1;
    }
    let d = [], m = n ? [] : null;
    for (let y = 0; y < c.length; y++) {
      let b = c[y], S = -1;
      if (b) {
        for (let A = 0; A < this.tooltips.length; A++) {
          let w = this.tooltips[A];
          w && w.create == b.create && (S = A);
        }
        if (S < 0)
          d[y] = this.createTooltipView(b, y ? d[y - 1] : null), m && (m[y] = !!b.above);
        else {
          let A = d[y] = this.tooltipViews[S];
          m && (m[y] = n[S]), A.update && A.update(e);
        }
      }
    }
    for (let y of this.tooltipViews)
      d.indexOf(y) < 0 && (this.removeTooltipView(y), (l = y.destroy) === null || l === void 0 || l.call(y));
    return n && (m.forEach((y, b) => n[b] = y), n.length = m.length), this.input = s, this.tooltips = c, this.tooltipViews = d, !0;
  }
}
function O5(o) {
  let e = o.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const QT = /* @__PURE__ */ Be.define({
  combine: (o) => {
    var e, n, l;
    return {
      position: qe.ios ? "absolute" : ((e = o.find((s) => s.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = o.find((s) => s.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((l = o.find((s) => s.tooltipSpace)) === null || l === void 0 ? void 0 : l.tooltipSpace) || O5
    };
  }
}), PC = /* @__PURE__ */ new WeakMap(), pA = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.view = o, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = o.state.facet(QT);
    this.position = e.position, this.parent = e.parent, this.classes = o.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new CD(o, mA, (n, l) => this.createTooltip(n, l), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), o.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let o of this.manager.tooltipViews)
        this.intersectionObserver.observe(o.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(o) {
    o.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(o, this.above);
    e && this.observeIntersection();
    let n = e || o.geometryChanged, l = o.state.facet(QT);
    if (l.position != this.position && !this.madeAbsolute) {
      this.position = l.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      n = !0;
    }
    if (l.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = l.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      n = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(o, e) {
    let n = o.create(this.view), l = e ? e.dom : null;
    if (n.dom.classList.add("cm-tooltip"), o.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let s = document.createElement("div");
      s.className = "cm-tooltip-arrow", n.dom.appendChild(s);
    }
    return n.dom.style.position = this.position, n.dom.style.top = Zy, n.dom.style.left = "0px", this.container.insertBefore(n.dom, l), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var o, e, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let l of this.manager.tooltipViews)
      l.dom.remove(), (o = l.destroy) === null || o === void 0 || o.call(l);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let o = 1, e = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: c } = this.manager.tooltipViews[0];
      if (qe.gecko)
        n = c.offsetParent != this.container.ownerDocument.body;
      else if (c.style.top == Zy && c.style.left == "0px") {
        let d = c.getBoundingClientRect();
        n = Math.abs(d.top + 1e4) > 1 || Math.abs(d.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let c = this.parent.getBoundingClientRect();
        c.width && c.height && (o = c.width / this.parent.offsetWidth, e = c.height / this.parent.offsetHeight);
      } else
        ({ scaleX: o, scaleY: e } = this.view.viewState);
    let l = this.view.scrollDOM.getBoundingClientRect(), s = cA(this.view);
    return {
      visible: {
        left: l.left + s.left,
        top: l.top + s.top,
        right: l.right - s.right,
        bottom: l.bottom - s.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((c, d) => {
        let m = this.manager.tooltipViews[d];
        return m.getCoords ? m.getCoords(c.pos) : this.view.coordsAtPos(c.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: c }) => c.getBoundingClientRect()),
      space: this.view.state.facet(QT).tooltipSpace(this.view),
      scaleX: o,
      scaleY: e,
      makeAbsolute: n
    };
  }
  writeMeasure(o) {
    var e;
    if (o.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let m of this.manager.tooltipViews)
        m.dom.style.position = "absolute";
    }
    let { visible: n, space: l, scaleX: s, scaleY: c } = o, d = [];
    for (let m = 0; m < this.manager.tooltips.length; m++) {
      let y = this.manager.tooltips[m], b = this.manager.tooltipViews[m], { dom: S } = b, A = o.pos[m], w = o.size[m];
      if (!A || y.clip !== !1 && (A.bottom <= Math.max(n.top, l.top) || A.top >= Math.min(n.bottom, l.bottom) || A.right < Math.max(n.left, l.left) - 0.1 || A.left > Math.min(n.right, l.right) + 0.1)) {
        S.style.top = Zy;
        continue;
      }
      let E = y.arrow ? b.dom.querySelector(".cm-tooltip-arrow") : null, z = E ? 7 : 0, U = w.right - w.left, V = (e = PC.get(b)) !== null && e !== void 0 ? e : w.bottom - w.top, G = b.offset || b5, ie = this.view.textDirection == fn.LTR, me = w.width > l.right - l.left ? ie ? l.left : l.right - w.width : ie ? Math.max(l.left, Math.min(A.left - (E ? 14 : 0) + G.x, l.right - U)) : Math.min(Math.max(l.left, A.left - U + (E ? 14 : 0) - G.x), l.right - U), pe = this.above[m];
      !y.strictSide && (pe ? A.top - V - z - G.y < l.top : A.bottom + V + z + G.y > l.bottom) && pe == l.bottom - A.bottom > A.top - l.top && (pe = this.above[m] = !pe);
      let ne = (pe ? A.top - l.top : l.bottom - A.bottom) - z;
      if (ne < V && b.resize !== !1) {
        if (ne < this.view.defaultLineHeight) {
          S.style.top = Zy;
          continue;
        }
        PC.set(b, V), S.style.height = (V = ne) / c + "px";
      } else S.style.height && (S.style.height = "");
      let ye = pe ? A.top - V - z - G.y : A.bottom + z + G.y, Oe = me + U;
      if (b.overlap !== !0)
        for (let we of d)
          we.left < Oe && we.right > me && we.top < ye + V && we.bottom > ye && (ye = pe ? we.top - V - 2 - z : we.bottom + z + 2);
      if (this.position == "absolute" ? (S.style.top = (ye - o.parent.top) / c + "px", WC(S, (me - o.parent.left) / s)) : (S.style.top = ye / c + "px", WC(S, me / s)), E) {
        let we = A.left + (ie ? G.x : -G.x) - (me + 14 - 7);
        E.style.left = we / s + "px";
      }
      b.overlap !== !0 && d.push({ left: me, top: ye, right: Oe, bottom: ye + V }), S.classList.toggle("cm-tooltip-above", pe), S.classList.toggle("cm-tooltip-below", !pe), b.positioned && b.positioned(o.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let o of this.manager.tooltipViews)
        o.dom.style.top = Zy;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function WC(o, e) {
  let n = parseInt(o.style.left, 10);
  (isNaN(n) || Math.abs(e - n) > 1) && (o.style.left = e + "px");
}
const v5 = /* @__PURE__ */ Me.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), b5 = { x: 0, y: 0 }, mA = /* @__PURE__ */ Be.define({
  enables: [pA, v5]
}), T1 = /* @__PURE__ */ Be.define({
  combine: (o) => o.reduce((e, n) => e.concat(n), [])
});
class Y1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Y1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new CD(e, T1, (n, l) => this.createHostedView(n, l), (n) => n.dom.remove());
  }
  createHostedView(e, n) {
    let l = e.create(this.view);
    return l.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(l.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && l.mount && l.mount(this.view), l;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let l of this.manager.tooltipViews) {
      let s = l[e];
      if (s !== void 0) {
        if (n === void 0)
          n = s;
        else if (n !== s)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const S5 = /* @__PURE__ */ mA.compute([T1], (o) => {
  let e = o.facet(T1);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var l;
      return (l = n.end) !== null && l !== void 0 ? l : n.pos;
    })),
    create: Y1.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class T5 {
  constructor(e, n, l, s, c) {
    this.view = e, this.source = n, this.field = l, this.setHover = s, this.hoverTime = c, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, l = e.docView.nearest(n.target);
    if (!l)
      return;
    let s, c = 1;
    if (l instanceof Pc)
      s = l.posAtStart;
    else {
      if (s = e.posAtCoords(n), s == null)
        return;
      let m = e.coordsAtPos(s);
      if (!m || n.y < m.top || n.y > m.bottom || n.x < m.left - e.defaultCharacterWidth || n.x > m.right + e.defaultCharacterWidth)
        return;
      let y = e.bidiSpans(e.state.doc.lineAt(s)).find((S) => S.from <= s && S.to >= s), b = y && y.dir == fn.RTL ? -1 : 1;
      c = n.x < m.left ? -b : b;
    }
    let d = this.source(e, s, c);
    if (d != null && d.then) {
      let m = this.pending = { pos: s };
      d.then((y) => {
        this.pending == m && (this.pending = null, y && !(Array.isArray(y) && !y.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(y) ? y : [y]) }));
      }, (y) => Zl(e.state, y, "hover tooltip"));
    } else d && !(Array.isArray(d) && !d.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(d) ? d : [d]) });
  }
  get tooltip() {
    let e = this.view.plugin(pA), n = e ? e.manager.tooltips.findIndex((l) => l.create == Y1.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n, l;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: s, tooltip: c } = this;
    if (s.length && c && !x5(c.dom, e) || this.pending) {
      let { pos: d } = s[0] || this.pending, m = (l = (n = s[0]) === null || n === void 0 ? void 0 : n.end) !== null && l !== void 0 ? l : d;
      (d == m ? this.view.posAtCoords(this.lastMove) != d : !A5(this.view, d, m, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: l } = this;
      l && l.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(l.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let n = (l) => {
      e.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(l.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Xb = 4;
function x5(o, e) {
  let { left: n, right: l, top: s, bottom: c } = o.getBoundingClientRect(), d;
  if (d = o.querySelector(".cm-tooltip-arrow")) {
    let m = d.getBoundingClientRect();
    s = Math.min(m.top, s), c = Math.max(m.bottom, c);
  }
  return e.clientX >= n - Xb && e.clientX <= l + Xb && e.clientY >= s - Xb && e.clientY <= c + Xb;
}
function A5(o, e, n, l, s, c) {
  let d = o.scrollDOM.getBoundingClientRect(), m = o.documentTop + o.documentPadding.top + o.contentHeight;
  if (d.left > l || d.right < l || d.top > s || Math.min(d.bottom, m) < s)
    return !1;
  let y = o.posAtCoords({ x: l, y: s }, !1);
  return y >= e && y <= n;
}
function w5(o, e = {}) {
  let n = it.define(), l = Si.define({
    create() {
      return [];
    },
    update(s, c) {
      if (s.length && (e.hideOnChange && (c.docChanged || c.selection) ? s = [] : e.hideOn && (s = s.filter((d) => !e.hideOn(c, d))), c.docChanged)) {
        let d = [];
        for (let m of s) {
          let y = c.changes.mapPos(m.pos, -1, Qi.TrackDel);
          if (y != null) {
            let b = Object.assign(/* @__PURE__ */ Object.create(null), m);
            b.pos = y, b.end != null && (b.end = c.changes.mapPos(b.end)), d.push(b);
          }
        }
        s = d;
      }
      for (let d of c.effects)
        d.is(n) && (s = d.value), d.is(E5) && (s = []);
      return s;
    },
    provide: (s) => T1.from(s)
  });
  return {
    active: l,
    extension: [
      l,
      Bn.define((s) => new T5(
        s,
        o,
        l,
        n,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      S5
    ]
  };
}
function RD(o, e) {
  let n = o.plugin(pA);
  if (!n)
    return null;
  let l = n.manager.tooltips.indexOf(e);
  return l < 0 ? null : n.manager.tooltipViews[l];
}
const E5 = /* @__PURE__ */ it.define(), FC = /* @__PURE__ */ Be.define({
  combine(o) {
    let e, n;
    for (let l of o)
      e = e || l.topContainer, n = n || l.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function mO(o, e) {
  let n = o.plugin(kD), l = n ? n.specs.indexOf(e) : -1;
  return l > -1 ? n.panels[l] : null;
}
const kD = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.input = o.state.facet(gO), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(o));
    let e = o.state.facet(FC);
    this.top = new jb(o, !0, e.topContainer), this.bottom = new jb(o, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(o) {
    let e = o.state.facet(FC);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new jb(o.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new jb(o.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = o.state.facet(gO);
    if (n != this.input) {
      let l = n.filter((y) => y), s = [], c = [], d = [], m = [];
      for (let y of l) {
        let b = this.specs.indexOf(y), S;
        b < 0 ? (S = y(o.view), m.push(S)) : (S = this.panels[b], S.update && S.update(o)), s.push(S), (S.top ? c : d).push(S);
      }
      this.specs = l, this.panels = s, this.top.sync(c), this.bottom.sync(d);
      for (let y of m)
        y.dom.classList.add("cm-panel"), y.mount && y.mount();
    } else
      for (let l of this.panels)
        l.update && l.update(o);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (o) => Me.scrollMargins.of((e) => {
    let n = e.plugin(o);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class jb {
  constructor(e, n, l) {
    this.view = e, this.top = n, this.container = l, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = KC(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = KC(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function KC(o) {
  let e = o.nextSibling;
  return o.remove(), e;
}
const gO = /* @__PURE__ */ Be.define({
  enables: kD
});
class vu extends Jh {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
vu.prototype.elementClass = "";
vu.prototype.toDOM = void 0;
vu.prototype.mapMode = Qi.TrackBefore;
vu.prototype.startSide = vu.prototype.endSide = -1;
vu.prototype.point = !0;
const u1 = /* @__PURE__ */ Be.define(), C5 = /* @__PURE__ */ Be.define(), R5 = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Qt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, sO = /* @__PURE__ */ Be.define();
function k5(o) {
  return [DD(), sO.of(Object.assign(Object.assign({}, R5), o))];
}
const JC = /* @__PURE__ */ Be.define({
  combine: (o) => o.some((e) => e)
});
function DD(o) {
  return [
    D5
  ];
}
const D5 = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.view = o, this.prevViewport = o.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = o.state.facet(sO).map((e) => new eR(o, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !o.state.facet(JC), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), o.scrollDOM.insertBefore(this.dom, o.contentDOM);
  }
  update(o) {
    if (this.updateGutters(o)) {
      let e = this.prevViewport, n = o.view.viewport, l = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(l < (n.to - n.from) * 0.8);
    }
    o.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(JC) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = o.view.viewport;
  }
  syncGutters(o) {
    let e = this.dom.nextSibling;
    o && this.dom.remove();
    let n = Qt.iter(this.view.state.facet(u1), this.view.viewport.from), l = [], s = this.gutters.map((c) => new M5(c, this.view.viewport, -this.view.documentPadding.top));
    for (let c of this.view.viewportLineBlocks)
      if (l.length && (l = []), Array.isArray(c.type)) {
        let d = !0;
        for (let m of c.type)
          if (m.type == Al.Text && d) {
            Hx(n, l, m.from);
            for (let y of s)
              y.line(this.view, m, l);
            d = !1;
          } else if (m.widget)
            for (let y of s)
              y.widget(this.view, m);
      } else if (c.type == Al.Text) {
        Hx(n, l, c.from);
        for (let d of s)
          d.line(this.view, c, l);
      } else if (c.widget)
        for (let d of s)
          d.widget(this.view, c);
    for (let c of s)
      c.finish();
    o && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(o) {
    let e = o.startState.facet(sO), n = o.state.facet(sO), l = o.docChanged || o.heightChanged || o.viewportChanged || !Qt.eq(o.startState.facet(u1), o.state.facet(u1), o.view.viewport.from, o.view.viewport.to);
    if (e == n)
      for (let s of this.gutters)
        s.update(o) && (l = !0);
    else {
      l = !0;
      let s = [];
      for (let c of n) {
        let d = e.indexOf(c);
        d < 0 ? s.push(new eR(this.view, c)) : (this.gutters[d].update(o), s.push(this.gutters[d]));
      }
      for (let c of this.gutters)
        c.dom.remove(), s.indexOf(c) < 0 && c.destroy();
      for (let c of s)
        this.dom.appendChild(c.dom);
      this.gutters = s;
    }
    return l;
  }
  destroy() {
    for (let o of this.gutters)
      o.destroy();
    this.dom.remove();
  }
}, {
  provide: (o) => Me.scrollMargins.of((e) => {
    let n = e.plugin(o);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == fn.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function IC(o) {
  return Array.isArray(o) ? o : [o];
}
function Hx(o, e, n) {
  for (; o.value && o.from <= n; )
    o.from == n && e.push(o.value), o.next();
}
class M5 {
  constructor(e, n, l) {
    this.gutter = e, this.height = l, this.i = 0, this.cursor = Qt.iter(e.markers, n.from);
  }
  addElement(e, n, l) {
    let { gutter: s } = this, c = (n.top - this.height) / e.scaleY, d = n.height / e.scaleY;
    if (this.i == s.elements.length) {
      let m = new MD(e, d, c, l);
      s.elements.push(m), s.dom.appendChild(m.dom);
    } else
      s.elements[this.i].update(e, d, c, l);
    this.height = n.bottom, this.i++;
  }
  line(e, n, l) {
    let s = [];
    Hx(this.cursor, s, n.from), l.length && (s = s.concat(l));
    let c = this.gutter.config.lineMarker(e, n, s);
    c && s.unshift(c);
    let d = this.gutter;
    s.length == 0 && !d.config.renderEmptyElements || this.addElement(e, n, s);
  }
  widget(e, n) {
    let l = this.gutter.config.widgetMarker(e, n.widget, n), s = l ? [l] : null;
    for (let c of e.state.facet(C5)) {
      let d = c(e, n.widget, n);
      d && (s || (s = [])).push(d);
    }
    s && this.addElement(e, n, s);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class eR {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let l in n.domEventHandlers)
      this.dom.addEventListener(l, (s) => {
        let c = s.target, d;
        if (c != this.dom && this.dom.contains(c)) {
          for (; c.parentNode != this.dom; )
            c = c.parentNode;
          let y = c.getBoundingClientRect();
          d = (y.top + y.bottom) / 2;
        } else
          d = s.clientY;
        let m = e.lineBlockAtHeight(d - e.documentTop);
        n.domEventHandlers[l](e, m, s) && s.preventDefault();
      });
    this.markers = IC(n.markers(e)), n.initialSpacer && (this.spacer = new MD(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = IC(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], e);
      s != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [s]);
    }
    let l = e.view.viewport;
    return !Qt.eq(this.markers, n, l.from, l.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class MD {
  constructor(e, n, l, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, l, s);
  }
  update(e, n, l, s) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != l && (this.dom.style.marginTop = (this.above = l) ? l + "px" : ""), z5(this.markers, s) || this.setMarkers(e, s);
  }
  setMarkers(e, n) {
    let l = "cm-gutterElement", s = this.dom.firstChild;
    for (let c = 0, d = 0; ; ) {
      let m = d, y = c < n.length ? n[c++] : null, b = !1;
      if (y) {
        let S = y.elementClass;
        S && (l += " " + S);
        for (let A = d; A < this.markers.length; A++)
          if (this.markers[A].compare(y)) {
            m = A, b = !0;
            break;
          }
      } else
        m = this.markers.length;
      for (; d < m; ) {
        let S = this.markers[d++];
        if (S.toDOM) {
          S.destroy(s);
          let A = s.nextSibling;
          s.remove(), s = A;
        }
      }
      if (!y)
        break;
      y.toDOM && (b ? s = s.nextSibling : this.dom.insertBefore(y.toDOM(e), s)), b && d++;
    }
    this.dom.className = l, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function z5(o, e) {
  if (o.length != e.length)
    return !1;
  for (let n = 0; n < o.length; n++)
    if (!o[n].compare(e[n]))
      return !1;
  return !0;
}
const Q5 = /* @__PURE__ */ Be.define(), N5 = /* @__PURE__ */ Be.define(), wm = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let l = Object.assign({}, e);
        for (let s in n) {
          let c = l[s], d = n[s];
          l[s] = c ? (m, y, b) => c(m, y, b) || d(m, y, b) : d;
        }
        return l;
      }
    });
  }
});
class NT extends vu {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function UT(o, e) {
  return o.state.facet(wm).formatNumber(e, o.state);
}
const U5 = /* @__PURE__ */ sO.compute([wm], (o) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Q5);
  },
  lineMarker(e, n, l) {
    return l.some((s) => s.toDOM) ? null : new NT(UT(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: (e, n, l) => {
    for (let s of e.state.facet(N5)) {
      let c = s(e, n, l);
      if (c)
        return c;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(wm) != e.state.facet(wm),
  initialSpacer(e) {
    return new NT(UT(e, tR(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let l = UT(n.view, tR(n.view.state.doc.lines));
    return l == e.number ? e : new NT(l);
  },
  domEventHandlers: o.facet(wm).domEventHandlers
}));
function B5(o = {}) {
  return [
    wm.of(o),
    DD(),
    U5
  ];
}
function tR(o) {
  let e = 9;
  for (; e < o; )
    e = e * 10 + 9;
  return e;
}
const q5 = /* @__PURE__ */ new class extends vu {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), _5 = /* @__PURE__ */ u1.compute(["selection"], (o) => {
  let e = [], n = -1;
  for (let l of o.selection.ranges) {
    let s = o.doc.lineAt(l.head).from;
    s > n && (n = s, e.push(q5.range(s)));
  }
  return Qt.of(e);
});
function H5() {
  return _5;
}
const zD = 1024;
let L5 = 0;
class BT {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
class bt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = L5++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Fl.match(e)), (n) => {
      let l = e(n);
      return l === void 0 ? null : [this, l];
    };
  }
}
bt.closedBy = new bt({ deserialize: (o) => o.split(" ") });
bt.openedBy = new bt({ deserialize: (o) => o.split(" ") });
bt.group = new bt({ deserialize: (o) => o.split(" ") });
bt.isolate = new bt({ deserialize: (o) => {
  if (o && o != "rtl" && o != "ltr" && o != "auto")
    throw new RangeError("Invalid value for isolate: " + o);
  return o || "auto";
} });
bt.contextHash = new bt({ perNode: !0 });
bt.lookAhead = new bt({ perNode: !0 });
bt.mounted = new bt({ perNode: !0 });
class x1 {
  constructor(e, n, l) {
    this.tree = e, this.overlay = n, this.parser = l;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[bt.mounted.id];
  }
}
const V5 = /* @__PURE__ */ Object.create(null);
class Fl {
  /**
  @internal
  */
  constructor(e, n, l, s = 0) {
    this.name = e, this.props = n, this.id = l, this.flags = s;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : V5, l = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), s = new Fl(e.name || "", n, e.id, l);
    if (e.props) {
      for (let c of e.props)
        if (Array.isArray(c) || (c = c(s)), c) {
          if (c[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[c[0].id] = c[1];
        }
    }
    return s;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(bt.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let l in e)
      for (let s of l.split(" "))
        n[s] = e[l];
    return (l) => {
      for (let s = l.prop(bt.group), c = -1; c < (s ? s.length : 0); c++) {
        let d = n[c < 0 ? l.name : s[c]];
        if (d)
          return d;
      }
    };
  }
}
Fl.none = new Fl(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class gA {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let n = [];
    for (let l of this.types) {
      let s = null;
      for (let c of e) {
        let d = c(l);
        d && (s || (s = Object.assign({}, l.props)), s[d[0].id] = d[1]);
      }
      n.push(s ? new Fl(l.name, s, l.id, l.flags) : l);
    }
    return new gA(n);
  }
}
const Gb = /* @__PURE__ */ new WeakMap(), nR = /* @__PURE__ */ new WeakMap();
var ui;
(function(o) {
  o[o.ExcludeBuffers = 1] = "ExcludeBuffers", o[o.IncludeAnonymous = 2] = "IncludeAnonymous", o[o.IgnoreMounts = 4] = "IgnoreMounts", o[o.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ui || (ui = {}));
class Wn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, n, l, s, c) {
    if (this.type = e, this.children = n, this.positions = l, this.length = s, this.props = null, c && c.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [d, m] of c)
        this.props[typeof d == "number" ? d : d.id] = m;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = x1.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let l of this.children) {
      let s = l.toString();
      s && (n && (n += ","), n += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Vx(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, n = 0, l = 0) {
    let s = Gb.get(this) || this.topNode, c = new Vx(s);
    return c.moveTo(e, n), Gb.set(this, c._tree), c;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Wl(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.

  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, n = 0) {
    let l = yO(Gb.get(this) || this.topNode, e, n, !1);
    return Gb.set(this, l), l;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, n = 0) {
    let l = yO(nR.get(this) || this.topNode, e, n, !0);
    return nR.set(this, l), l;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, n = 0) {
    return G5(this, e, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: n, leave: l, from: s = 0, to: c = this.length } = e, d = e.mode || 0, m = (d & ui.IncludeAnonymous) > 0;
    for (let y = this.cursor(d | ui.IncludeAnonymous); ; ) {
      let b = !1;
      if (y.from <= c && y.to >= s && (!m && y.type.isAnonymous || n(y) !== !1)) {
        if (y.firstChild())
          continue;
        b = !0;
      }
      for (; b && l && (m || !y.type.isAnonymous) && l(y), !y.nextSibling(); ) {
        if (!y.parent())
          return;
        b = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : vA(Fl.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, l, s) => new Wn(this.type, n, l, s, this.propValues), e.makeTree || ((n, l, s) => new Wn(Fl.none, n, l, s)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Y5(e);
  }
}
Wn.empty = new Wn(Fl.none, [], [], 0);
class yA {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new yA(this.buffer, this.index);
  }
}
class ef {
  /**
  Create a tree buffer.
  */
  constructor(e, n, l) {
    this.buffer = e, this.length = n, this.set = l;
  }
  /**
  @internal
  */
  get type() {
    return Fl.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let n = this.buffer[e], l = this.buffer[e + 3], s = this.set.types[n], c = s.name;
    if (/\W/.test(c) && !s.isError && (c = JSON.stringify(c)), e += 4, l == e)
      return c;
    let d = [];
    for (; e < l; )
      d.push(this.childString(e)), e = this.buffer[e + 3];
    return c + "(" + d.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, n, l, s, c) {
    let { buffer: d } = this, m = -1;
    for (let y = e; y != n && !(QD(c, s, d[y + 1], d[y + 2]) && (m = y, l > 0)); y = d[y + 3])
      ;
    return m;
  }
  /**
  @internal
  */
  slice(e, n, l) {
    let s = this.buffer, c = new Uint16Array(n - e), d = 0;
    for (let m = e, y = 0; m < n; ) {
      c[y++] = s[m++], c[y++] = s[m++] - l;
      let b = c[y++] = s[m++] - l;
      c[y++] = s[m++] - e, d = Math.max(d, b);
    }
    return new ef(c, d, this.set);
  }
}
function QD(o, e, n, l) {
  switch (o) {
    case -2:
      return n < e;
    case -1:
      return l >= e && n < e;
    case 0:
      return n < e && l > e;
    case 1:
      return n <= e && l > e;
    case 2:
      return l > e;
    case 4:
      return !0;
  }
}
function yO(o, e, n, l) {
  for (var s; o.from == o.to || (n < 1 ? o.from >= e : o.from > e) || (n > -1 ? o.to <= e : o.to < e); ) {
    let d = !l && o instanceof Wl && o.index < 0 ? null : o.parent;
    if (!d)
      return o;
    o = d;
  }
  let c = l ? 0 : ui.IgnoreOverlays;
  if (l)
    for (let d = o, m = d.parent; m; d = m, m = d.parent)
      d instanceof Wl && d.index < 0 && ((s = m.enter(e, n, c)) === null || s === void 0 ? void 0 : s.from) != d.from && (o = m);
  for (; ; ) {
    let d = o.enter(e, n, c);
    if (!d)
      return o;
    o = d;
  }
}
class ND {
  cursor(e = 0) {
    return new Vx(this, e);
  }
  getChild(e, n = null, l = null) {
    let s = iR(this, e, n, l);
    return s.length ? s[0] : null;
  }
  getChildren(e, n = null, l = null) {
    return iR(this, e, n, l);
  }
  resolve(e, n = 0) {
    return yO(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return yO(this, e, n, !0);
  }
  matchContext(e) {
    return Lx(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), l = this;
    for (; n; ) {
      let s = n.lastChild;
      if (!s || s.to != n.to)
        break;
      s.type.isError && s.from == s.to ? (l = n, n = s.prevSibling) : n = s;
    }
    return l;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Wl extends ND {
  constructor(e, n, l, s) {
    super(), this._tree = e, this.from = n, this.index = l, this._parent = s;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, l, s, c = 0) {
    for (let d = this; ; ) {
      for (let { children: m, positions: y } = d._tree, b = n > 0 ? m.length : -1; e != b; e += n) {
        let S = m[e], A = y[e] + d.from;
        if (QD(s, l, A, A + S.length)) {
          if (S instanceof ef) {
            if (c & ui.ExcludeBuffers)
              continue;
            let w = S.findChild(0, S.buffer.length, n, l - A, s);
            if (w > -1)
              return new tr(new X5(d, S, e, A), null, w);
          } else if (c & ui.IncludeAnonymous || !S.type.isAnonymous || OA(S)) {
            let w;
            if (!(c & ui.IgnoreMounts) && (w = x1.get(S)) && !w.overlay)
              return new Wl(w.tree, A, e, d);
            let E = new Wl(S, A, e, d);
            return c & ui.IncludeAnonymous || !E.type.isAnonymous ? E : E.nextChild(n < 0 ? S.children.length - 1 : 0, n, l, s);
          }
        }
      }
      if (c & ui.IncludeAnonymous || !d.type.isAnonymous || (d.index >= 0 ? e = d.index + n : e = n < 0 ? -1 : d._parent._tree.children.length, d = d._parent, !d))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, l = 0) {
    let s;
    if (!(l & ui.IgnoreOverlays) && (s = x1.get(this._tree)) && s.overlay) {
      let c = e - this.from;
      for (let { from: d, to: m } of s.overlay)
        if ((n > 0 ? d <= c : d < c) && (n < 0 ? m >= c : m > c))
          return new Wl(s.tree, s.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, l);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function iR(o, e, n, l) {
  let s = o.cursor(), c = [];
  if (!s.firstChild())
    return c;
  if (n != null) {
    for (let d = !1; !d; )
      if (d = s.type.is(n), !s.nextSibling())
        return c;
  }
  for (; ; ) {
    if (l != null && s.type.is(l))
      return c;
    if (s.type.is(e) && c.push(s.node), !s.nextSibling())
      return l == null ? c : [];
  }
}
function Lx(o, e, n = e.length - 1) {
  for (let l = o; n >= 0; l = l.parent) {
    if (!l)
      return !1;
    if (!l.type.isAnonymous) {
      if (e[n] && e[n] != l.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class X5 {
  constructor(e, n, l, s) {
    this.parent = e, this.buffer = n, this.index = l, this.start = s;
  }
}
class tr extends ND {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, l) {
    super(), this.context = e, this._parent = n, this.index = l, this.type = e.buffer.set.types[e.buffer.buffer[l]];
  }
  child(e, n, l) {
    let { buffer: s } = this.context, c = s.findChild(this.index + 4, s.buffer[this.index + 3], e, n - this.context.start, l);
    return c < 0 ? null : new tr(this.context, this, c);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, n, l = 0) {
    if (l & ui.ExcludeBuffers)
      return null;
    let { buffer: s } = this.context, c = s.findChild(this.index + 4, s.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return c < 0 ? null : new tr(this.context, this, c);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new tr(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new tr(this.context, this._parent, e.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: l } = this.context, s = this.index + 4, c = l.buffer[this.index + 3];
    if (c > s) {
      let d = l.buffer[this.index + 1];
      e.push(l.slice(s, c, d)), n.push(0);
    }
    return new Wn(this.type, e, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function UD(o) {
  if (!o.length)
    return null;
  let e = 0, n = o[0];
  for (let c = 1; c < o.length; c++) {
    let d = o[c];
    (d.from > n.from || d.to < n.to) && (n = d, e = c);
  }
  let l = n instanceof Wl && n.index < 0 ? null : n.parent, s = o.slice();
  return l ? s[e] = l : s.splice(e, 1), new j5(s, n);
}
class j5 {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return UD(this.heads);
  }
}
function G5(o, e, n) {
  let l = o.resolveInner(e, n), s = null;
  for (let c = l instanceof Wl ? l : l.context.parent; c; c = c.parent)
    if (c.index < 0) {
      let d = c.parent;
      (s || (s = [l])).push(d.resolve(e, n)), c = d;
    } else {
      let d = x1.get(c.tree);
      if (d && d.overlay && d.overlay[0].from <= e && d.overlay[d.overlay.length - 1].to >= e) {
        let m = new Wl(d.tree, d.overlay[0].from + c.from, -1, c);
        (s || (s = [l])).push(yO(m, e, n, !1));
      }
    }
  return s ? UD(s) : l;
}
class Vx {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Wl)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let l = e._parent; l; l = l._parent)
        this.stack.unshift(l.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: l, buffer: s } = this.buffer;
    return this.type = n || s.set.types[s.buffer[e]], this.from = l + s.buffer[e + 1], this.to = l + s.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Wl ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, n, l) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, l, this.mode));
    let { buffer: s } = this.buffer, c = s.findChild(this.index + 4, s.buffer[this.index + 3], e, n - this.buffer.start, l);
    return c < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(c));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, n, l = this.mode) {
    return this.buffer ? l & ui.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, l));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ui.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & ui.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, l = this.stack.length - 1;
    if (e < 0) {
      let s = l < 0 ? 0 : this.stack[l] + 4;
      if (this.index != s)
        return this.yieldBuf(n.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let s = n.buffer[this.index + 3];
      if (s < (l < 0 ? n.buffer.length : n.buffer[this.stack[l] + 3]))
        return this.yieldBuf(s);
    }
    return l < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, l, { buffer: s } = this;
    if (s) {
      if (e > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let c = 0; c < this.index; c++)
          if (s.buffer.buffer[c + 3] < this.index)
            return !1;
      ({ index: n, parent: l } = s);
    } else
      ({ index: n, _parent: l } = this._tree);
    for (; l; { index: n, _parent: l } = l)
      if (n > -1)
        for (let c = n + e, d = e < 0 ? -1 : l._tree.children.length; c != d; c += e) {
          let m = l._tree.children[c];
          if (this.mode & ui.IncludeAnonymous || m instanceof ef || !m.type.isAnonymous || OA(m))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, l = 0;
    if (e && e.context == this.buffer)
      e: for (let s = this.index, c = this.stack.length; c >= 0; ) {
        for (let d = e; d; d = d._parent)
          if (d.index == s) {
            if (s == this.index)
              return d;
            n = d, l = c + 1;
            break e;
          }
        s = this.stack[--c];
      }
    for (let s = l; s < this.stack.length; s++)
      n = new tr(this.buffer, n, this.stack[s]);
    return this.bufferNode = new tr(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, n) {
    for (let l = 0; ; ) {
      let s = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          l++;
          continue;
        }
        this.type.isAnonymous || (s = !0);
      }
      for (; ; ) {
        if (s && n && n(this), s = this.type.isAnonymous, !l)
          return;
        if (this.nextSibling())
          break;
        this.parent(), l--, s = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Lx(this.node.parent, e);
    let { buffer: n } = this.buffer, { types: l } = n.set;
    for (let s = e.length - 1, c = this.stack.length - 1; s >= 0; c--) {
      if (c < 0)
        return Lx(this._tree, e, s);
      let d = l[n.buffer[this.stack[c]]];
      if (!d.isAnonymous) {
        if (e[s] && e[s] != d.name)
          return !1;
        s--;
      }
    }
    return !0;
  }
}
function OA(o) {
  return o.children.some((e) => e instanceof ef || !e.type.isAnonymous || OA(e));
}
function Y5(o) {
  var e;
  let { buffer: n, nodeSet: l, maxBufferLength: s = zD, reused: c = [], minRepeatType: d = l.types.length } = o, m = Array.isArray(n) ? new yA(n, n.length) : n, y = l.types, b = 0, S = 0;
  function A(ne, ye, Oe, we, Re, Te) {
    let { id: ze, start: fe, end: Qe, size: Ve } = m, Xe = S, F = b;
    for (; Ve < 0; )
      if (m.next(), Ve == -1) {
        let L = c[ze];
        Oe.push(L), we.push(fe - ne);
        return;
      } else if (Ve == -3) {
        b = ze;
        return;
      } else if (Ve == -4) {
        S = ze;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${Ve}`);
    let Z = y[ze], ge, Se, B = fe - ne;
    if (Qe - fe <= s && (Se = V(m.pos - ye, Re))) {
      let L = new Uint16Array(Se.size - Se.skip), se = m.pos - Se.size, le = L.length;
      for (; m.pos > se; )
        le = G(Se.start, L, le);
      ge = new ef(L, Qe - Se.start, l), B = Se.start - ne;
    } else {
      let L = m.pos - Ve;
      m.next();
      let se = [], le = [], Ae = ze >= d ? ze : -1, je = 0, Ne = Qe;
      for (; m.pos > L; )
        Ae >= 0 && m.id == Ae && m.size >= 0 ? (m.end <= Ne - s && (z(se, le, fe, je, m.end, Ne, Ae, Xe, F), je = se.length, Ne = m.end), m.next()) : Te > 2500 ? w(fe, L, se, le) : A(fe, L, se, le, Ae, Te + 1);
      if (Ae >= 0 && je > 0 && je < se.length && z(se, le, fe, je, fe, Ne, Ae, Xe, F), se.reverse(), le.reverse(), Ae > -1 && je > 0) {
        let Ke = E(Z, F);
        ge = vA(Z, se, le, 0, se.length, 0, Qe - fe, Ke, Ke);
      } else
        ge = U(Z, se, le, Qe - fe, Xe - Qe, F);
    }
    Oe.push(ge), we.push(B);
  }
  function w(ne, ye, Oe, we) {
    let Re = [], Te = 0, ze = -1;
    for (; m.pos > ye; ) {
      let { id: fe, start: Qe, end: Ve, size: Xe } = m;
      if (Xe > 4)
        m.next();
      else {
        if (ze > -1 && Qe < ze)
          break;
        ze < 0 && (ze = Ve - s), Re.push(fe, Qe, Ve), Te++, m.next();
      }
    }
    if (Te) {
      let fe = new Uint16Array(Te * 4), Qe = Re[Re.length - 2];
      for (let Ve = Re.length - 3, Xe = 0; Ve >= 0; Ve -= 3)
        fe[Xe++] = Re[Ve], fe[Xe++] = Re[Ve + 1] - Qe, fe[Xe++] = Re[Ve + 2] - Qe, fe[Xe++] = Xe;
      Oe.push(new ef(fe, Re[2] - Qe, l)), we.push(Qe - ne);
    }
  }
  function E(ne, ye) {
    return (Oe, we, Re) => {
      let Te = 0, ze = Oe.length - 1, fe, Qe;
      if (ze >= 0 && (fe = Oe[ze]) instanceof Wn) {
        if (!ze && fe.type == ne && fe.length == Re)
          return fe;
        (Qe = fe.prop(bt.lookAhead)) && (Te = we[ze] + fe.length + Qe);
      }
      return U(ne, Oe, we, Re, Te, ye);
    };
  }
  function z(ne, ye, Oe, we, Re, Te, ze, fe, Qe) {
    let Ve = [], Xe = [];
    for (; ne.length > we; )
      Ve.push(ne.pop()), Xe.push(ye.pop() + Oe - Re);
    ne.push(U(l.types[ze], Ve, Xe, Te - Re, fe - Te, Qe)), ye.push(Re - Oe);
  }
  function U(ne, ye, Oe, we, Re, Te, ze) {
    if (Te) {
      let fe = [bt.contextHash, Te];
      ze = ze ? [fe].concat(ze) : [fe];
    }
    if (Re > 25) {
      let fe = [bt.lookAhead, Re];
      ze = ze ? [fe].concat(ze) : [fe];
    }
    return new Wn(ne, ye, Oe, we, ze);
  }
  function V(ne, ye) {
    let Oe = m.fork(), we = 0, Re = 0, Te = 0, ze = Oe.end - s, fe = { size: 0, start: 0, skip: 0 };
    e: for (let Qe = Oe.pos - ne; Oe.pos > Qe; ) {
      let Ve = Oe.size;
      if (Oe.id == ye && Ve >= 0) {
        fe.size = we, fe.start = Re, fe.skip = Te, Te += 4, we += 4, Oe.next();
        continue;
      }
      let Xe = Oe.pos - Ve;
      if (Ve < 0 || Xe < Qe || Oe.start < ze)
        break;
      let F = Oe.id >= d ? 4 : 0, Z = Oe.start;
      for (Oe.next(); Oe.pos > Xe; ) {
        if (Oe.size < 0)
          if (Oe.size == -3)
            F += 4;
          else
            break e;
        else Oe.id >= d && (F += 4);
        Oe.next();
      }
      Re = Z, we += Ve, Te += F;
    }
    return (ye < 0 || we == ne) && (fe.size = we, fe.start = Re, fe.skip = Te), fe.size > 4 ? fe : void 0;
  }
  function G(ne, ye, Oe) {
    let { id: we, start: Re, end: Te, size: ze } = m;
    if (m.next(), ze >= 0 && we < d) {
      let fe = Oe;
      if (ze > 4) {
        let Qe = m.pos - (ze - 4);
        for (; m.pos > Qe; )
          Oe = G(ne, ye, Oe);
      }
      ye[--Oe] = fe, ye[--Oe] = Te - ne, ye[--Oe] = Re - ne, ye[--Oe] = we;
    } else ze == -3 ? b = we : ze == -4 && (S = we);
    return Oe;
  }
  let ie = [], me = [];
  for (; m.pos > 0; )
    A(o.start || 0, o.bufferStart || 0, ie, me, -1, 0);
  let pe = (e = o.length) !== null && e !== void 0 ? e : ie.length ? me[0] + ie[0].length : 0;
  return new Wn(y[o.topID], ie.reverse(), me.reverse(), pe);
}
const lR = /* @__PURE__ */ new WeakMap();
function c1(o, e) {
  if (!o.isAnonymous || e instanceof ef || e.type != o)
    return 1;
  let n = lR.get(e);
  if (n == null) {
    n = 1;
    for (let l of e.children) {
      if (l.type != o || !(l instanceof Wn)) {
        n = 1;
        break;
      }
      n += c1(o, l);
    }
    lR.set(e, n);
  }
  return n;
}
function vA(o, e, n, l, s, c, d, m, y) {
  let b = 0;
  for (let z = l; z < s; z++)
    b += c1(o, e[z]);
  let S = Math.ceil(
    b * 1.5 / 8
    /* Balance.BranchFactor */
  ), A = [], w = [];
  function E(z, U, V, G, ie) {
    for (let me = V; me < G; ) {
      let pe = me, ne = U[me], ye = c1(o, z[me]);
      for (me++; me < G; me++) {
        let Oe = c1(o, z[me]);
        if (ye + Oe >= S)
          break;
        ye += Oe;
      }
      if (me == pe + 1) {
        if (ye > S) {
          let Oe = z[pe];
          E(Oe.children, Oe.positions, 0, Oe.children.length, U[pe] + ie);
          continue;
        }
        A.push(z[pe]);
      } else {
        let Oe = U[me - 1] + z[me - 1].length - ne;
        A.push(vA(o, z, U, pe, me, ne, Oe, null, y));
      }
      w.push(ne + ie - c);
    }
  }
  return E(e, n, l, s, 0), (m || y)(A, w, d);
}
class $5 {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, l) {
    let s = this.map.get(e);
    s || this.map.set(e, s = /* @__PURE__ */ new Map()), s.set(n, l);
  }
  getBuffer(e, n) {
    let l = this.map.get(e);
    return l && l.get(n);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, n) {
    e instanceof tr ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof Wl && this.map.set(e.tree, n);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof tr ? this.getBuffer(e.context.buffer, e.index) : e instanceof Wl ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Fh {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, n, l, s, c = !1, d = !1) {
    this.from = e, this.to = n, this.tree = l, this.offset = s, this.open = (c ? 1 : 0) | (d ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, n = [], l = !1) {
    let s = [new Fh(0, e.length, e, 0, !1, l)];
    for (let c of n)
      c.to > e.length && s.push(c);
    return s;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, n, l = 128) {
    if (!n.length)
      return e;
    let s = [], c = 1, d = e.length ? e[0] : null;
    for (let m = 0, y = 0, b = 0; ; m++) {
      let S = m < n.length ? n[m] : null, A = S ? S.fromA : 1e9;
      if (A - y >= l)
        for (; d && d.from < A; ) {
          let w = d;
          if (y >= w.from || A <= w.to || b) {
            let E = Math.max(w.from, y) - b, z = Math.min(w.to, A) - b;
            w = E >= z ? null : new Fh(E, z, w.tree, w.offset + b, m > 0, !!S);
          }
          if (w && s.push(w), d.to > A)
            break;
          d = c < e.length ? e[c++] : null;
        }
      if (!S)
        break;
      y = S.toA, b = S.toA - S.toB;
    }
    return s;
  }
}
class BD {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.

  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, n, l) {
    return typeof e == "string" && (e = new Z5(e)), l = l ? l.length ? l.map((s) => new BT(s.from, s.to)) : [new BT(0, 0)] : [new BT(0, e.length)], this.createParse(e, n || [], l);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, n, l) {
    let s = this.startParse(e, n, l);
    for (; ; ) {
      let c = s.advance();
      if (c)
        return c;
    }
  }
}
class Z5 {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
new bt({ perNode: !0 });
let P5 = 0;
class oo {
  /**
  @internal
  */
  constructor(e, n, l, s) {
    this.name = e, this.set = n, this.base = l, this.modified = s, this.id = P5++;
  }
  toString() {
    let { name: e } = this;
    for (let n of this.modified)
      n.name && (e = `${n.name}(${e})`);
    return e;
  }
  static define(e, n) {
    let l = typeof e == "string" ? e : "?";
    if (e instanceof oo && (n = e), n != null && n.base)
      throw new Error("Can not derive from a modified tag");
    let s = new oo(l, [], null, []);
    if (s.set.push(s), n)
      for (let c of n.set)
        s.set.push(c);
    return s;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).

  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let n = new A1(e);
    return (l) => l.modified.indexOf(n) > -1 ? l : A1.get(l.base || l, l.modified.concat(n).sort((s, c) => s.id - c.id));
  }
}
let W5 = 0;
class A1 {
  constructor(e) {
    this.name = e, this.instances = [], this.id = W5++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let l = n[0].instances.find((m) => m.base == e && F5(n, m.modified));
    if (l)
      return l;
    let s = [], c = new oo(e.name, s, e, n);
    for (let m of n)
      m.instances.push(c);
    let d = K5(n);
    for (let m of e.set)
      if (!m.modified.length)
        for (let y of d)
          s.push(A1.get(m, y));
    return c;
  }
}
function F5(o, e) {
  return o.length == e.length && o.every((n, l) => n == e[l]);
}
function K5(o) {
  let e = [[]];
  for (let n = 0; n < o.length; n++)
    for (let l = 0, s = e.length; l < s; l++)
      e.push(e[l].concat(o[n]));
  return e.sort((n, l) => l.length - n.length);
}
function qD(o) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in o) {
    let l = o[n];
    Array.isArray(l) || (l = [l]);
    for (let s of n.split(" "))
      if (s) {
        let c = [], d = 2, m = s;
        for (let A = 0; ; ) {
          if (m == "..." && A > 0 && A + 3 == s.length) {
            d = 1;
            break;
          }
          let w = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(m);
          if (!w)
            throw new RangeError("Invalid path: " + s);
          if (c.push(w[0] == "*" ? "" : w[0][0] == '"' ? JSON.parse(w[0]) : w[0]), A += w[0].length, A == s.length)
            break;
          let E = s[A++];
          if (A == s.length && E == "!") {
            d = 0;
            break;
          }
          if (E != "/")
            throw new RangeError("Invalid path: " + s);
          m = s.slice(A);
        }
        let y = c.length - 1, b = c[y];
        if (!b)
          throw new RangeError("Invalid path: " + s);
        let S = new w1(l, d, y > 0 ? c.slice(0, y) : null);
        e[b] = S.sort(e[b]);
      }
  }
  return _D.add(e);
}
const _D = new bt();
class w1 {
  constructor(e, n, l, s) {
    this.tags = e, this.mode = n, this.context = l, this.next = s;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
w1.empty = new w1([], 2, null);
function HD(o, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let c of o)
    if (!Array.isArray(c.tag))
      n[c.tag.id] = c.class;
    else
      for (let d of c.tag)
        n[d.id] = c.class;
  let { scope: l, all: s = null } = e || {};
  return {
    style: (c) => {
      let d = s;
      for (let m of c)
        for (let y of m.set) {
          let b = n[y.id];
          if (b) {
            d = d ? d + " " + b : b;
            break;
          }
        }
      return d;
    },
    scope: l
  };
}
function J5(o, e) {
  let n = null;
  for (let l of o) {
    let s = l.style(e);
    s && (n = n ? n + " " + s : s);
  }
  return n;
}
function I5(o, e, n, l = 0, s = o.length) {
  let c = new e6(l, Array.isArray(e) ? e : [e], n);
  c.highlightRange(o.cursor(), l, s, "", c.highlighters), c.flush(s);
}
class e6 {
  constructor(e, n, l) {
    this.at = e, this.highlighters = n, this.span = l, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, l, s, c) {
    let { type: d, from: m, to: y } = e;
    if (m >= l || y <= n)
      return;
    d.isTop && (c = this.highlighters.filter((E) => !E.scope || E.scope(d)));
    let b = s, S = t6(e) || w1.empty, A = J5(c, S.tags);
    if (A && (b && (b += " "), b += A, S.mode == 1 && (s += (s ? " " : "") + A)), this.startSpan(Math.max(n, m), b), S.opaque)
      return;
    let w = e.tree && e.tree.prop(bt.mounted);
    if (w && w.overlay) {
      let E = e.node.enter(w.overlay[0].from + m, 1), z = this.highlighters.filter((V) => !V.scope || V.scope(w.tree.type)), U = e.firstChild();
      for (let V = 0, G = m; ; V++) {
        let ie = V < w.overlay.length ? w.overlay[V] : null, me = ie ? ie.from + m : y, pe = Math.max(n, G), ne = Math.min(l, me);
        if (pe < ne && U)
          for (; e.from < ne && (this.highlightRange(e, pe, ne, s, c), this.startSpan(Math.min(ne, e.to), b), !(e.to >= me || !e.nextSibling())); )
            ;
        if (!ie || me > l)
          break;
        G = ie.to + m, G > n && (this.highlightRange(E.cursor(), Math.max(n, ie.from + m), Math.min(l, G), "", z), this.startSpan(Math.min(l, G), b));
      }
      U && e.parent();
    } else if (e.firstChild()) {
      w && (s = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= l)
            break;
          this.highlightRange(e, n, l, s, c), this.startSpan(Math.min(l, e.to), b);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function t6(o) {
  let e = o.type.prop(_D);
  for (; e && e.context && !o.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const De = oo.define, Yb = De(), Gc = De(), aR = De(Gc), oR = De(Gc), Yc = De(), $b = De(Yc), qT = De(Yc), Fs = De(), Yh = De(Fs), Ps = De(), Ws = De(), Xx = De(), Py = De(Xx), Zb = De(), C = {
  /**
  A comment.
  */
  comment: Yb,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: De(Yb),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: De(Yb),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: De(Yb),
  /**
  Any kind of identifier.
  */
  name: Gc,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: De(Gc),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: aR,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: De(aR),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: oR,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: De(oR),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: De(Gc),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: De(Gc),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: De(Gc),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: De(Gc),
  /**
  A literal value.
  */
  literal: Yc,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: $b,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: De($b),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: De($b),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: De($b),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: qT,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: De(qT),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: De(qT),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: De(Yc),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: De(Yc),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: De(Yc),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: De(Yc),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: De(Yc),
  /**
  A language keyword.
  */
  keyword: Ps,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: De(Ps),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: De(Ps),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: De(Ps),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: De(Ps),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: De(Ps),
  /**
  An operator.
  */
  operator: Ws,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: De(Ws),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: De(Ws),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: De(Ws),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: De(Ws),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: De(Ws),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: De(Ws),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: De(Ws),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: De(Ws),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: De(Ws),
  /**
  Program or markup punctuation.
  */
  punctuation: Xx,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: De(Xx),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Py,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: De(Py),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: De(Py),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: De(Py),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: De(Py),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Fs,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Yh,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: De(Yh),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: De(Yh),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: De(Yh),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: De(Yh),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: De(Yh),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: De(Yh),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: De(Fs),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: De(Fs),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: De(Fs),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: De(Fs),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: De(Fs),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: De(Fs),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: De(Fs),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: De(Fs),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: De(),
  /**
  Deleted text.
  */
  deleted: De(),
  /**
  Changed text.
  */
  changed: De(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: De(),
  /**
  Metadata or meta-instruction.
  */
  meta: Zb,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: De(Zb),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: De(Zb),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: De(Zb),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: oo.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: oo.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: oo.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: oo.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: oo.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: oo.defineModifier("special")
};
for (let o in C) {
  let e = C[o];
  e instanceof oo && (e.name = o);
}
HD([
  { tag: C.link, class: "tok-link" },
  { tag: C.heading, class: "tok-heading" },
  { tag: C.emphasis, class: "tok-emphasis" },
  { tag: C.strong, class: "tok-strong" },
  { tag: C.keyword, class: "tok-keyword" },
  { tag: C.atom, class: "tok-atom" },
  { tag: C.bool, class: "tok-bool" },
  { tag: C.url, class: "tok-url" },
  { tag: C.labelName, class: "tok-labelName" },
  { tag: C.inserted, class: "tok-inserted" },
  { tag: C.deleted, class: "tok-deleted" },
  { tag: C.literal, class: "tok-literal" },
  { tag: C.string, class: "tok-string" },
  { tag: C.number, class: "tok-number" },
  { tag: [C.regexp, C.escape, C.special(C.string)], class: "tok-string2" },
  { tag: C.variableName, class: "tok-variableName" },
  { tag: C.local(C.variableName), class: "tok-variableName tok-local" },
  { tag: C.definition(C.variableName), class: "tok-variableName tok-definition" },
  { tag: C.special(C.variableName), class: "tok-variableName2" },
  { tag: C.definition(C.propertyName), class: "tok-propertyName tok-definition" },
  { tag: C.typeName, class: "tok-typeName" },
  { tag: C.namespace, class: "tok-namespace" },
  { tag: C.className, class: "tok-className" },
  { tag: C.macroName, class: "tok-macroName" },
  { tag: C.propertyName, class: "tok-propertyName" },
  { tag: C.operator, class: "tok-operator" },
  { tag: C.comment, class: "tok-comment" },
  { tag: C.meta, class: "tok-meta" },
  { tag: C.invalid, class: "tok-invalid" },
  { tag: C.punctuation, class: "tok-punctuation" }
]);
var _T;
const Em = /* @__PURE__ */ new bt();
function n6(o) {
  return Be.define({
    combine: o ? (e) => e.concat(o) : void 0
  });
}
const i6 = /* @__PURE__ */ new bt();
class ts {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, n, l = [], s = "") {
    this.data = e, this.name = s, At.prototype.hasOwnProperty("tree") || Object.defineProperty(At.prototype, "tree", { get() {
      return bi(this);
    } }), this.parser = n, this.extension = [
      tf.of(this),
      At.languageData.of((c, d, m) => {
        let y = sR(c, d, m), b = y.type.prop(Em);
        if (!b)
          return [];
        let S = c.facet(b), A = y.type.prop(i6);
        if (A) {
          let w = y.resolve(d - y.from, m);
          for (let E of A)
            if (E.test(w, c)) {
              let z = c.facet(E.facet);
              return E.type == "replace" ? z : z.concat(S);
            }
        }
        return S;
      })
    ].concat(l);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, n, l = -1) {
    return sR(e, n, l).type.prop(Em) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let n = e.facet(tf);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let l = [], s = (c, d) => {
      if (c.prop(Em) == this.data) {
        l.push({ from: d, to: d + c.length });
        return;
      }
      let m = c.prop(bt.mounted);
      if (m) {
        if (m.tree.prop(Em) == this.data) {
          if (m.overlay)
            for (let y of m.overlay)
              l.push({ from: y.from + d, to: y.to + d });
          else
            l.push({ from: d, to: d + c.length });
          return;
        } else if (m.overlay) {
          let y = l.length;
          if (s(m.tree, m.overlay[0].from + d), l.length > y)
            return;
        }
      }
      for (let y = 0; y < c.children.length; y++) {
        let b = c.children[y];
        b instanceof Wn && s(b, c.positions[y] + d);
      }
    };
    return s(bi(e), 0), l;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ts.setState = /* @__PURE__ */ it.define();
function sR(o, e, n) {
  let l = o.facet(tf), s = bi(o).topNode;
  if (!l || l.allowsNesting)
    for (let c = s; c; c = c.enter(e, n, ui.ExcludeBuffers))
      c.type.isTop && (s = c);
  return s;
}
class E1 extends ts {
  constructor(e, n, l) {
    super(e, n, [], l), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let n = n6(e.languageData);
    return new E1(n, e.parser.configure({
      props: [Em.add((l) => l.isTop ? n : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, n) {
    return new E1(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function bi(o) {
  let e = o.field(ts.state, !1);
  return e ? e.tree : Wn.empty;
}
class l6 {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let l = this.cursorPos - this.string.length;
    return e < l || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - l, n - l);
  }
}
let Wy = null;
class C1 {
  constructor(e, n, l = [], s, c, d, m, y) {
    this.parser = e, this.state = n, this.fragments = l, this.tree = s, this.treeLen = c, this.viewport = d, this.skipped = m, this.scheduleOn = y, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, n, l) {
    return new C1(e, n, [], Wn.empty, 0, l, [], null);
  }
  startParse() {
    return this.parser.startParse(new l6(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != Wn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var l;
      if (typeof e == "number") {
        let s = Date.now() + e;
        e = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(Fh.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (l = this.parse.stoppedAt) !== null && l !== void 0 ? l : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(Fh.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = Wy;
    Wy = this;
    try {
      return e();
    } finally {
      Wy = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = rR(e, n.from, n.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, n) {
    let { fragments: l, tree: s, treeLen: c, viewport: d, skipped: m } = this;
    if (this.takeTree(), !e.empty) {
      let y = [];
      if (e.iterChangedRanges((b, S, A, w) => y.push({ fromA: b, toA: S, fromB: A, toB: w })), l = Fh.applyChanges(l, y), s = Wn.empty, c = 0, d = { from: e.mapPos(d.from, -1), to: e.mapPos(d.to, 1) }, this.skipped.length) {
        m = [];
        for (let b of this.skipped) {
          let S = e.mapPos(b.from, 1), A = e.mapPos(b.to, -1);
          S < A && m.push({ from: S, to: A });
        }
      }
    }
    return new C1(this.parser, n, l, s, c, d, m, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let l = 0; l < this.skipped.length; l++) {
      let { from: s, to: c } = this.skipped[l];
      s < e.to && c > e.from && (this.fragments = rR(this.fragments, s, c), this.skipped.splice(l--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.

  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends BD {
      createParse(n, l, s) {
        let c = s[0].from, d = s[s.length - 1].to;
        return {
          parsedPos: c,
          advance() {
            let y = Wy;
            if (y) {
              for (let b of s)
                y.tempSkipped.push(b);
              e && (y.scheduleOn = y.scheduleOn ? Promise.all([y.scheduleOn, e]) : e);
            }
            return this.parsedPos = d, new Wn(Fl.none, [], [], d - c);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Wy;
  }
}
function rR(o, e, n) {
  return Fh.applyChanges(o, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class Hm {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), l = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, l) || n.takeTree(), new Hm(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), l = C1.create(e.facet(tf).parser, e, { from: 0, to: n });
    return l.work(20, n) || l.takeTree(), new Hm(l);
  }
}
ts.state = /* @__PURE__ */ Si.define({
  create: Hm.init,
  update(o, e) {
    for (let n of e.effects)
      if (n.is(ts.setState))
        return n.value;
    return e.startState.facet(tf) != e.state.facet(tf) ? Hm.init(e.state) : o.apply(e);
  }
});
let LD = (o) => {
  let e = setTimeout(
    () => o(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (LD = (o) => {
  let e = -1, n = setTimeout(
    () => {
      e = requestIdleCallback(o, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const HT = typeof navigator < "u" && (!((_T = navigator.scheduling) === null || _T === void 0) && _T.isInputPending) ? () => navigator.scheduling.isInputPending() : null, a6 = /* @__PURE__ */ Bn.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(ts.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(ts.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = LD(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: l, viewport: { to: s } } = this.view, c = l.field(ts.state);
    if (c.tree == c.context.tree && c.context.isDone(
      s + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let d = Date.now() + Math.min(this.chunkBudget, 100, e && !HT ? Math.max(25, e.timeRemaining() - 5) : 1e9), m = c.context.treeLen < s && l.doc.length > s + 1e3, y = c.context.work(() => HT && HT() || Date.now() > d, s + (m ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (y || this.chunkBudget <= 0) && (c.context.takeTree(), this.view.dispatch({ effects: ts.setState.of(new Hm(c.context)) })), this.chunkBudget > 0 && !(y && !m) && this.scheduleWork(), this.checkAsyncSchedule(c.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Zl(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), tf = /* @__PURE__ */ Be.define({
  combine(o) {
    return o.length ? o[0] : null;
  },
  enables: (o) => [
    ts.state,
    a6,
    Me.contentAttributes.compute([o], (e) => {
      let n = e.facet(o);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class o6 {
  /**
  Create a language support object.
  */
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
const s6 = /* @__PURE__ */ Be.define(), MO = /* @__PURE__ */ Be.define({
  combine: (o) => {
    if (!o.length)
      return "  ";
    let e = o[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(o[0]));
    return e;
  }
});
function R1(o) {
  let e = o.facet(MO);
  return e.charCodeAt(0) == 9 ? o.tabSize * e.length : e.length;
}
function OO(o, e) {
  let n = "", l = o.tabSize, s = o.facet(MO)[0];
  if (s == "	") {
    for (; e >= l; )
      n += "	", e -= l;
    s = " ";
  }
  for (let c = 0; c < e; c++)
    n += s;
  return n;
}
function bA(o, e) {
  o instanceof At && (o = new $1(o));
  for (let l of o.state.facet(s6)) {
    let s = l(o, e);
    if (s !== void 0)
      return s;
  }
  let n = bi(o.state);
  return n.length >= e ? r6(o, n, e) : null;
}
class $1 {
  /**
  Create an indent context.
  */
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = R1(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, n = 1) {
    let l = this.state.doc.lineAt(e), { simulateBreak: s, simulateDoubleBreak: c } = this.options;
    return s != null && s >= l.from && s <= l.to ? c && s == e ? { text: "", from: e } : (n < 0 ? s < e : s <= e) ? { text: l.text.slice(s - l.from), from: s } : { text: l.text.slice(0, s - l.from), from: l.from } : l;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: l, from: s } = this.lineAt(e, n);
    return l.slice(e - s, Math.min(l.length, e + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(e, n = 1) {
    let { text: l, from: s } = this.lineAt(e, n), c = this.countColumn(l, e - s), d = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return d > -1 && (c += d - this.countColumn(l, l.search(/\S|$/))), c;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, n = e.length) {
    return jm(e, this.state.tabSize, n);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, n = 1) {
    let { text: l, from: s } = this.lineAt(e, n), c = this.options.overrideIndentation;
    if (c) {
      let d = c(s);
      if (d > -1)
        return d;
    }
    return this.countColumn(l, l.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const VD = /* @__PURE__ */ new bt();
function r6(o, e, n) {
  let l = e.resolveStack(n), s = e.resolveInner(n, -1).resolve(n, 0).enterUnfinishedNodesBefore(n);
  if (s != l.node) {
    let c = [];
    for (let d = s; d && !(d.from == l.node.from && d.type == l.node.type); d = d.parent)
      c.push(d);
    for (let d = c.length - 1; d >= 0; d--)
      l = { node: c[d], next: l };
  }
  return XD(l, o, n);
}
function XD(o, e, n) {
  for (let l = o; l; l = l.next) {
    let s = c6(l.node);
    if (s)
      return s(SA.create(e, n, l));
  }
  return 0;
}
function u6(o) {
  return o.pos == o.options.simulateBreak && o.options.simulateDoubleBreak;
}
function c6(o) {
  let e = o.type.prop(VD);
  if (e)
    return e;
  let n = o.firstChild, l;
  if (n && (l = n.type.prop(bt.closedBy))) {
    let s = o.lastChild, c = s && l.indexOf(s.name) > -1;
    return (d) => jD(d, !0, 1, void 0, c && !u6(d) ? s.from : void 0);
  }
  return o.parent == null ? f6 : null;
}
function f6() {
  return 0;
}
class SA extends $1 {
  constructor(e, n, l) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = l;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, n, l) {
    return new SA(e, n, l);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let l = e.resolve(n.from);
      for (; l.parent && l.parent.from == l.from; )
        l = l.parent;
      if (h6(l, e))
        break;
      n = this.state.doc.lineAt(l.from);
    }
    return this.lineIndent(n.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return XD(this.context.next, this.base, this.pos);
  }
}
function h6(o, e) {
  for (let n = e; n; n = n.parent)
    if (o == n)
      return !0;
  return !1;
}
function d6(o) {
  let e = o.node, n = e.childAfter(e.from), l = e.lastChild;
  if (!n)
    return null;
  let s = o.options.simulateBreak, c = o.state.doc.lineAt(n.from), d = s == null || s <= c.from ? c.to : Math.min(c.to, s);
  for (let m = n.to; ; ) {
    let y = e.childAfter(m);
    if (!y || y == l)
      return null;
    if (!y.type.isSkipped) {
      if (y.from >= d)
        return null;
      let b = /^ */.exec(c.text.slice(n.to - c.from))[0].length;
      return { from: n.from, to: n.to + b };
    }
    m = y.to;
  }
}
function LT({ closing: o, align: e = !0, units: n = 1 }) {
  return (l) => jD(l, e, n, o);
}
function jD(o, e, n, l, s) {
  let c = o.textAfter, d = c.match(/^\s*/)[0].length, m = l && c.slice(d, d + l.length) == l || s == o.pos + d, y = e ? d6(o) : null;
  return y ? m ? o.column(y.from) : o.column(y.to) : o.baseIndent + (m ? 0 : o.unit * n);
}
const p6 = 200;
function m6() {
  return At.transactionFilter.of((o) => {
    if (!o.docChanged || !o.isUserEvent("input.type") && !o.isUserEvent("input.complete"))
      return o;
    let e = o.startState.languageDataAt("indentOnInput", o.startState.selection.main.head);
    if (!e.length)
      return o;
    let n = o.newDoc, { head: l } = o.newSelection.main, s = n.lineAt(l);
    if (l > s.from + p6)
      return o;
    let c = n.sliceString(s.from, l);
    if (!e.some((b) => b.test(c)))
      return o;
    let { state: d } = o, m = -1, y = [];
    for (let { head: b } of d.selection.ranges) {
      let S = d.doc.lineAt(b);
      if (S.from == m)
        continue;
      m = S.from;
      let A = bA(d, S.from);
      if (A == null)
        continue;
      let w = /^\s*/.exec(S.text)[0], E = OO(d, A);
      w != E && y.push({ from: S.from, to: S.from + w.length, insert: E });
    }
    return y.length ? [o, { changes: y, sequential: !0 }] : o;
  });
}
const g6 = /* @__PURE__ */ Be.define(), GD = /* @__PURE__ */ new bt();
function y6(o) {
  let e = o.firstChild, n = o.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? o.to : n.from } : null;
}
function O6(o, e, n) {
  let l = bi(o);
  if (l.length < n)
    return null;
  let s = l.resolveStack(n, 1), c = null;
  for (let d = s; d; d = d.next) {
    let m = d.node;
    if (m.to <= n || m.from > n)
      continue;
    if (c && m.from < e)
      break;
    let y = m.type.prop(GD);
    if (y && (m.to < l.length - 50 || l.length == o.doc.length || !v6(m))) {
      let b = y(m, o);
      b && b.from <= n && b.from >= e && b.to > n && (c = b);
    }
  }
  return c;
}
function v6(o) {
  let e = o.lastChild;
  return e && e.to == o.to && e.type.isError;
}
function k1(o, e, n) {
  for (let l of o.facet(g6)) {
    let s = l(o, e, n);
    if (s)
      return s;
  }
  return O6(o, e, n);
}
function YD(o, e) {
  let n = e.mapPos(o.from, 1), l = e.mapPos(o.to, -1);
  return n >= l ? void 0 : { from: n, to: l };
}
const Z1 = /* @__PURE__ */ it.define({ map: YD }), zO = /* @__PURE__ */ it.define({ map: YD });
function $D(o) {
  let e = [];
  for (let { head: n } of o.state.selection.ranges)
    e.some((l) => l.from <= n && l.to >= n) || e.push(o.lineBlockAt(n));
  return e;
}
const nd = /* @__PURE__ */ Si.define({
  create() {
    return Ze.none;
  },
  update(o, e) {
    o = o.map(e.changes);
    for (let n of e.effects)
      if (n.is(Z1) && !b6(o, n.value.from, n.value.to)) {
        let { preparePlaceholder: l } = e.state.facet(WD), s = l ? Ze.replace({ widget: new C6(l(e.state, n.value)) }) : uR;
        o = o.update({ add: [s.range(n.value.from, n.value.to)] });
      } else n.is(zO) && (o = o.update({
        filter: (l, s) => n.value.from != l || n.value.to != s,
        filterFrom: n.value.from,
        filterTo: n.value.to
      }));
    if (e.selection) {
      let n = !1, { head: l } = e.selection.main;
      o.between(l, l, (s, c) => {
        s < l && c > l && (n = !0);
      }), n && (o = o.update({
        filterFrom: l,
        filterTo: l,
        filter: (s, c) => c <= l || s >= l
      }));
    }
    return o;
  },
  provide: (o) => Me.decorations.from(o),
  toJSON(o, e) {
    let n = [];
    return o.between(0, e.doc.length, (l, s) => {
      n.push(l, s);
    }), n;
  },
  fromJSON(o) {
    if (!Array.isArray(o) || o.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < o.length; ) {
      let l = o[n++], s = o[n++];
      if (typeof l != "number" || typeof s != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(uR.range(l, s));
    }
    return Ze.set(e, !0);
  }
});
function D1(o, e, n) {
  var l;
  let s = null;
  return (l = o.field(nd, !1)) === null || l === void 0 || l.between(e, n, (c, d) => {
    (!s || s.from > c) && (s = { from: c, to: d });
  }), s;
}
function b6(o, e, n) {
  let l = !1;
  return o.between(e, e, (s, c) => {
    s == e && c == n && (l = !0);
  }), l;
}
function ZD(o, e) {
  return o.field(nd, !1) ? e : e.concat(it.appendConfig.of(FD()));
}
const S6 = (o) => {
  for (let e of $D(o)) {
    let n = k1(o.state, e.from, e.to);
    if (n)
      return o.dispatch({ effects: ZD(o.state, [Z1.of(n), PD(o, n)]) }), !0;
  }
  return !1;
}, T6 = (o) => {
  if (!o.state.field(nd, !1))
    return !1;
  let e = [];
  for (let n of $D(o)) {
    let l = D1(o.state, n.from, n.to);
    l && e.push(zO.of(l), PD(o, l, !1));
  }
  return e.length && o.dispatch({ effects: e }), e.length > 0;
};
function PD(o, e, n = !0) {
  let l = o.state.doc.lineAt(e.from).number, s = o.state.doc.lineAt(e.to).number;
  return Me.announce.of(`${o.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${l} ${o.state.phrase("to")} ${s}.`);
}
const x6 = (o) => {
  let { state: e } = o, n = [];
  for (let l = 0; l < e.doc.length; ) {
    let s = o.lineBlockAt(l), c = k1(e, s.from, s.to);
    c && n.push(Z1.of(c)), l = (c ? o.lineBlockAt(c.to) : s).to + 1;
  }
  return n.length && o.dispatch({ effects: ZD(o.state, n) }), !!n.length;
}, A6 = (o) => {
  let e = o.state.field(nd, !1);
  if (!e || !e.size)
    return !1;
  let n = [];
  return e.between(0, o.state.doc.length, (l, s) => {
    n.push(zO.of({ from: l, to: s }));
  }), o.dispatch({ effects: n }), !0;
}, w6 = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: S6 },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: T6 },
  { key: "Ctrl-Alt-[", run: x6 },
  { key: "Ctrl-Alt-]", run: A6 }
], E6 = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, WD = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, E6);
  }
});
function FD(o) {
  return [nd, D6];
}
function KD(o, e) {
  let { state: n } = o, l = n.facet(WD), s = (d) => {
    let m = o.lineBlockAt(o.posAtDOM(d.target)), y = D1(o.state, m.from, m.to);
    y && o.dispatch({ effects: zO.of(y) }), d.preventDefault();
  };
  if (l.placeholderDOM)
    return l.placeholderDOM(o, s, e);
  let c = document.createElement("span");
  return c.textContent = l.placeholderText, c.setAttribute("aria-label", n.phrase("folded code")), c.title = n.phrase("unfold"), c.className = "cm-foldPlaceholder", c.onclick = s, c;
}
const uR = /* @__PURE__ */ Ze.replace({ widget: /* @__PURE__ */ new class extends rr {
  toDOM(o) {
    return KD(o, null);
  }
}() });
class C6 extends rr {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return KD(e, this.value);
  }
}
const R6 = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class VT extends vu {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function k6(o = {}) {
  let e = Object.assign(Object.assign({}, R6), o), n = new VT(e, !0), l = new VT(e, !1), s = Bn.fromClass(class {
    constructor(d) {
      this.from = d.viewport.from, this.markers = this.buildMarkers(d);
    }
    update(d) {
      (d.docChanged || d.viewportChanged || d.startState.facet(tf) != d.state.facet(tf) || d.startState.field(nd, !1) != d.state.field(nd, !1) || bi(d.startState) != bi(d.state) || e.foldingChanged(d)) && (this.markers = this.buildMarkers(d.view));
    }
    buildMarkers(d) {
      let m = new yu();
      for (let y of d.viewportLineBlocks) {
        let b = D1(d.state, y.from, y.to) ? l : k1(d.state, y.from, y.to) ? n : null;
        b && m.add(y.from, y.from, b);
      }
      return m.finish();
    }
  }), { domEventHandlers: c } = e;
  return [
    s,
    k5({
      class: "cm-foldGutter",
      markers(d) {
        var m;
        return ((m = d.plugin(s)) === null || m === void 0 ? void 0 : m.markers) || Qt.empty;
      },
      initialSpacer() {
        return new VT(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, c), { click: (d, m, y) => {
        if (c.click && c.click(d, m, y))
          return !0;
        let b = D1(d.state, m.from, m.to);
        if (b)
          return d.dispatch({ effects: zO.of(b) }), !0;
        let S = k1(d.state, m.from, m.to);
        return S ? (d.dispatch({ effects: Z1.of(S) }), !0) : !1;
      } })
    }),
    FD()
  ];
}
const D6 = /* @__PURE__ */ Me.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Gm {
  constructor(e, n) {
    this.specs = e;
    let l;
    function s(m) {
      let y = Kc.newName();
      return (l || (l = /* @__PURE__ */ Object.create(null)))["." + y] = m, y;
    }
    const c = typeof n.all == "string" ? n.all : n.all ? s(n.all) : void 0, d = n.scope;
    this.scope = d instanceof ts ? (m) => m.prop(Em) == d.data : d ? (m) => m == d : void 0, this.style = HD(e.map((m) => ({
      tag: m.tag,
      class: m.class || s(Object.assign({}, m, { tag: null }))
    })), {
      all: c
    }).style, this.module = l ? new Kc(l) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).

  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, n) {
    return new Gm(e, n || {});
  }
}
const jx = /* @__PURE__ */ Be.define(), JD = /* @__PURE__ */ Be.define({
  combine(o) {
    return o.length ? [o[0]] : null;
  }
});
function XT(o) {
  let e = o.facet(jx);
  return e.length ? e : o.facet(JD);
}
function TA(o, e) {
  let n = [z6], l;
  return o instanceof Gm && (o.module && n.push(Me.styleModule.of(o.module)), l = o.themeType), e != null && e.fallback ? n.push(JD.of(o)) : l ? n.push(jx.computeN([Me.darkTheme], (s) => s.facet(Me.darkTheme) == (l == "dark") ? [o] : [])) : n.push(jx.of(o)), n;
}
class M6 {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = bi(e.state), this.decorations = this.buildDeco(e, XT(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let n = bi(e.state), l = XT(e.state), s = l != XT(e.startState), { viewport: c } = e.view, d = e.changes.mapPos(this.decoratedTo, 1);
    n.length < c.to && !s && n.type == this.tree.type && d >= c.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = d) : (n != this.tree || e.viewportChanged || s) && (this.tree = n, this.decorations = this.buildDeco(e.view, l), this.decoratedTo = c.to);
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return Ze.none;
    let l = new yu();
    for (let { from: s, to: c } of e.visibleRanges)
      I5(this.tree, n, (d, m, y) => {
        l.add(d, m, this.markCache[y] || (this.markCache[y] = Ze.mark({ class: y })));
      }, s, c);
    return l.finish();
  }
}
const z6 = /* @__PURE__ */ nf.high(/* @__PURE__ */ Bn.fromClass(M6, {
  decorations: (o) => o.decorations
})), Q6 = /* @__PURE__ */ Gm.define([
  {
    tag: C.meta,
    color: "#404740"
  },
  {
    tag: C.link,
    textDecoration: "underline"
  },
  {
    tag: C.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: C.emphasis,
    fontStyle: "italic"
  },
  {
    tag: C.strong,
    fontWeight: "bold"
  },
  {
    tag: C.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: C.keyword,
    color: "#708"
  },
  {
    tag: [C.atom, C.bool, C.url, C.contentSeparator, C.labelName],
    color: "#219"
  },
  {
    tag: [C.literal, C.inserted],
    color: "#164"
  },
  {
    tag: [C.string, C.deleted],
    color: "#a11"
  },
  {
    tag: [C.regexp, C.escape, /* @__PURE__ */ C.special(C.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ C.local(C.variableName),
    color: "#30a"
  },
  {
    tag: [C.typeName, C.namespace],
    color: "#085"
  },
  {
    tag: C.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ C.special(C.variableName), C.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ C.definition(C.propertyName),
    color: "#00c"
  },
  {
    tag: C.comment,
    color: "#940"
  },
  {
    tag: C.invalid,
    color: "#f00"
  }
]), N6 = /* @__PURE__ */ Me.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), ID = 1e4, eM = "()[]{}", tM = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, {
      afterCursor: !0,
      brackets: eM,
      maxScanDistance: ID,
      renderMatch: q6
    });
  }
}), U6 = /* @__PURE__ */ Ze.mark({ class: "cm-matchingBracket" }), B6 = /* @__PURE__ */ Ze.mark({ class: "cm-nonmatchingBracket" });
function q6(o) {
  let e = [], n = o.matched ? U6 : B6;
  return e.push(n.range(o.start.from, o.start.to)), o.end && e.push(n.range(o.end.from, o.end.to)), e;
}
const _6 = /* @__PURE__ */ Si.define({
  create() {
    return Ze.none;
  },
  update(o, e) {
    if (!e.docChanged && !e.selection)
      return o;
    let n = [], l = e.state.facet(tM);
    for (let s of e.state.selection.ranges) {
      if (!s.empty)
        continue;
      let c = nr(e.state, s.head, -1, l) || s.head > 0 && nr(e.state, s.head - 1, 1, l) || l.afterCursor && (nr(e.state, s.head, 1, l) || s.head < e.state.doc.length && nr(e.state, s.head + 1, -1, l));
      c && (n = n.concat(l.renderMatch(c, e.state)));
    }
    return Ze.set(n, !0);
  },
  provide: (o) => Me.decorations.from(o)
}), H6 = [
  _6,
  N6
];
function L6(o = {}) {
  return [tM.of(o), H6];
}
const V6 = /* @__PURE__ */ new bt();
function Gx(o, e, n) {
  let l = o.prop(e < 0 ? bt.openedBy : bt.closedBy);
  if (l)
    return l;
  if (o.name.length == 1) {
    let s = n.indexOf(o.name);
    if (s > -1 && s % 2 == (e < 0 ? 1 : 0))
      return [n[s + e]];
  }
  return null;
}
function Yx(o) {
  let e = o.type.prop(V6);
  return e ? e(o.node) : o;
}
function nr(o, e, n, l = {}) {
  let s = l.maxScanDistance || ID, c = l.brackets || eM, d = bi(o), m = d.resolveInner(e, n);
  for (let y = m; y; y = y.parent) {
    let b = Gx(y.type, n, c);
    if (b && y.from < y.to) {
      let S = Yx(y);
      if (S && (n > 0 ? e >= S.from && e < S.to : e > S.from && e <= S.to))
        return X6(o, e, n, y, S, b, c);
    }
  }
  return j6(o, e, n, d, m.type, s, c);
}
function X6(o, e, n, l, s, c, d) {
  let m = l.parent, y = { from: s.from, to: s.to }, b = 0, S = m == null ? void 0 : m.cursor();
  if (S && (n < 0 ? S.childBefore(l.from) : S.childAfter(l.to)))
    do
      if (n < 0 ? S.to <= l.from : S.from >= l.to) {
        if (b == 0 && c.indexOf(S.type.name) > -1 && S.from < S.to) {
          let A = Yx(S);
          return { start: y, end: A ? { from: A.from, to: A.to } : void 0, matched: !0 };
        } else if (Gx(S.type, n, d))
          b++;
        else if (Gx(S.type, -n, d)) {
          if (b == 0) {
            let A = Yx(S);
            return {
              start: y,
              end: A && A.from < A.to ? { from: A.from, to: A.to } : void 0,
              matched: !1
            };
          }
          b--;
        }
      }
    while (n < 0 ? S.prevSibling() : S.nextSibling());
  return { start: y, matched: !1 };
}
function j6(o, e, n, l, s, c, d) {
  let m = n < 0 ? o.sliceDoc(e - 1, e) : o.sliceDoc(e, e + 1), y = d.indexOf(m);
  if (y < 0 || y % 2 == 0 != n > 0)
    return null;
  let b = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, S = o.doc.iterRange(e, n > 0 ? o.doc.length : 0), A = 0;
  for (let w = 0; !S.next().done && w <= c; ) {
    let E = S.value;
    n < 0 && (w += E.length);
    let z = e + w * n;
    for (let U = n > 0 ? 0 : E.length - 1, V = n > 0 ? E.length : -1; U != V; U += n) {
      let G = d.indexOf(E[U]);
      if (!(G < 0 || l.resolveInner(z + U, 1).type != s))
        if (G % 2 == 0 == n > 0)
          A++;
        else {
          if (A == 1)
            return { start: b, end: { from: z + U, to: z + U + 1 }, matched: G >> 1 == y >> 1 };
          A--;
        }
    }
    n > 0 && (w += E.length);
  }
  return S.done ? { start: b, matched: !1 } : null;
}
const G6 = /* @__PURE__ */ Object.create(null), cR = [Fl.none], fR = [], hR = /* @__PURE__ */ Object.create(null), Y6 = /* @__PURE__ */ Object.create(null);
for (let [o, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  Y6[o] = /* @__PURE__ */ $6(G6, e);
function jT(o, e) {
  fR.indexOf(o) > -1 || (fR.push(o), console.warn(e));
}
function $6(o, e) {
  let n = [];
  for (let m of e.split(" ")) {
    let y = [];
    for (let b of m.split(".")) {
      let S = o[b] || C[b];
      S ? typeof S == "function" ? y.length ? y = y.map(S) : jT(b, `Modifier ${b} used at start of tag`) : y.length ? jT(b, `Tag ${b} used as modifier`) : y = Array.isArray(S) ? S : [S] : jT(b, `Unknown highlighting tag ${b}`);
    }
    for (let b of y)
      n.push(b);
  }
  if (!n.length)
    return 0;
  let l = e.replace(/ /g, "_"), s = l + " " + n.map((m) => m.id), c = hR[s];
  if (c)
    return c.id;
  let d = hR[s] = Fl.define({
    id: cR.length,
    name: l,
    props: [qD({ [l]: n })]
  });
  return cR.push(d), d.id;
}
fn.RTL, fn.LTR;
const Z6 = (o) => {
  let { state: e } = o, n = e.doc.lineAt(e.selection.main.from), l = AA(o.state, n.from);
  return l.line ? P6(o) : l.block ? F6(o) : !1;
};
function xA(o, e) {
  return ({ state: n, dispatch: l }) => {
    if (n.readOnly)
      return !1;
    let s = o(e, n);
    return s ? (l(n.update(s)), !0) : !1;
  };
}
const P6 = /* @__PURE__ */ xA(
  I6,
  0
  /* CommentOption.Toggle */
), W6 = /* @__PURE__ */ xA(
  nM,
  0
  /* CommentOption.Toggle */
), F6 = /* @__PURE__ */ xA(
  (o, e) => nM(o, e, J6(e)),
  0
  /* CommentOption.Toggle */
);
function AA(o, e) {
  let n = o.languageDataAt("commentTokens", e, 1);
  return n.length ? n[0] : {};
}
const Fy = 50;
function K6(o, { open: e, close: n }, l, s) {
  let c = o.sliceDoc(l - Fy, l), d = o.sliceDoc(s, s + Fy), m = /\s*$/.exec(c)[0].length, y = /^\s*/.exec(d)[0].length, b = c.length - m;
  if (c.slice(b - e.length, b) == e && d.slice(y, y + n.length) == n)
    return {
      open: { pos: l - m, margin: m && 1 },
      close: { pos: s + y, margin: y && 1 }
    };
  let S, A;
  s - l <= 2 * Fy ? S = A = o.sliceDoc(l, s) : (S = o.sliceDoc(l, l + Fy), A = o.sliceDoc(s - Fy, s));
  let w = /^\s*/.exec(S)[0].length, E = /\s*$/.exec(A)[0].length, z = A.length - E - n.length;
  return S.slice(w, w + e.length) == e && A.slice(z, z + n.length) == n ? {
    open: {
      pos: l + w + e.length,
      margin: /\s/.test(S.charAt(w + e.length)) ? 1 : 0
    },
    close: {
      pos: s - E - n.length,
      margin: /\s/.test(A.charAt(z - 1)) ? 1 : 0
    }
  } : null;
}
function J6(o) {
  let e = [];
  for (let n of o.selection.ranges) {
    let l = o.doc.lineAt(n.from), s = n.to <= l.to ? l : o.doc.lineAt(n.to);
    s.from > l.from && s.from == n.to && (s = n.to == l.to + 1 ? l : o.doc.lineAt(n.to - 1));
    let c = e.length - 1;
    c >= 0 && e[c].to > l.from ? e[c].to = s.to : e.push({ from: l.from + /^\s*/.exec(l.text)[0].length, to: s.to });
  }
  return e;
}
function nM(o, e, n = e.selection.ranges) {
  let l = n.map((c) => AA(e, c.from).block);
  if (!l.every((c) => c))
    return null;
  let s = n.map((c, d) => K6(e, l[d], c.from, c.to));
  if (o != 2 && !s.every((c) => c))
    return { changes: e.changes(n.map((c, d) => s[d] ? [] : [{ from: c.from, insert: l[d].open + " " }, { from: c.to, insert: " " + l[d].close }])) };
  if (o != 1 && s.some((c) => c)) {
    let c = [];
    for (let d = 0, m; d < s.length; d++)
      if (m = s[d]) {
        let y = l[d], { open: b, close: S } = m;
        c.push({ from: b.pos - y.open.length, to: b.pos + b.margin }, { from: S.pos - S.margin, to: S.pos + y.close.length });
      }
    return { changes: c };
  }
  return null;
}
function I6(o, e, n = e.selection.ranges) {
  let l = [], s = -1;
  for (let { from: c, to: d } of n) {
    let m = l.length, y = 1e9, b = AA(e, c).line;
    if (b) {
      for (let S = c; S <= d; ) {
        let A = e.doc.lineAt(S);
        if (A.from > s && (c == d || d > A.from)) {
          s = A.from;
          let w = /^\s*/.exec(A.text)[0].length, E = w == A.length, z = A.text.slice(w, w + b.length) == b ? w : -1;
          w < A.text.length && w < y && (y = w), l.push({ line: A, comment: z, token: b, indent: w, empty: E, single: !1 });
        }
        S = A.to + 1;
      }
      if (y < 1e9)
        for (let S = m; S < l.length; S++)
          l[S].indent < l[S].line.text.length && (l[S].indent = y);
      l.length == m + 1 && (l[m].single = !0);
    }
  }
  if (o != 2 && l.some((c) => c.comment < 0 && (!c.empty || c.single))) {
    let c = [];
    for (let { line: m, token: y, indent: b, empty: S, single: A } of l)
      (A || !S) && c.push({ from: m.from + b, insert: y + " " });
    let d = e.changes(c);
    return { changes: d, selection: e.selection.map(d, 1) };
  } else if (o != 1 && l.some((c) => c.comment >= 0)) {
    let c = [];
    for (let { line: d, comment: m, token: y } of l)
      if (m >= 0) {
        let b = d.from + m, S = b + y.length;
        d.text[S - d.from] == " " && S++, c.push({ from: b, to: S });
      }
    return { changes: c };
  }
  return null;
}
const $x = /* @__PURE__ */ or.define(), e8 = /* @__PURE__ */ or.define(), t8 = /* @__PURE__ */ Be.define(), iM = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (l, s) => e(l, s) || n(l, s)
    });
  }
}), lM = /* @__PURE__ */ Si.define({
  create() {
    return ir.empty;
  },
  update(o, e) {
    let n = e.state.facet(iM), l = e.annotation($x);
    if (l) {
      let y = Pl.fromTransaction(e, l.selection), b = l.side, S = b == 0 ? o.undone : o.done;
      return y ? S = M1(S, S.length, n.minDepth, y) : S = sM(S, e.startState.selection), new ir(b == 0 ? l.rest : S, b == 0 ? S : l.rest);
    }
    let s = e.annotation(e8);
    if ((s == "full" || s == "before") && (o = o.isolate()), e.annotation(Pn.addToHistory) === !1)
      return e.changes.empty ? o : o.addMapping(e.changes.desc);
    let c = Pl.fromTransaction(e), d = e.annotation(Pn.time), m = e.annotation(Pn.userEvent);
    return c ? o = o.addChanges(c, d, m, n, e) : e.selection && (o = o.addSelection(e.startState.selection, d, m, n.newGroupDelay)), (s == "full" || s == "after") && (o = o.isolate()), o;
  },
  toJSON(o) {
    return { done: o.done.map((e) => e.toJSON()), undone: o.undone.map((e) => e.toJSON()) };
  },
  fromJSON(o) {
    return new ir(o.done.map(Pl.fromJSON), o.undone.map(Pl.fromJSON));
  }
});
function n8(o = {}) {
  return [
    lM,
    iM.of(o),
    Me.domEventHandlers({
      beforeinput(e, n) {
        let l = e.inputType == "historyUndo" ? aM : e.inputType == "historyRedo" ? Zx : null;
        return l ? (e.preventDefault(), l(n)) : !1;
      }
    })
  ];
}
function P1(o, e) {
  return function({ state: n, dispatch: l }) {
    if (!e && n.readOnly)
      return !1;
    let s = n.field(lM, !1);
    if (!s)
      return !1;
    let c = s.pop(o, n, e);
    return c ? (l(c), !0) : !1;
  };
}
const aM = /* @__PURE__ */ P1(0, !1), Zx = /* @__PURE__ */ P1(1, !1), i8 = /* @__PURE__ */ P1(0, !0), l8 = /* @__PURE__ */ P1(1, !0);
class Pl {
  constructor(e, n, l, s, c) {
    this.changes = e, this.effects = n, this.mapped = l, this.startSelection = s, this.selectionsAfter = c;
  }
  setSelAfter(e) {
    return new Pl(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, l;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (l = this.startSelection) === null || l === void 0 ? void 0 : l.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(e) {
    return new Pl(e.changes && ri.fromJSON(e.changes), [], e.mapped && lr.fromJSON(e.mapped), e.startSelection && ve.fromJSON(e.startSelection), e.selectionsAfter.map(ve.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, n) {
    let l = so;
    for (let s of e.startState.facet(t8)) {
      let c = s(e);
      c.length && (l = l.concat(c));
    }
    return !l.length && e.changes.empty ? null : new Pl(e.changes.invert(e.startState.doc), l, void 0, n || e.startState.selection, so);
  }
  static selection(e) {
    return new Pl(void 0, so, void 0, void 0, e);
  }
}
function M1(o, e, n, l) {
  let s = e + 1 > n + 20 ? e - n - 1 : 0, c = o.slice(s, e);
  return c.push(l), c;
}
function a8(o, e) {
  let n = [], l = !1;
  return o.iterChangedRanges((s, c) => n.push(s, c)), e.iterChangedRanges((s, c, d, m) => {
    for (let y = 0; y < n.length; ) {
      let b = n[y++], S = n[y++];
      m >= b && d <= S && (l = !0);
    }
  }), l;
}
function o8(o, e) {
  return o.ranges.length == e.ranges.length && o.ranges.filter((n, l) => n.empty != e.ranges[l].empty).length === 0;
}
function oM(o, e) {
  return o.length ? e.length ? o.concat(e) : o : e;
}
const so = [], s8 = 200;
function sM(o, e) {
  if (o.length) {
    let n = o[o.length - 1], l = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - s8));
    return l.length && l[l.length - 1].eq(e) ? o : (l.push(e), M1(o, o.length - 1, 1e9, n.setSelAfter(l)));
  } else
    return [Pl.selection([e])];
}
function r8(o) {
  let e = o[o.length - 1], n = o.slice();
  return n[o.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function GT(o, e) {
  if (!o.length)
    return o;
  let n = o.length, l = so;
  for (; n; ) {
    let s = u8(o[n - 1], e, l);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let c = o.slice(0, n);
      return c[n - 1] = s, c;
    } else
      e = s.mapped, n--, l = s.selectionsAfter;
  }
  return l.length ? [Pl.selection(l)] : so;
}
function u8(o, e, n) {
  let l = oM(o.selectionsAfter.length ? o.selectionsAfter.map((m) => m.map(e)) : so, n);
  if (!o.changes)
    return Pl.selection(l);
  let s = o.changes.map(e), c = e.mapDesc(o.changes, !0), d = o.mapped ? o.mapped.composeDesc(c) : c;
  return new Pl(s, it.mapEffects(o.effects, e), d, o.startSelection.map(c), l);
}
const c8 = /^(input\.type|delete)($|\.)/;
class ir {
  constructor(e, n, l = 0, s = void 0) {
    this.done = e, this.undone = n, this.prevTime = l, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new ir(this.done, this.undone) : this;
  }
  addChanges(e, n, l, s, c) {
    let d = this.done, m = d[d.length - 1];
    return m && m.changes && !m.changes.empty && e.changes && (!l || c8.test(l)) && (!m.selectionsAfter.length && n - this.prevTime < s.newGroupDelay && s.joinToEvent(c, a8(m.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    l == "input.type.compose") ? d = M1(d, d.length - 1, s.minDepth, new Pl(e.changes.compose(m.changes), oM(it.mapEffects(e.effects, m.changes), m.effects), m.mapped, m.startSelection, so)) : d = M1(d, d.length, s.minDepth, e), new ir(d, so, n, l);
  }
  addSelection(e, n, l, s) {
    let c = this.done.length ? this.done[this.done.length - 1].selectionsAfter : so;
    return c.length > 0 && n - this.prevTime < s && l == this.prevUserEvent && l && /^select($|\.)/.test(l) && o8(c[c.length - 1], e) ? this : new ir(sM(this.done, e), this.undone, n, l);
  }
  addMapping(e) {
    return new ir(GT(this.done, e), GT(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, l) {
    let s = e == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let c = s[s.length - 1], d = c.selectionsAfter[0] || n.selection;
    if (l && c.selectionsAfter.length)
      return n.update({
        selection: c.selectionsAfter[c.selectionsAfter.length - 1],
        annotations: $x.of({ side: e, rest: r8(s), selection: d }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (c.changes) {
      let m = s.length == 1 ? so : s.slice(0, s.length - 1);
      return c.mapped && (m = GT(m, c.mapped)), n.update({
        changes: c.changes,
        selection: c.startSelection,
        effects: c.effects,
        annotations: $x.of({ side: e, rest: m, selection: d }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ir.empty = /* @__PURE__ */ new ir(so, so);
const f8 = [
  { key: "Mod-z", run: aM, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Zx, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Zx, preventDefault: !0 },
  { key: "Mod-u", run: i8, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: l8, preventDefault: !0 }
];
function Ym(o, e) {
  return ve.create(o.ranges.map(e), o.mainIndex);
}
function ur(o, e) {
  return o.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ls({ state: o, dispatch: e }, n) {
  let l = Ym(o.selection, n);
  return l.eq(o.selection, !0) ? !1 : (e(ur(o, l)), !0);
}
function W1(o, e) {
  return ve.cursor(e ? o.to : o.from);
}
function rM(o, e) {
  return ls(o, (n) => n.empty ? o.moveByChar(n, e) : W1(n, e));
}
function ol(o) {
  return o.textDirectionAt(o.state.selection.main.head) == fn.LTR;
}
const uM = (o) => rM(o, !ol(o)), cM = (o) => rM(o, ol(o));
function fM(o, e) {
  return ls(o, (n) => n.empty ? o.moveByGroup(n, e) : W1(n, e));
}
const h8 = (o) => fM(o, !ol(o)), d8 = (o) => fM(o, ol(o));
function p8(o, e, n) {
  if (e.type.prop(n))
    return !0;
  let l = e.to - e.from;
  return l && (l > 2 || /[^\s,.;:]/.test(o.sliceDoc(e.from, e.to))) || e.firstChild;
}
function F1(o, e, n) {
  let l = bi(o).resolveInner(e.head), s = n ? bt.closedBy : bt.openedBy;
  for (let y = e.head; ; ) {
    let b = n ? l.childAfter(y) : l.childBefore(y);
    if (!b)
      break;
    p8(o, b, s) ? l = b : y = n ? b.to : b.from;
  }
  let c = l.type.prop(s), d, m;
  return c && (d = n ? nr(o, l.from, 1) : nr(o, l.to, -1)) && d.matched ? m = n ? d.end.to : d.end.from : m = n ? l.to : l.from, ve.cursor(m, n ? -1 : 1);
}
const m8 = (o) => ls(o, (e) => F1(o.state, e, !ol(o))), g8 = (o) => ls(o, (e) => F1(o.state, e, ol(o)));
function hM(o, e) {
  return ls(o, (n) => {
    if (!n.empty)
      return W1(n, e);
    let l = o.moveVertically(n, e);
    return l.head != n.head ? l : o.moveToLineBoundary(n, e);
  });
}
const dM = (o) => hM(o, !1), pM = (o) => hM(o, !0);
function mM(o) {
  let e = o.scrollDOM.clientHeight < o.scrollDOM.scrollHeight - 2, n = 0, l = 0, s;
  if (e) {
    for (let c of o.state.facet(Me.scrollMargins)) {
      let d = c(o);
      d != null && d.top && (n = Math.max(d == null ? void 0 : d.top, n)), d != null && d.bottom && (l = Math.max(d == null ? void 0 : d.bottom, l));
    }
    s = o.scrollDOM.clientHeight - n - l;
  } else
    s = (o.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: l,
    selfScroll: e,
    height: Math.max(o.defaultLineHeight, s - 5)
  };
}
function gM(o, e) {
  let n = mM(o), { state: l } = o, s = Ym(l.selection, (d) => d.empty ? o.moveVertically(d, e, n.height) : W1(d, e));
  if (s.eq(l.selection))
    return !1;
  let c;
  if (n.selfScroll) {
    let d = o.coordsAtPos(l.selection.main.head), m = o.scrollDOM.getBoundingClientRect(), y = m.top + n.marginTop, b = m.bottom - n.marginBottom;
    d && d.top > y && d.bottom < b && (c = Me.scrollIntoView(s.main.head, { y: "start", yMargin: d.top - y }));
  }
  return o.dispatch(ur(l, s), { effects: c }), !0;
}
const dR = (o) => gM(o, !1), Px = (o) => gM(o, !0);
function lf(o, e, n) {
  let l = o.lineBlockAt(e.head), s = o.moveToLineBoundary(e, n);
  if (s.head == e.head && s.head != (n ? l.to : l.from) && (s = o.moveToLineBoundary(e, n, !1)), !n && s.head == l.from && l.length) {
    let c = /^\s*/.exec(o.state.sliceDoc(l.from, Math.min(l.from + 100, l.to)))[0].length;
    c && e.head != l.from + c && (s = ve.cursor(l.from + c));
  }
  return s;
}
const y8 = (o) => ls(o, (e) => lf(o, e, !0)), O8 = (o) => ls(o, (e) => lf(o, e, !1)), v8 = (o) => ls(o, (e) => lf(o, e, !ol(o))), b8 = (o) => ls(o, (e) => lf(o, e, ol(o))), S8 = (o) => ls(o, (e) => ve.cursor(o.lineBlockAt(e.head).from, 1)), T8 = (o) => ls(o, (e) => ve.cursor(o.lineBlockAt(e.head).to, -1));
function x8(o, e, n) {
  let l = !1, s = Ym(o.selection, (c) => {
    let d = nr(o, c.head, -1) || nr(o, c.head, 1) || c.head > 0 && nr(o, c.head - 1, 1) || c.head < o.doc.length && nr(o, c.head + 1, -1);
    if (!d || !d.end)
      return c;
    l = !0;
    let m = d.start.from == c.head ? d.end.to : d.end.from;
    return ve.cursor(m);
  });
  return l ? (e(ur(o, s)), !0) : !1;
}
const A8 = ({ state: o, dispatch: e }) => x8(o, e);
function fo(o, e) {
  let n = Ym(o.state.selection, (l) => {
    let s = e(l);
    return ve.range(l.anchor, s.head, s.goalColumn, s.bidiLevel || void 0);
  });
  return n.eq(o.state.selection) ? !1 : (o.dispatch(ur(o.state, n)), !0);
}
function yM(o, e) {
  return fo(o, (n) => o.moveByChar(n, e));
}
const OM = (o) => yM(o, !ol(o)), vM = (o) => yM(o, ol(o));
function bM(o, e) {
  return fo(o, (n) => o.moveByGroup(n, e));
}
const w8 = (o) => bM(o, !ol(o)), E8 = (o) => bM(o, ol(o)), C8 = (o) => fo(o, (e) => F1(o.state, e, !ol(o))), R8 = (o) => fo(o, (e) => F1(o.state, e, ol(o)));
function SM(o, e) {
  return fo(o, (n) => o.moveVertically(n, e));
}
const TM = (o) => SM(o, !1), xM = (o) => SM(o, !0);
function AM(o, e) {
  return fo(o, (n) => o.moveVertically(n, e, mM(o).height));
}
const pR = (o) => AM(o, !1), mR = (o) => AM(o, !0), k8 = (o) => fo(o, (e) => lf(o, e, !0)), D8 = (o) => fo(o, (e) => lf(o, e, !1)), M8 = (o) => fo(o, (e) => lf(o, e, !ol(o))), z8 = (o) => fo(o, (e) => lf(o, e, ol(o))), Q8 = (o) => fo(o, (e) => ve.cursor(o.lineBlockAt(e.head).from)), N8 = (o) => fo(o, (e) => ve.cursor(o.lineBlockAt(e.head).to)), gR = ({ state: o, dispatch: e }) => (e(ur(o, { anchor: 0 })), !0), yR = ({ state: o, dispatch: e }) => (e(ur(o, { anchor: o.doc.length })), !0), OR = ({ state: o, dispatch: e }) => (e(ur(o, { anchor: o.selection.main.anchor, head: 0 })), !0), vR = ({ state: o, dispatch: e }) => (e(ur(o, { anchor: o.selection.main.anchor, head: o.doc.length })), !0), U8 = ({ state: o, dispatch: e }) => (e(o.update({ selection: { anchor: 0, head: o.doc.length }, userEvent: "select" })), !0), B8 = ({ state: o, dispatch: e }) => {
  let n = K1(o).map(({ from: l, to: s }) => ve.range(l, Math.min(s + 1, o.doc.length)));
  return e(o.update({ selection: ve.create(n), userEvent: "select" })), !0;
}, q8 = ({ state: o, dispatch: e }) => {
  let n = Ym(o.selection, (l) => {
    let s = bi(o), c = s.resolveStack(l.from, 1);
    if (l.empty) {
      let d = s.resolveStack(l.from, -1);
      d.node.from >= c.node.from && d.node.to <= c.node.to && (c = d);
    }
    for (let d = c; d; d = d.next) {
      let { node: m } = d;
      if ((m.from < l.from && m.to >= l.to || m.to > l.to && m.from <= l.from) && d.next)
        return ve.range(m.to, m.from);
    }
    return l;
  });
  return n.eq(o.selection) ? !1 : (e(ur(o, n)), !0);
}, _8 = ({ state: o, dispatch: e }) => {
  let n = o.selection, l = null;
  return n.ranges.length > 1 ? l = ve.create([n.main]) : n.main.empty || (l = ve.create([ve.cursor(n.main.head)])), l ? (e(ur(o, l)), !0) : !1;
};
function QO(o, e) {
  if (o.state.readOnly)
    return !1;
  let n = "delete.selection", { state: l } = o, s = l.changeByRange((c) => {
    let { from: d, to: m } = c;
    if (d == m) {
      let y = e(c);
      y < d ? (n = "delete.backward", y = Pb(o, y, !1)) : y > d && (n = "delete.forward", y = Pb(o, y, !0)), d = Math.min(d, y), m = Math.max(m, y);
    } else
      d = Pb(o, d, !1), m = Pb(o, m, !0);
    return d == m ? { range: c } : { changes: { from: d, to: m }, range: ve.cursor(d, d < c.head ? -1 : 1) };
  });
  return s.changes.empty ? !1 : (o.dispatch(l.update(s, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? Me.announce.of(l.phrase("Selection deleted")) : void 0
  })), !0);
}
function Pb(o, e, n) {
  if (o instanceof Me)
    for (let l of o.state.facet(Me.atomicRanges).map((s) => s(o)))
      l.between(e, e, (s, c) => {
        s < e && c > e && (e = n ? c : s);
      });
  return e;
}
const wM = (o, e, n) => QO(o, (l) => {
  let s = l.from, { state: c } = o, d = c.doc.lineAt(s), m, y;
  if (n && !e && s > d.from && s < d.from + 200 && !/[^ \t]/.test(m = d.text.slice(0, s - d.from))) {
    if (m[m.length - 1] == "	")
      return s - 1;
    let b = jm(m, c.tabSize), S = b % R1(c) || R1(c);
    for (let A = 0; A < S && m[m.length - 1 - A] == " "; A++)
      s--;
    y = s;
  } else
    y = Ni(d.text, s - d.from, e, e) + d.from, y == s && d.number != (e ? c.doc.lines : 1) ? y += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(d.text.slice(y - d.from, s - d.from)) && (y = Ni(d.text, y - d.from, !1, !1) + d.from);
  return y;
}), Wx = (o) => wM(o, !1, !0), EM = (o) => wM(o, !0, !1), CM = (o, e) => QO(o, (n) => {
  let l = n.head, { state: s } = o, c = s.doc.lineAt(l), d = s.charCategorizer(l);
  for (let m = null; ; ) {
    if (l == (e ? c.to : c.from)) {
      l == n.head && c.number != (e ? s.doc.lines : 1) && (l += e ? 1 : -1);
      break;
    }
    let y = Ni(c.text, l - c.from, e) + c.from, b = c.text.slice(Math.min(l, y) - c.from, Math.max(l, y) - c.from), S = d(b);
    if (m != null && S != m)
      break;
    (b != " " || l != n.head) && (m = S), l = y;
  }
  return l;
}), RM = (o) => CM(o, !1), H8 = (o) => CM(o, !0), L8 = (o) => QO(o, (e) => {
  let n = o.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(o.state.doc.length, e.head + 1);
}), V8 = (o) => QO(o, (e) => {
  let n = o.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), X8 = (o) => QO(o, (e) => {
  let n = o.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(o.state.doc.length, e.head + 1);
}), j8 = ({ state: o, dispatch: e }) => {
  if (o.readOnly)
    return !1;
  let n = o.changeByRange((l) => ({
    changes: { from: l.from, to: l.to, insert: kt.of(["", ""]) },
    range: ve.cursor(l.from)
  }));
  return e(o.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, G8 = ({ state: o, dispatch: e }) => {
  if (o.readOnly)
    return !1;
  let n = o.changeByRange((l) => {
    if (!l.empty || l.from == 0 || l.from == o.doc.length)
      return { range: l };
    let s = l.from, c = o.doc.lineAt(s), d = s == c.from ? s - 1 : Ni(c.text, s - c.from, !1) + c.from, m = s == c.to ? s + 1 : Ni(c.text, s - c.from, !0) + c.from;
    return {
      changes: { from: d, to: m, insert: o.doc.slice(s, m).append(o.doc.slice(d, s)) },
      range: ve.cursor(m)
    };
  });
  return n.changes.empty ? !1 : (e(o.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function K1(o) {
  let e = [], n = -1;
  for (let l of o.selection.ranges) {
    let s = o.doc.lineAt(l.from), c = o.doc.lineAt(l.to);
    if (!l.empty && l.to == c.from && (c = o.doc.lineAt(l.to - 1)), n >= s.number) {
      let d = e[e.length - 1];
      d.to = c.to, d.ranges.push(l);
    } else
      e.push({ from: s.from, to: c.to, ranges: [l] });
    n = c.number + 1;
  }
  return e;
}
function kM(o, e, n) {
  if (o.readOnly)
    return !1;
  let l = [], s = [];
  for (let c of K1(o)) {
    if (n ? c.to == o.doc.length : c.from == 0)
      continue;
    let d = o.doc.lineAt(n ? c.to + 1 : c.from - 1), m = d.length + 1;
    if (n) {
      l.push({ from: c.to, to: d.to }, { from: c.from, insert: d.text + o.lineBreak });
      for (let y of c.ranges)
        s.push(ve.range(Math.min(o.doc.length, y.anchor + m), Math.min(o.doc.length, y.head + m)));
    } else {
      l.push({ from: d.from, to: c.from }, { from: c.to, insert: o.lineBreak + d.text });
      for (let y of c.ranges)
        s.push(ve.range(y.anchor - m, y.head - m));
    }
  }
  return l.length ? (e(o.update({
    changes: l,
    scrollIntoView: !0,
    selection: ve.create(s, o.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Y8 = ({ state: o, dispatch: e }) => kM(o, e, !1), $8 = ({ state: o, dispatch: e }) => kM(o, e, !0);
function DM(o, e, n) {
  if (o.readOnly)
    return !1;
  let l = [];
  for (let s of K1(o))
    n ? l.push({ from: s.from, insert: o.doc.slice(s.from, s.to) + o.lineBreak }) : l.push({ from: s.to, insert: o.lineBreak + o.doc.slice(s.from, s.to) });
  return e(o.update({ changes: l, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Z8 = ({ state: o, dispatch: e }) => DM(o, e, !1), P8 = ({ state: o, dispatch: e }) => DM(o, e, !0), W8 = (o) => {
  if (o.state.readOnly)
    return !1;
  let { state: e } = o, n = e.changes(K1(e).map(({ from: s, to: c }) => (s > 0 ? s-- : c < e.doc.length && c++, { from: s, to: c }))), l = Ym(e.selection, (s) => {
    let c;
    if (o.lineWrapping) {
      let d = o.lineBlockAt(s.head), m = o.coordsAtPos(s.head, s.assoc || 1);
      m && (c = d.bottom + o.documentTop - m.bottom + o.defaultLineHeight / 2);
    }
    return o.moveVertically(s, !0, c);
  }).map(n);
  return o.dispatch({ changes: n, selection: l, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function F8(o, e) {
  if (/\(\)|\[\]|\{\}/.test(o.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = bi(o).resolveInner(e), l = n.childBefore(e), s = n.childAfter(e), c;
  return l && s && l.to <= e && s.from >= e && (c = l.type.prop(bt.closedBy)) && c.indexOf(s.name) > -1 && o.doc.lineAt(l.to).from == o.doc.lineAt(s.from).from && !/\S/.test(o.sliceDoc(l.to, s.from)) ? { from: l.to, to: s.from } : null;
}
const bR = /* @__PURE__ */ MM(!1), K8 = /* @__PURE__ */ MM(!0);
function MM(o) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let l = e.changeByRange((s) => {
      let { from: c, to: d } = s, m = e.doc.lineAt(c), y = !o && c == d && F8(e, c);
      o && (c = d = (d <= m.to ? m : e.doc.lineAt(d)).to);
      let b = new $1(e, { simulateBreak: c, simulateDoubleBreak: !!y }), S = bA(b, c);
      for (S == null && (S = jm(/^\s*/.exec(e.doc.lineAt(c).text)[0], e.tabSize)); d < m.to && /\s/.test(m.text[d - m.from]); )
        d++;
      y ? { from: c, to: d } = y : c > m.from && c < m.from + 100 && !/\S/.test(m.text.slice(0, c)) && (c = m.from);
      let A = ["", OO(e, S)];
      return y && A.push(OO(e, b.lineIndent(m.from, -1))), {
        changes: { from: c, to: d, insert: kt.of(A) },
        range: ve.cursor(c + 1 + A[1].length)
      };
    });
    return n(e.update(l, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function wA(o, e) {
  let n = -1;
  return o.changeByRange((l) => {
    let s = [];
    for (let d = l.from; d <= l.to; ) {
      let m = o.doc.lineAt(d);
      m.number > n && (l.empty || l.to > m.from) && (e(m, s, l), n = m.number), d = m.to + 1;
    }
    let c = o.changes(s);
    return {
      changes: s,
      range: ve.range(c.mapPos(l.anchor, 1), c.mapPos(l.head, 1))
    };
  });
}
const J8 = ({ state: o, dispatch: e }) => {
  if (o.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), l = new $1(o, { overrideIndentation: (c) => {
    let d = n[c];
    return d ?? -1;
  } }), s = wA(o, (c, d, m) => {
    let y = bA(l, c.from);
    if (y == null)
      return;
    /\S/.test(c.text) || (y = 0);
    let b = /^\s*/.exec(c.text)[0], S = OO(o, y);
    (b != S || m.from < c.from + b.length) && (n[c.from] = y, d.push({ from: c.from, to: c.from + b.length, insert: S }));
  });
  return s.changes.empty || e(o.update(s, { userEvent: "indent" })), !0;
}, zM = ({ state: o, dispatch: e }) => o.readOnly ? !1 : (e(o.update(wA(o, (n, l) => {
  l.push({ from: n.from, insert: o.facet(MO) });
}), { userEvent: "input.indent" })), !0), QM = ({ state: o, dispatch: e }) => o.readOnly ? !1 : (e(o.update(wA(o, (n, l) => {
  let s = /^\s*/.exec(n.text)[0];
  if (!s)
    return;
  let c = jm(s, o.tabSize), d = 0, m = OO(o, Math.max(0, c - R1(o)));
  for (; d < s.length && d < m.length && s.charCodeAt(d) == m.charCodeAt(d); )
    d++;
  l.push({ from: n.from + d, to: n.from + s.length, insert: m.slice(d) });
}), { userEvent: "delete.dedent" })), !0), I8 = (o) => (o.setTabFocusMode(), !0), eN = [
  { key: "Ctrl-b", run: uM, shift: OM, preventDefault: !0 },
  { key: "Ctrl-f", run: cM, shift: vM },
  { key: "Ctrl-p", run: dM, shift: TM },
  { key: "Ctrl-n", run: pM, shift: xM },
  { key: "Ctrl-a", run: S8, shift: Q8 },
  { key: "Ctrl-e", run: T8, shift: N8 },
  { key: "Ctrl-d", run: EM },
  { key: "Ctrl-h", run: Wx },
  { key: "Ctrl-k", run: L8 },
  { key: "Ctrl-Alt-h", run: RM },
  { key: "Ctrl-o", run: j8 },
  { key: "Ctrl-t", run: G8 },
  { key: "Ctrl-v", run: Px }
], tN = /* @__PURE__ */ [
  { key: "ArrowLeft", run: uM, shift: OM, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: h8, shift: w8, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: v8, shift: M8, preventDefault: !0 },
  { key: "ArrowRight", run: cM, shift: vM, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: d8, shift: E8, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: b8, shift: z8, preventDefault: !0 },
  { key: "ArrowUp", run: dM, shift: TM, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: gR, shift: OR },
  { mac: "Ctrl-ArrowUp", run: dR, shift: pR },
  { key: "ArrowDown", run: pM, shift: xM, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: yR, shift: vR },
  { mac: "Ctrl-ArrowDown", run: Px, shift: mR },
  { key: "PageUp", run: dR, shift: pR },
  { key: "PageDown", run: Px, shift: mR },
  { key: "Home", run: O8, shift: D8, preventDefault: !0 },
  { key: "Mod-Home", run: gR, shift: OR },
  { key: "End", run: y8, shift: k8, preventDefault: !0 },
  { key: "Mod-End", run: yR, shift: vR },
  { key: "Enter", run: bR, shift: bR },
  { key: "Mod-a", run: U8 },
  { key: "Backspace", run: Wx, shift: Wx },
  { key: "Delete", run: EM },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: RM },
  { key: "Mod-Delete", mac: "Alt-Delete", run: H8 },
  { mac: "Mod-Backspace", run: V8 },
  { mac: "Mod-Delete", run: X8 }
].concat(/* @__PURE__ */ eN.map((o) => ({ mac: o.key, run: o.run, shift: o.shift }))), nN = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: m8, shift: C8 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: g8, shift: R8 },
  { key: "Alt-ArrowUp", run: Y8 },
  { key: "Shift-Alt-ArrowUp", run: Z8 },
  { key: "Alt-ArrowDown", run: $8 },
  { key: "Shift-Alt-ArrowDown", run: P8 },
  { key: "Escape", run: _8 },
  { key: "Mod-Enter", run: K8 },
  { key: "Alt-l", mac: "Ctrl-l", run: B8 },
  { key: "Mod-i", run: q8, preventDefault: !0 },
  { key: "Mod-[", run: QM },
  { key: "Mod-]", run: zM },
  { key: "Mod-Alt-\\", run: J8 },
  { key: "Shift-Mod-k", run: W8 },
  { key: "Shift-Mod-\\", run: A8 },
  { key: "Mod-/", run: Z6 },
  { key: "Alt-A", run: W6 },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: I8 }
].concat(tN), iN = { key: "Tab", run: zM, shift: QM };
function tn() {
  var o = arguments[0];
  typeof o == "string" && (o = document.createElement(o));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var l in n) if (Object.prototype.hasOwnProperty.call(n, l)) {
      var s = n[l];
      typeof s == "string" ? o.setAttribute(l, s) : s != null && (o[l] = s);
    }
    e++;
  }
  for (; e < arguments.length; e++) NM(o, arguments[e]);
  return o;
}
function NM(o, e) {
  if (typeof e == "string")
    o.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    o.appendChild(e);
  else if (Array.isArray(e))
    for (var n = 0; n < e.length; n++) NM(o, e[n]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
const SR = typeof String.prototype.normalize == "function" ? (o) => o.normalize("NFKD") : (o) => o;
class Lm {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.

  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.

  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, n, l = 0, s = e.length, c, d) {
    this.test = d, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(l, s), this.bufferStart = l, this.normalize = c ? (m) => c(SR(m)) : SR, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Gl(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = eA(e), l = this.bufferStart + this.bufferPos;
      this.bufferPos += Is(e);
      let s = this.normalize(n);
      if (s.length)
        for (let c = 0, d = l; ; c++) {
          let m = s.charCodeAt(c), y = this.match(m, d, this.bufferPos + this.bufferStart);
          if (c == s.length - 1) {
            if (y)
              return this.value = y, this;
            break;
          }
          d == l && c < n.length && n.charCodeAt(c) == m && d++;
        }
    }
  }
  match(e, n, l) {
    let s = null;
    for (let c = 0; c < this.matches.length; c += 2) {
      let d = this.matches[c], m = !1;
      this.query.charCodeAt(d) == e && (d == this.query.length - 1 ? s = { from: this.matches[c + 1], to: l } : (this.matches[c]++, m = !0)), m || (this.matches.splice(c, 2), c -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? s = { from: n, to: l } : this.matches.push(1, n)), s && this.test && !this.test(s.from, s.to, this.buffer, this.bufferStart) && (s = null), s;
  }
}
typeof Symbol < "u" && (Lm.prototype[Symbol.iterator] = function() {
  return this;
});
const UM = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, EA = "gm" + (/x/.unicode == null ? "" : "u");
class BM {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, n, l, s = 0, c = e.length) {
    if (this.text = e, this.to = c, this.curLine = "", this.done = !1, this.value = UM, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new qM(e, n, l, s, c);
    this.re = new RegExp(n, EA + (l != null && l.ignoreCase ? "i" : "")), this.test = l == null ? void 0 : l.test, this.iter = e.iter();
    let d = e.lineAt(s);
    this.curLineStart = d.from, this.matchPos = z1(e, s), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let l = this.curLineStart + n.index, s = l + n[0].length;
        if (this.matchPos = z1(this.text, s + (l == s ? 1 : 0)), l == this.curLineStart + this.curLine.length && this.nextLine(), (l < s || l > this.value.to) && (!this.test || this.test(l, s, n)))
          return this.value = { from: l, to: s, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const YT = /* @__PURE__ */ new WeakMap();
class Mm {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, l) {
    let s = YT.get(e);
    if (!s || s.from >= l || s.to <= n) {
      let m = new Mm(n, e.sliceString(n, l));
      return YT.set(e, m), m;
    }
    if (s.from == n && s.to == l)
      return s;
    let { text: c, from: d } = s;
    return d > n && (c = e.sliceString(n, d) + c, d = n), s.to < l && (c += e.sliceString(s.to, l)), YT.set(e, new Mm(d, c)), new Mm(n, c.slice(n - d, l - d));
  }
}
class qM {
  constructor(e, n, l, s, c) {
    this.text = e, this.to = c, this.done = !1, this.value = UM, this.matchPos = z1(e, s), this.re = new RegExp(n, EA + (l != null && l.ignoreCase ? "i" : "")), this.test = l == null ? void 0 : l.test, this.flat = Mm.get(e, s, this.chunkEnd(
      s + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let l = this.flat.from + n.index, s = l + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(l, s, n)))
          return this.value = { from: l, to: s, match: n }, this.matchPos = z1(this.text, s + (l == s ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Mm.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (BM.prototype[Symbol.iterator] = qM.prototype[Symbol.iterator] = function() {
  return this;
});
function lN(o) {
  try {
    return new RegExp(o, EA), !0;
  } catch {
    return !1;
  }
}
function z1(o, e) {
  if (e >= o.length)
    return e;
  let n = o.lineAt(e), l;
  for (; e < n.to && (l = n.text.charCodeAt(e - n.from)) >= 56320 && l < 57344; )
    e++;
  return e;
}
function Fx(o) {
  let e = String(o.state.doc.lineAt(o.state.selection.main.head).number), n = tn("input", { class: "cm-textfield", name: "line", value: e }), l = tn("form", {
    class: "cm-gotoLine",
    onkeydown: (c) => {
      c.keyCode == 27 ? (c.preventDefault(), o.dispatch({ effects: rO.of(!1) }), o.focus()) : c.keyCode == 13 && (c.preventDefault(), s());
    },
    onsubmit: (c) => {
      c.preventDefault(), s();
    }
  }, tn("label", o.state.phrase("Go to line"), ": ", n), " ", tn("button", { class: "cm-button", type: "submit" }, o.state.phrase("go")), tn("button", {
    name: "close",
    onclick: () => {
      o.dispatch({ effects: rO.of(!1) }), o.focus();
    },
    "aria-label": o.state.phrase("close"),
    type: "button"
  }, [""]));
  function s() {
    let c = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!c)
      return;
    let { state: d } = o, m = d.doc.lineAt(d.selection.main.head), [, y, b, S, A] = c, w = S ? +S.slice(1) : 0, E = b ? +b : m.number;
    if (b && A) {
      let V = E / 100;
      y && (V = V * (y == "-" ? -1 : 1) + m.number / d.doc.lines), E = Math.round(d.doc.lines * V);
    } else b && y && (E = E * (y == "-" ? -1 : 1) + m.number);
    let z = d.doc.line(Math.max(1, Math.min(d.doc.lines, E))), U = ve.cursor(z.from + Math.max(0, Math.min(w, z.length)));
    o.dispatch({
      effects: [rO.of(!1), Me.scrollIntoView(U.from, { y: "center" })],
      selection: U
    }), o.focus();
  }
  return { dom: l };
}
const rO = /* @__PURE__ */ it.define(), TR = /* @__PURE__ */ Si.define({
  create() {
    return !0;
  },
  update(o, e) {
    for (let n of e.effects)
      n.is(rO) && (o = n.value);
    return o;
  },
  provide: (o) => gO.from(o, (e) => e ? Fx : null)
}), aN = (o) => {
  let e = mO(o, Fx);
  if (!e) {
    let n = [rO.of(!0)];
    o.state.field(TR, !1) == null && n.push(it.appendConfig.of([TR, oN])), o.dispatch({ effects: n }), e = mO(o, Fx);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, oN = /* @__PURE__ */ Me.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), sN = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, rN = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, sN, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function uN(o) {
  return [pN, dN];
}
const cN = /* @__PURE__ */ Ze.mark({ class: "cm-selectionMatch" }), fN = /* @__PURE__ */ Ze.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function xR(o, e, n, l) {
  return (n == 0 || o(e.sliceDoc(n - 1, n)) != yn.Word) && (l == e.doc.length || o(e.sliceDoc(l, l + 1)) != yn.Word);
}
function hN(o, e, n, l) {
  return o(e.sliceDoc(n, n + 1)) == yn.Word && o(e.sliceDoc(l - 1, l)) == yn.Word;
}
const dN = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.decorations = this.getDeco(o);
  }
  update(o) {
    (o.selectionSet || o.docChanged || o.viewportChanged) && (this.decorations = this.getDeco(o.view));
  }
  getDeco(o) {
    let e = o.state.facet(rN), { state: n } = o, l = n.selection;
    if (l.ranges.length > 1)
      return Ze.none;
    let s = l.main, c, d = null;
    if (s.empty) {
      if (!e.highlightWordAroundCursor)
        return Ze.none;
      let y = n.wordAt(s.head);
      if (!y)
        return Ze.none;
      d = n.charCategorizer(s.head), c = n.sliceDoc(y.from, y.to);
    } else {
      let y = s.to - s.from;
      if (y < e.minSelectionLength || y > 200)
        return Ze.none;
      if (e.wholeWords) {
        if (c = n.sliceDoc(s.from, s.to), d = n.charCategorizer(s.head), !(xR(d, n, s.from, s.to) && hN(d, n, s.from, s.to)))
          return Ze.none;
      } else if (c = n.sliceDoc(s.from, s.to), !c)
        return Ze.none;
    }
    let m = [];
    for (let y of o.visibleRanges) {
      let b = new Lm(n.doc, c, y.from, y.to);
      for (; !b.next().done; ) {
        let { from: S, to: A } = b.value;
        if ((!d || xR(d, n, S, A)) && (s.empty && S <= s.from && A >= s.to ? m.push(fN.range(S, A)) : (S >= s.to || A <= s.from) && m.push(cN.range(S, A)), m.length > e.maxMatches))
          return Ze.none;
      }
    }
    return Ze.set(m);
  }
}, {
  decorations: (o) => o.decorations
}), pN = /* @__PURE__ */ Me.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), mN = ({ state: o, dispatch: e }) => {
  let { selection: n } = o, l = ve.create(n.ranges.map((s) => o.wordAt(s.head) || ve.cursor(s.head)), n.mainIndex);
  return l.eq(n) ? !1 : (e(o.update({ selection: l })), !0);
};
function gN(o, e) {
  let { main: n, ranges: l } = o.selection, s = o.wordAt(n.head), c = s && s.from == n.from && s.to == n.to;
  for (let d = !1, m = new Lm(o.doc, e, l[l.length - 1].to); ; )
    if (m.next(), m.done) {
      if (d)
        return null;
      m = new Lm(o.doc, e, 0, Math.max(0, l[l.length - 1].from - 1)), d = !0;
    } else {
      if (d && l.some((y) => y.from == m.value.from))
        continue;
      if (c) {
        let y = o.wordAt(m.value.from);
        if (!y || y.from != m.value.from || y.to != m.value.to)
          continue;
      }
      return m.value;
    }
}
const yN = ({ state: o, dispatch: e }) => {
  let { ranges: n } = o.selection;
  if (n.some((c) => c.from === c.to))
    return mN({ state: o, dispatch: e });
  let l = o.sliceDoc(n[0].from, n[0].to);
  if (o.selection.ranges.some((c) => o.sliceDoc(c.from, c.to) != l))
    return !1;
  let s = gN(o, l);
  return s ? (e(o.update({
    selection: o.selection.addRange(ve.range(s.from, s.to), !1),
    effects: Me.scrollIntoView(s.to)
  })), !0) : !1;
}, $m = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new kN(e),
      scrollToMatch: (e) => Me.scrollIntoView(e)
    });
  }
});
class _M {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || lN(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, l) => l == "n" ? `
` : l == "r" ? "\r" : l == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new SN(this) : new vN(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, n = 0, l) {
    let s = e.doc ? e : At.create({ doc: e });
    return l == null && (l = s.doc.length), this.regexp ? Am(this, s, n, l) : xm(this, s, n, l);
  }
}
class HM {
  constructor(e) {
    this.spec = e;
  }
}
function xm(o, e, n, l) {
  return new Lm(e.doc, o.unquoted, n, l, o.caseSensitive ? void 0 : (s) => s.toLowerCase(), o.wholeWord ? ON(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function ON(o, e) {
  return (n, l, s, c) => ((c > n || c + s.length < l) && (c = Math.max(0, n - 2), s = o.sliceString(c, Math.min(o.length, l + 2))), (e(Q1(s, n - c)) != yn.Word || e(N1(s, n - c)) != yn.Word) && (e(N1(s, l - c)) != yn.Word || e(Q1(s, l - c)) != yn.Word));
}
class vN extends HM {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, l) {
    let s = xm(this.spec, e, l, e.doc.length).nextOverlapping();
    if (s.done) {
      let c = Math.min(e.doc.length, n + this.spec.unquoted.length);
      s = xm(this.spec, e, 0, c).nextOverlapping();
    }
    return s.done || s.value.from == n && s.value.to == l ? null : s.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, n, l) {
    for (let s = l; ; ) {
      let c = Math.max(n, s - 1e4 - this.spec.unquoted.length), d = xm(this.spec, e, c, s), m = null;
      for (; !d.nextOverlapping().done; )
        m = d.value;
      if (m)
        return m;
      if (c == n)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(e, n, l) {
    let s = this.prevMatchInRange(e, 0, n);
    return s || (s = this.prevMatchInRange(e, Math.max(0, l - this.spec.unquoted.length), e.doc.length)), s && (s.from != n || s.to != l) ? s : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let l = xm(this.spec, e, 0, e.doc.length), s = [];
    for (; !l.next().done; ) {
      if (s.length >= n)
        return null;
      s.push(l.value);
    }
    return s;
  }
  highlight(e, n, l, s) {
    let c = xm(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(l + this.spec.unquoted.length, e.doc.length));
    for (; !c.next().done; )
      s(c.value.from, c.value.to);
  }
}
function Am(o, e, n, l) {
  return new BM(e.doc, o.search, {
    ignoreCase: !o.caseSensitive,
    test: o.wholeWord ? bN(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, l);
}
function Q1(o, e) {
  return o.slice(Ni(o, e, !1), e);
}
function N1(o, e) {
  return o.slice(e, Ni(o, e));
}
function bN(o) {
  return (e, n, l) => !l[0].length || (o(Q1(l.input, l.index)) != yn.Word || o(N1(l.input, l.index)) != yn.Word) && (o(N1(l.input, l.index + l[0].length)) != yn.Word || o(Q1(l.input, l.index + l[0].length)) != yn.Word);
}
class SN extends HM {
  nextMatch(e, n, l) {
    let s = Am(this.spec, e, l, e.doc.length).next();
    return s.done && (s = Am(this.spec, e, 0, n).next()), s.done ? null : s.value;
  }
  prevMatchInRange(e, n, l) {
    for (let s = 1; ; s++) {
      let c = Math.max(
        n,
        l - s * 1e4
        /* FindPrev.ChunkSize */
      ), d = Am(this.spec, e, c, l), m = null;
      for (; !d.next().done; )
        m = d.value;
      if (m && (c == n || m.from > c + 10))
        return m;
      if (c == n)
        return null;
    }
  }
  prevMatch(e, n, l) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, l, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (n, l) => {
      if (l == "&")
        return e.match[0];
      if (l == "$")
        return "$";
      for (let s = l.length; s > 0; s--) {
        let c = +l.slice(0, s);
        if (c > 0 && c < e.match.length)
          return e.match[c] + l.slice(s);
      }
      return n;
    });
  }
  matchAll(e, n) {
    let l = Am(this.spec, e, 0, e.doc.length), s = [];
    for (; !l.next().done; ) {
      if (s.length >= n)
        return null;
      s.push(l.value);
    }
    return s;
  }
  highlight(e, n, l, s) {
    let c = Am(this.spec, e, Math.max(
      0,
      n - 250
      /* RegExp.HighlightMargin */
    ), Math.min(l + 250, e.doc.length));
    for (; !c.next().done; )
      s(c.value.from, c.value.to);
  }
}
const vO = /* @__PURE__ */ it.define(), CA = /* @__PURE__ */ it.define(), Fc = /* @__PURE__ */ Si.define({
  create(o) {
    return new $T(Kx(o).create(), null);
  },
  update(o, e) {
    for (let n of e.effects)
      n.is(vO) ? o = new $T(n.value.create(), o.panel) : n.is(CA) && (o = new $T(o.query, n.value ? RA : null));
    return o;
  },
  provide: (o) => gO.from(o, (e) => e.panel)
});
class $T {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const TN = /* @__PURE__ */ Ze.mark({ class: "cm-searchMatch" }), xN = /* @__PURE__ */ Ze.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), AN = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.view = o, this.decorations = this.highlight(o.state.field(Fc));
  }
  update(o) {
    let e = o.state.field(Fc);
    (e != o.startState.field(Fc) || o.docChanged || o.selectionSet || o.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: o, panel: e }) {
    if (!e || !o.spec.valid)
      return Ze.none;
    let { view: n } = this, l = new yu();
    for (let s = 0, c = n.visibleRanges, d = c.length; s < d; s++) {
      let { from: m, to: y } = c[s];
      for (; s < d - 1 && y > c[s + 1].from - 2 * 250; )
        y = c[++s].to;
      o.highlight(n.state, m, y, (b, S) => {
        let A = n.state.selection.ranges.some((w) => w.from == b && w.to == S);
        l.add(b, S, A ? xN : TN);
      });
    }
    return l.finish();
  }
}, {
  decorations: (o) => o.decorations
});
function NO(o) {
  return (e) => {
    let n = e.state.field(Fc, !1);
    return n && n.query.spec.valid ? o(e, n) : XM(e);
  };
}
const U1 = /* @__PURE__ */ NO((o, { query: e }) => {
  let { to: n } = o.state.selection.main, l = e.nextMatch(o.state, n, n);
  if (!l)
    return !1;
  let s = ve.single(l.from, l.to), c = o.state.facet($m);
  return o.dispatch({
    selection: s,
    effects: [kA(o, l), c.scrollToMatch(s.main, o)],
    userEvent: "select.search"
  }), VM(o), !0;
}), B1 = /* @__PURE__ */ NO((o, { query: e }) => {
  let { state: n } = o, { from: l } = n.selection.main, s = e.prevMatch(n, l, l);
  if (!s)
    return !1;
  let c = ve.single(s.from, s.to), d = o.state.facet($m);
  return o.dispatch({
    selection: c,
    effects: [kA(o, s), d.scrollToMatch(c.main, o)],
    userEvent: "select.search"
  }), VM(o), !0;
}), wN = /* @__PURE__ */ NO((o, { query: e }) => {
  let n = e.matchAll(o.state, 1e3);
  return !n || !n.length ? !1 : (o.dispatch({
    selection: ve.create(n.map((l) => ve.range(l.from, l.to))),
    userEvent: "select.search.matches"
  }), !0);
}), EN = ({ state: o, dispatch: e }) => {
  let n = o.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: l, to: s } = n.main, c = [], d = 0;
  for (let m = new Lm(o.doc, o.sliceDoc(l, s)); !m.next().done; ) {
    if (c.length > 1e3)
      return !1;
    m.value.from == l && (d = c.length), c.push(ve.range(m.value.from, m.value.to));
  }
  return e(o.update({
    selection: ve.create(c, d),
    userEvent: "select.search.matches"
  })), !0;
}, AR = /* @__PURE__ */ NO((o, { query: e }) => {
  let { state: n } = o, { from: l, to: s } = n.selection.main;
  if (n.readOnly)
    return !1;
  let c = e.nextMatch(n, l, l);
  if (!c)
    return !1;
  let d = c, m = [], y, b, S = [];
  if (d.from == l && d.to == s && (b = n.toText(e.getReplacement(d)), m.push({ from: d.from, to: d.to, insert: b }), d = e.nextMatch(n, d.from, d.to), S.push(Me.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(l).number) + "."))), d) {
    let A = m.length == 0 || m[0].from >= c.to ? 0 : c.to - c.from - b.length;
    y = ve.single(d.from - A, d.to - A), S.push(kA(o, d)), S.push(n.facet($m).scrollToMatch(y.main, o));
  }
  return o.dispatch({
    changes: m,
    selection: y,
    effects: S,
    userEvent: "input.replace"
  }), !0;
}), CN = /* @__PURE__ */ NO((o, { query: e }) => {
  if (o.state.readOnly)
    return !1;
  let n = e.matchAll(o.state, 1e9).map((s) => {
    let { from: c, to: d } = s;
    return { from: c, to: d, insert: e.getReplacement(s) };
  });
  if (!n.length)
    return !1;
  let l = o.state.phrase("replaced $ matches", n.length) + ".";
  return o.dispatch({
    changes: n,
    effects: Me.announce.of(l),
    userEvent: "input.replace.all"
  }), !0;
});
function RA(o) {
  return o.state.facet($m).createPanel(o);
}
function Kx(o, e) {
  var n, l, s, c, d;
  let m = o.selection.main, y = m.empty || m.to > m.from + 100 ? "" : o.sliceDoc(m.from, m.to);
  if (e && !y)
    return e;
  let b = o.facet($m);
  return new _M({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : b.literal) ? y : y.replace(/\n/g, "\\n"),
    caseSensitive: (l = e == null ? void 0 : e.caseSensitive) !== null && l !== void 0 ? l : b.caseSensitive,
    literal: (s = e == null ? void 0 : e.literal) !== null && s !== void 0 ? s : b.literal,
    regexp: (c = e == null ? void 0 : e.regexp) !== null && c !== void 0 ? c : b.regexp,
    wholeWord: (d = e == null ? void 0 : e.wholeWord) !== null && d !== void 0 ? d : b.wholeWord
  });
}
function LM(o) {
  let e = mO(o, RA);
  return e && e.dom.querySelector("[main-field]");
}
function VM(o) {
  let e = LM(o);
  e && e == o.root.activeElement && e.select();
}
const XM = (o) => {
  let e = o.state.field(Fc, !1);
  if (e && e.panel) {
    let n = LM(o);
    if (n && n != o.root.activeElement) {
      let l = Kx(o.state, e.query.spec);
      l.valid && o.dispatch({ effects: vO.of(l) }), n.focus(), n.select();
    }
  } else
    o.dispatch({ effects: [
      CA.of(!0),
      e ? vO.of(Kx(o.state, e.query.spec)) : it.appendConfig.of(MN)
    ] });
  return !0;
}, jM = (o) => {
  let e = o.state.field(Fc, !1);
  if (!e || !e.panel)
    return !1;
  let n = mO(o, RA);
  return n && n.dom.contains(o.root.activeElement) && o.focus(), o.dispatch({ effects: CA.of(!1) }), !0;
}, RN = [
  { key: "Mod-f", run: XM, scope: "editor search-panel" },
  { key: "F3", run: U1, shift: B1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: U1, shift: B1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: jM, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: EN },
  { key: "Mod-Alt-g", run: aN },
  { key: "Mod-d", run: yN, preventDefault: !0 }
];
class kN {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Fc).query.spec;
    this.commit = this.commit.bind(this), this.searchField = tn("input", {
      value: n.search,
      placeholder: Ea(e, "Find"),
      "aria-label": Ea(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = tn("input", {
      value: n.replace,
      placeholder: Ea(e, "Replace"),
      "aria-label": Ea(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = tn("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = tn("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = tn("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function l(s, c, d) {
      return tn("button", { class: "cm-button", name: s, onclick: c, type: "button" }, d);
    }
    this.dom = tn("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      l("next", () => U1(e), [Ea(e, "next")]),
      l("prev", () => B1(e), [Ea(e, "previous")]),
      l("select", () => wN(e), [Ea(e, "all")]),
      tn("label", null, [this.caseField, Ea(e, "match case")]),
      tn("label", null, [this.reField, Ea(e, "regexp")]),
      tn("label", null, [this.wordField, Ea(e, "by word")]),
      ...e.state.readOnly ? [] : [
        tn("br"),
        this.replaceField,
        l("replace", () => AR(e), [Ea(e, "replace")]),
        l("replaceAll", () => CN(e), [Ea(e, "replace all")])
      ],
      tn("button", {
        name: "close",
        onclick: () => jM(e),
        "aria-label": Ea(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new _M({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: vO.of(e) }));
  }
  keydown(e) {
    q4(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? B1 : U1)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), AR(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let l of n.effects)
        l.is(vO) && !l.value.eq(this.query) && this.setQuery(l.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet($m).top;
  }
}
function Ea(o, e) {
  return o.state.phrase(e);
}
const Wb = 30, Fb = /[\s\.,:;?!]/;
function kA(o, { from: e, to: n }) {
  let l = o.state.doc.lineAt(e), s = o.state.doc.lineAt(n).to, c = Math.max(l.from, e - Wb), d = Math.min(s, n + Wb), m = o.state.sliceDoc(c, d);
  if (c != l.from) {
    for (let y = 0; y < Wb; y++)
      if (!Fb.test(m[y + 1]) && Fb.test(m[y])) {
        m = m.slice(y);
        break;
      }
  }
  if (d != s) {
    for (let y = m.length - 1; y > m.length - Wb; y--)
      if (!Fb.test(m[y - 1]) && Fb.test(m[y])) {
        m = m.slice(0, y);
        break;
      }
  }
  return Me.announce.of(`${o.state.phrase("current match")}. ${m} ${o.state.phrase("on line")} ${l.number}.`);
}
const DN = /* @__PURE__ */ Me.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), MN = [
  Fc,
  /* @__PURE__ */ nf.low(AN),
  DN
];
class GM {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, n, l, s) {
    this.state = e, this.pos = n, this.explicit = l, this.view = s, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let n = bi(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), l = Math.max(n.from, this.pos - 250), s = n.text.slice(l - n.from, this.pos - n.from), c = s.search($M(e, !1));
    return c < 0 ? null : { from: l + c, to: this.pos, text: s.slice(c) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).

  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, n, l) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(n), l && l.onDocChange && (this.abortOnDocChange = !0));
  }
}
function wR(o) {
  let e = Object.keys(o).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function zN(o) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of o) {
    e[s[0]] = !0;
    for (let c = 1; c < s.length; c++)
      n[s[c]] = !0;
  }
  let l = wR(e) + wR(n) + "*$";
  return [new RegExp("^" + l), new RegExp(l)];
}
function YM(o) {
  let e = o.map((s) => typeof s == "string" ? { label: s } : s), [n, l] = e.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : zN(e);
  return (s) => {
    let c = s.matchBefore(l);
    return c || s.explicit ? { from: c ? c.from : s.pos, options: e, validFor: n } : null;
  };
}
function QN(o, e) {
  return (n) => {
    for (let l = bi(n.state).resolveInner(n.pos, -1); l; l = l.parent) {
      if (o.indexOf(l.name) > -1)
        return null;
      if (l.type.isTop)
        break;
    }
    return e(n);
  };
}
class ER {
  constructor(e, n, l, s) {
    this.completion = e, this.source = n, this.match = l, this.score = s;
  }
}
function Kh(o) {
  return o.selection.main.from;
}
function $M(o, e) {
  var n;
  let { source: l } = o, s = e && l[0] != "^", c = l[l.length - 1] != "$";
  return !s && !c ? o : new RegExp(`${s ? "^" : ""}(?:${l})${c ? "$" : ""}`, (n = o.flags) !== null && n !== void 0 ? n : o.ignoreCase ? "i" : "");
}
const DA = /* @__PURE__ */ or.define();
function NN(o, e, n, l) {
  let { main: s } = o.selection, c = n - s.from, d = l - s.from;
  return Object.assign(Object.assign({}, o.changeByRange((m) => {
    if (m != s && n != l && o.sliceDoc(m.from + c, m.from + d) != o.sliceDoc(n, l))
      return { range: m };
    let y = o.toText(e);
    return {
      changes: { from: m.from + c, to: l == s.from ? m.to : m.from + d, insert: y },
      range: ve.cursor(m.from + c + y.length)
    };
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const CR = /* @__PURE__ */ new WeakMap();
function UN(o) {
  if (!Array.isArray(o))
    return o;
  let e = CR.get(o);
  return e || CR.set(o, e = YM(o)), e;
}
const q1 = /* @__PURE__ */ it.define(), bO = /* @__PURE__ */ it.define();
class BN {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let l = Gl(e, n), s = Is(l);
      this.chars.push(l);
      let c = e.slice(n, n + s), d = c.toUpperCase();
      this.folded.push(Gl(d == c ? c.toLowerCase() : d, 0)), n += s;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: n, folded: l, any: s, precise: c, byWord: d } = this;
    if (n.length == 1) {
      let ie = Gl(e, 0), me = Is(ie), pe = me == e.length ? 0 : -100;
      if (ie != n[0]) if (ie == l[0])
        pe += -200;
      else
        return null;
      return this.ret(pe, [0, me]);
    }
    let m = e.indexOf(this.pattern);
    if (m == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let y = n.length, b = 0;
    if (m < 0) {
      for (let ie = 0, me = Math.min(e.length, 200); ie < me && b < y; ) {
        let pe = Gl(e, ie);
        (pe == n[b] || pe == l[b]) && (s[b++] = ie), ie += Is(pe);
      }
      if (b < y)
        return null;
    }
    let S = 0, A = 0, w = !1, E = 0, z = -1, U = -1, V = /[a-z]/.test(e), G = !0;
    for (let ie = 0, me = Math.min(e.length, 200), pe = 0; ie < me && A < y; ) {
      let ne = Gl(e, ie);
      m < 0 && (S < y && ne == n[S] && (c[S++] = ie), E < y && (ne == n[E] || ne == l[E] ? (E == 0 && (z = ie), U = ie + 1, E++) : E = 0));
      let ye, Oe = ne < 255 ? ne >= 48 && ne <= 57 || ne >= 97 && ne <= 122 ? 2 : ne >= 65 && ne <= 90 ? 1 : 0 : (ye = eA(ne)) != ye.toLowerCase() ? 1 : ye != ye.toUpperCase() ? 2 : 0;
      (!ie || Oe == 1 && V || pe == 0 && Oe != 0) && (n[A] == ne || l[A] == ne && (w = !0) ? d[A++] = ie : d.length && (G = !1)), pe = Oe, ie += Is(ne);
    }
    return A == y && d[0] == 0 && G ? this.result(-100 + (w ? -200 : 0), d, e) : E == y && z == 0 ? this.ret(-200 - e.length + (U == e.length ? 0 : -100), [0, U]) : m > -1 ? this.ret(-700 - e.length, [m, m + this.pattern.length]) : E == y ? this.ret(-900 - e.length, [z, U]) : A == y ? this.result(-100 + (w ? -200 : 0) + -700 + (G ? 0 : -1100), d, e) : n.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, e);
  }
  result(e, n, l) {
    let s = [], c = 0;
    for (let d of n) {
      let m = d + (this.astral ? Is(Gl(l, d)) : 1);
      c && s[c - 1] == d ? s[c - 1] = m : (s[c++] = d, s[c++] = m);
    }
    return this.ret(e - l.length, s);
  }
}
class qN {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let n = e.slice(0, this.pattern.length), l = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return l == null ? null : (this.matched = [0, n.length], this.score = l + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const vi = /* @__PURE__ */ Be.define({
  combine(o) {
    return sr(o, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: _N,
      filterStrict: !1,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (l) => RR(e(l), n(l)),
      optionClass: (e, n) => (l) => RR(e(l), n(l)),
      addToOptions: (e, n) => e.concat(n),
      filterStrict: (e, n) => e || n
    });
  }
});
function RR(o, e) {
  return o ? e ? o + " " + e : o : e;
}
function _N(o, e, n, l, s, c) {
  let d = o.textDirection == fn.RTL, m = d, y = !1, b = "top", S, A, w = e.left - s.left, E = s.right - e.right, z = l.right - l.left, U = l.bottom - l.top;
  if (m && w < Math.min(z, E) ? m = !1 : !m && E < Math.min(z, w) && (m = !0), z <= (m ? w : E))
    S = Math.max(s.top, Math.min(n.top, s.bottom - U)) - e.top, A = Math.min(400, m ? w : E);
  else {
    y = !0, A = Math.min(
      400,
      (d ? e.right : s.right - e.left) - 30
      /* Info.Margin */
    );
    let ie = s.bottom - e.bottom;
    ie >= U || ie > e.top ? S = n.bottom - e.top : (b = "bottom", S = e.bottom - n.top);
  }
  let V = (e.bottom - e.top) / c.offsetHeight, G = (e.right - e.left) / c.offsetWidth;
  return {
    style: `${b}: ${S / V}px; max-width: ${A / G}px`,
    class: "cm-completionInfo-" + (y ? d ? "left-narrow" : "right-narrow" : m ? "left" : "right")
  };
}
function HN(o) {
  let e = o.addToOptions.slice();
  return o.icons && e.push({
    render(n) {
      let l = document.createElement("div");
      return l.classList.add("cm-completionIcon"), n.type && l.classList.add(...n.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), l.setAttribute("aria-hidden", "true"), l;
    },
    position: 20
  }), e.push({
    render(n, l, s, c) {
      let d = document.createElement("span");
      d.className = "cm-completionLabel";
      let m = n.displayLabel || n.label, y = 0;
      for (let b = 0; b < c.length; ) {
        let S = c[b++], A = c[b++];
        S > y && d.appendChild(document.createTextNode(m.slice(y, S)));
        let w = d.appendChild(document.createElement("span"));
        w.appendChild(document.createTextNode(m.slice(S, A))), w.className = "cm-completionMatchedText", y = A;
      }
      return y < m.length && d.appendChild(document.createTextNode(m.slice(y))), d;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let l = document.createElement("span");
      return l.className = "cm-completionDetail", l.textContent = n.detail, l;
    },
    position: 80
  }), e.sort((n, l) => n.position - l.position).map((n) => n.render);
}
function ZT(o, e, n) {
  if (o <= n)
    return { from: 0, to: o };
  if (e < 0 && (e = 0), e <= o >> 1) {
    let s = Math.floor(e / n);
    return { from: s * n, to: (s + 1) * n };
  }
  let l = Math.floor((o - e) / n);
  return { from: o - (l + 1) * n, to: o - l * n };
}
class LN {
  constructor(e, n, l) {
    this.view = e, this.stateField = n, this.applyCompletion = l, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (y) => this.placeInfo(y),
      key: this
    }, this.space = null, this.currentClass = "";
    let s = e.state.field(n), { options: c, selected: d } = s.open, m = e.state.facet(vi);
    this.optionContent = HN(m), this.optionClass = m.optionClass, this.tooltipClass = m.tooltipClass, this.range = ZT(c.length, d, m.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (y) => {
      let { options: b } = e.state.field(n).open;
      for (let S = y.target, A; S && S != this.dom; S = S.parentNode)
        if (S.nodeName == "LI" && (A = /-(\d+)$/.exec(S.id)) && +A[1] < b.length) {
          this.applyCompletion(e, b[+A[1]]), y.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (y) => {
      let b = e.state.field(this.stateField, !1);
      b && b.tooltip && e.state.facet(vi).closeOnBlur && y.relatedTarget != e.contentDOM && e.dispatch({ effects: bO.of(null) });
    }), this.showOptions(c, s.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let l = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), l != s) {
      let { options: c, selected: d, disabled: m } = l.open;
      (!s.open || s.open.options != c) && (this.range = ZT(c.length, d, e.state.facet(vi).maxRenderedOptions), this.showOptions(c, l.id)), this.updateSel(), m != ((n = s.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!m);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let l of this.currentClass.split(" "))
        l && this.dom.classList.remove(l);
      for (let l of n.split(" "))
        l && this.dom.classList.add(l);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = ZT(n.options.length, n.selected, this.view.state.facet(vi).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: l } = n.options[n.selected], { info: s } = l;
      if (!s)
        return;
      let c = typeof s == "string" ? document.createTextNode(s) : s(l);
      if (!c)
        return;
      "then" in c ? c.then((d) => {
        d && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(d, l);
      }).catch((d) => Zl(this.view.state, d, "completion info")) : this.addInfoPane(c, l);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let l = this.info = document.createElement("div");
    if (l.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      l.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: s, destroy: c } = e;
      l.appendChild(s), this.infoDestroy = c || null;
    }
    this.dom.appendChild(l), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let l = this.list.firstChild, s = this.range.from; l; l = l.nextSibling, s++)
      l.nodeName != "LI" || !l.id ? s-- : s == e ? l.hasAttribute("aria-selected") || (l.setAttribute("aria-selected", "true"), n = l) : l.hasAttribute("aria-selected") && l.removeAttribute("aria-selected");
    return n && XN(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), l = this.info.getBoundingClientRect(), s = e.getBoundingClientRect(), c = this.space;
    if (!c) {
      let d = this.dom.ownerDocument.documentElement;
      c = { left: 0, top: 0, right: d.clientWidth, bottom: d.clientHeight };
    }
    return s.top > Math.min(c.bottom, n.bottom) - 10 || s.bottom < Math.max(c.top, n.top) + 10 ? null : this.view.state.facet(vi).positionInfo(this.view, n, s, l, c, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, l) {
    const s = document.createElement("ul");
    s.id = n, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true"), s.setAttribute("aria-label", this.view.state.phrase("Completions")), s.addEventListener("mousedown", (d) => {
      d.target == s && d.preventDefault();
    });
    let c = null;
    for (let d = l.from; d < l.to; d++) {
      let { completion: m, match: y } = e[d], { section: b } = m;
      if (b) {
        let w = typeof b == "string" ? b : b.name;
        if (w != c && (d > l.from || l.from == 0))
          if (c = w, typeof b != "string" && b.header)
            s.appendChild(b.header(b));
          else {
            let E = s.appendChild(document.createElement("completion-section"));
            E.textContent = w;
          }
      }
      const S = s.appendChild(document.createElement("li"));
      S.id = n + "-" + d, S.setAttribute("role", "option");
      let A = this.optionClass(m);
      A && (S.className = A);
      for (let w of this.optionContent) {
        let E = w(m, this.view.state, this.view, y);
        E && S.appendChild(E);
      }
    }
    return l.from && s.classList.add("cm-completionListIncompleteTop"), l.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function VN(o, e) {
  return (n) => new LN(n, o, e);
}
function XN(o, e) {
  let n = o.getBoundingClientRect(), l = e.getBoundingClientRect(), s = n.height / o.offsetHeight;
  l.top < n.top ? o.scrollTop -= (n.top - l.top) / s : l.bottom > n.bottom && (o.scrollTop += (l.bottom - n.bottom) / s);
}
function kR(o) {
  return (o.boost || 0) * 100 + (o.apply ? 10 : 0) + (o.info ? 5 : 0) + (o.type ? 1 : 0);
}
function jN(o, e) {
  let n = [], l = null, s = (b) => {
    n.push(b);
    let { section: S } = b.completion;
    if (S) {
      l || (l = []);
      let A = typeof S == "string" ? S : S.name;
      l.some((w) => w.name == A) || l.push(typeof S == "string" ? { name: A } : S);
    }
  }, c = e.facet(vi);
  for (let b of o)
    if (b.hasResult()) {
      let S = b.result.getMatch;
      if (b.result.filter === !1)
        for (let A of b.result.options)
          s(new ER(A, b.source, S ? S(A) : [], 1e9 - n.length));
      else {
        let A = e.sliceDoc(b.from, b.to), w, E = c.filterStrict ? new qN(A) : new BN(A);
        for (let z of b.result.options)
          if (w = E.match(z.label)) {
            let U = z.displayLabel ? S ? S(z, w.matched) : [] : w.matched;
            s(new ER(z, b.source, U, w.score + (z.boost || 0)));
          }
      }
    }
  if (l) {
    let b = /* @__PURE__ */ Object.create(null), S = 0, A = (w, E) => {
      var z, U;
      return ((z = w.rank) !== null && z !== void 0 ? z : 1e9) - ((U = E.rank) !== null && U !== void 0 ? U : 1e9) || (w.name < E.name ? -1 : 1);
    };
    for (let w of l.sort(A))
      S -= 1e5, b[w.name] = S;
    for (let w of n) {
      let { section: E } = w.completion;
      E && (w.score += b[typeof E == "string" ? E : E.name]);
    }
  }
  let d = [], m = null, y = c.compareCompletions;
  for (let b of n.sort((S, A) => A.score - S.score || y(S.completion, A.completion))) {
    let S = b.completion;
    !m || m.label != S.label || m.detail != S.detail || m.type != null && S.type != null && m.type != S.type || m.apply != S.apply || m.boost != S.boost ? d.push(b) : kR(b.completion) > kR(m) && (d[d.length - 1] = b), m = b.completion;
  }
  return d;
}
class Cm {
  constructor(e, n, l, s, c, d) {
    this.options = e, this.attrs = n, this.tooltip = l, this.timestamp = s, this.selected = c, this.disabled = d;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new Cm(this.options, DR(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, l, s, c, d) {
    if (s && !d && e.some((b) => b.isPending))
      return s.setDisabled();
    let m = jN(e, n);
    if (!m.length)
      return s && e.some((b) => b.isPending) ? s.setDisabled() : null;
    let y = n.facet(vi).selectOnOpen ? 0 : -1;
    if (s && s.selected != y && s.selected != -1) {
      let b = s.options[s.selected].completion;
      for (let S = 0; S < m.length; S++)
        if (m[S].completion == b) {
          y = S;
          break;
        }
    }
    return new Cm(m, DR(l, y), {
      pos: e.reduce((b, S) => S.hasResult() ? Math.min(b, S.from) : b, 1e8),
      create: WN,
      above: c.aboveCursor
    }, s ? s.timestamp : Date.now(), y, !1);
  }
  map(e) {
    return new Cm(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new Cm(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class _1 {
  constructor(e, n, l) {
    this.active = e, this.id = n, this.open = l;
  }
  static start() {
    return new _1(ZN, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, l = n.facet(vi), c = (l.override || n.languageDataAt("autocomplete", Kh(n)).map(UN)).map((y) => (this.active.find((S) => S.source == y) || new ro(
      y,
      this.active.some(
        (S) => S.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, l));
    c.length == this.active.length && c.every((y, b) => y == this.active[b]) && (c = this.active);
    let d = this.open, m = e.effects.some((y) => y.is(MA));
    d && e.docChanged && (d = d.map(e.changes)), e.selection || c.some((y) => y.hasResult() && e.changes.touchesRange(y.from, y.to)) || !GN(c, this.active) || m ? d = Cm.build(c, n, this.id, d, l, m) : d && d.disabled && !c.some((y) => y.isPending) && (d = null), !d && c.every((y) => !y.isPending) && c.some((y) => y.hasResult()) && (c = c.map((y) => y.hasResult() ? new ro(
      y.source,
      0
      /* State.Inactive */
    ) : y));
    for (let y of e.effects)
      y.is(PM) && (d = d && d.setSelected(y.value, this.id));
    return c == this.active && d == this.open ? this : new _1(c, this.id, d);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? YN : $N;
  }
}
function GN(o, e) {
  if (o == e)
    return !0;
  for (let n = 0, l = 0; ; ) {
    for (; n < o.length && !o[n].hasResult(); )
      n++;
    for (; l < e.length && !e[l].hasResult(); )
      l++;
    let s = n == o.length, c = l == e.length;
    if (s || c)
      return s == c;
    if (o[n++].result != e[l++].result)
      return !1;
  }
}
const YN = {
  "aria-autocomplete": "list"
}, $N = {};
function DR(o, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": o
  };
  return e > -1 && (n["aria-activedescendant"] = o + "-" + e), n;
}
const ZN = [];
function ZM(o, e) {
  if (o.isUserEvent("input.complete")) {
    let l = o.annotation(DA);
    if (l && e.activateOnCompletion(l))
      return 12;
  }
  let n = o.isUserEvent("input.type");
  return n && e.activateOnTyping ? 5 : n ? 1 : o.isUserEvent("delete.backward") ? 2 : o.selection ? 8 : o.docChanged ? 16 : 0;
}
class ro {
  constructor(e, n, l = !1) {
    this.source = e, this.state = n, this.explicit = l;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, n) {
    let l = ZM(e, n), s = this;
    (l & 8 || l & 16 && this.touches(e)) && (s = new ro(
      s.source,
      0
      /* State.Inactive */
    )), l & 4 && s.state == 0 && (s = new ro(
      this.source,
      1
      /* State.Pending */
    )), s = s.updateFor(e, l);
    for (let c of e.effects)
      if (c.is(q1))
        s = new ro(s.source, 1, c.value);
      else if (c.is(bO))
        s = new ro(
          s.source,
          0
          /* State.Inactive */
        );
      else if (c.is(MA))
        for (let d of c.value)
          d.source == s.source && (s = d);
    return s;
  }
  updateFor(e, n) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(Kh(e.state));
  }
}
class zm extends ro {
  constructor(e, n, l, s, c, d) {
    super(e, 3, n), this.limit = l, this.result = s, this.from = c, this.to = d;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, n) {
    var l;
    if (!(n & 3))
      return this.map(e.changes);
    let s = this.result;
    s.map && !e.changes.empty && (s = s.map(s, e.changes));
    let c = e.changes.mapPos(this.from), d = e.changes.mapPos(this.to, 1), m = Kh(e.state);
    if (m > d || !s || n & 2 && (Kh(e.startState) == this.from || m < this.limit))
      return new ro(
        this.source,
        n & 4 ? 1 : 0
        /* State.Inactive */
      );
    let y = e.changes.mapPos(this.limit);
    return PN(s.validFor, e.state, c, d) ? new zm(this.source, this.explicit, y, s, c, d) : s.update && (s = s.update(s, c, d, new GM(e.state, m, !1))) ? new zm(this.source, this.explicit, y, s, s.from, (l = s.to) !== null && l !== void 0 ? l : Kh(e.state)) : new ro(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new zm(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new ro(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function PN(o, e, n, l) {
  if (!o)
    return !1;
  let s = e.sliceDoc(n, l);
  return typeof o == "function" ? o(s, n, l, e) : $M(o, !0).test(s);
}
const MA = /* @__PURE__ */ it.define({
  map(o, e) {
    return o.map((n) => n.map(e));
  }
}), PM = /* @__PURE__ */ it.define(), $l = /* @__PURE__ */ Si.define({
  create() {
    return _1.start();
  },
  update(o, e) {
    return o.update(e);
  },
  provide: (o) => [
    mA.from(o, (e) => e.tooltip),
    Me.contentAttributes.from(o, (e) => e.attrs)
  ]
});
function zA(o, e) {
  const n = e.completion.apply || e.completion.label;
  let l = o.state.field($l).active.find((s) => s.source == e.source);
  return l instanceof zm ? (typeof n == "string" ? o.dispatch(Object.assign(Object.assign({}, NN(o.state, n, l.from, l.to)), { annotations: DA.of(e.completion) })) : n(o, e.completion, l.from, l.to), !0) : !1;
}
const WN = /* @__PURE__ */ VN($l, zA);
function Kb(o, e = "option") {
  return (n) => {
    let l = n.state.field($l, !1);
    if (!l || !l.open || l.open.disabled || Date.now() - l.open.timestamp < n.state.facet(vi).interactionDelay)
      return !1;
    let s = 1, c;
    e == "page" && (c = RD(n, l.open.tooltip)) && (s = Math.max(2, Math.floor(c.dom.offsetHeight / c.dom.querySelector("li").offsetHeight) - 1));
    let { length: d } = l.open.options, m = l.open.selected > -1 ? l.open.selected + s * (o ? 1 : -1) : o ? 0 : d - 1;
    return m < 0 ? m = e == "page" ? 0 : d - 1 : m >= d && (m = e == "page" ? d - 1 : 0), n.dispatch({ effects: PM.of(m) }), !0;
  };
}
const FN = (o) => {
  let e = o.state.field($l, !1);
  return o.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < o.state.facet(vi).interactionDelay ? !1 : zA(o, e.open.options[e.open.selected]);
}, MR = (o) => o.state.field($l, !1) ? (o.dispatch({ effects: q1.of(!0) }), !0) : !1, KN = (o) => {
  let e = o.state.field($l, !1);
  return !e || !e.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (o.dispatch({ effects: bO.of(null) }), !0);
};
class JN {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const IN = 50, eU = 1e3, tU = /* @__PURE__ */ Bn.fromClass(class {
  constructor(o) {
    this.view = o, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of o.state.field($l).active)
      e.isPending && this.startQuery(e);
  }
  update(o) {
    let e = o.state.field($l), n = o.state.facet(vi);
    if (!o.selectionSet && !o.docChanged && o.startState.field($l) == e)
      return;
    let l = o.transactions.some((c) => {
      let d = ZM(c, n);
      return d & 8 || (c.selection || c.docChanged) && !(d & 3);
    });
    for (let c = 0; c < this.running.length; c++) {
      let d = this.running[c];
      if (l || d.context.abortOnDocChange && o.docChanged || d.updates.length + o.transactions.length > IN && Date.now() - d.time > eU) {
        for (let m of d.context.abortListeners)
          try {
            m();
          } catch (y) {
            Zl(this.view.state, y);
          }
        d.context.abortListeners = null, this.running.splice(c--, 1);
      } else
        d.updates.push(...o.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), o.transactions.some((c) => c.effects.some((d) => d.is(q1))) && (this.pendingStart = !0);
    let s = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((c) => c.isPending && !this.running.some((d) => d.active.source == c.source)) ? setTimeout(() => this.startUpdate(), s) : -1, this.composing != 0)
      for (let c of o.transactions)
        c.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && c.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: o } = this.view, e = o.field($l);
    for (let n of e.active)
      n.isPending && !this.running.some((l) => l.active.source == n.source) && this.startQuery(n);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vi).updateSyncTime));
  }
  startQuery(o) {
    let { state: e } = this.view, n = Kh(e), l = new GM(e, n, o.explicit, this.view), s = new JN(o, l);
    this.running.push(s), Promise.resolve(o.source(l)).then((c) => {
      s.context.aborted || (s.done = c || null, this.scheduleAccept());
    }, (c) => {
      this.view.dispatch({ effects: bO.of(null) }), Zl(this.view.state, c);
    });
  }
  scheduleAccept() {
    this.running.every((o) => o.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vi).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var o;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(vi), l = this.view.state.field($l);
    for (let s = 0; s < this.running.length; s++) {
      let c = this.running[s];
      if (c.done === void 0)
        continue;
      if (this.running.splice(s--, 1), c.done) {
        let m = Kh(c.updates.length ? c.updates[0].startState : this.view.state), y = Math.min(m, c.done.from + (c.active.explicit ? 0 : 1)), b = new zm(c.active.source, c.active.explicit, y, c.done, c.done.from, (o = c.done.to) !== null && o !== void 0 ? o : m);
        for (let S of c.updates)
          b = b.update(S, n);
        if (b.hasResult()) {
          e.push(b);
          continue;
        }
      }
      let d = l.active.find((m) => m.source == c.active.source);
      if (d && d.isPending)
        if (c.done == null) {
          let m = new ro(
            c.active.source,
            0
            /* State.Inactive */
          );
          for (let y of c.updates)
            m = m.update(y, n);
          m.isPending || e.push(m);
        } else
          this.startQuery(d);
    }
    (e.length || l.open && l.open.disabled) && this.view.dispatch({ effects: MA.of(e) });
  }
}, {
  eventHandlers: {
    blur(o) {
      let e = this.view.state.field($l, !1);
      if (e && e.tooltip && this.view.state.facet(vi).closeOnBlur) {
        let n = e.open && RD(this.view, e.open.tooltip);
        (!n || !n.dom.contains(o.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: bO.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: q1.of(!1) }), 20), this.composing = 0;
    }
  }
}), nU = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), iU = /* @__PURE__ */ nf.highest(/* @__PURE__ */ Me.domEventHandlers({
  keydown(o, e) {
    let n = e.state.field($l, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || o.key.length > 1 || o.ctrlKey && !(nU && o.altKey) || o.metaKey)
      return !1;
    let l = n.open.options[n.open.selected], s = n.active.find((d) => d.source == l.source), c = l.completion.commitCharacters || s.result.commitCharacters;
    return c && c.indexOf(o.key) > -1 && zA(e, l), !1;
  }
})), WM = /* @__PURE__ */ Me.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class lU {
  constructor(e, n, l, s) {
    this.field = e, this.line = n, this.from = l, this.to = s;
  }
}
class QA {
  constructor(e, n, l) {
    this.field = e, this.from = n, this.to = l;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, Qi.TrackDel), l = e.mapPos(this.to, 1, Qi.TrackDel);
    return n == null || l == null ? null : new QA(this.field, n, l);
  }
}
class NA {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let l = [], s = [n], c = e.doc.lineAt(n), d = /^\s*/.exec(c.text)[0];
    for (let y of this.lines) {
      if (l.length) {
        let b = d, S = /^\t*/.exec(y)[0].length;
        for (let A = 0; A < S; A++)
          b += e.facet(MO);
        s.push(n + b.length - S), y = b + y.slice(S);
      }
      l.push(y), n += y.length + 1;
    }
    let m = this.fieldPositions.map((y) => new QA(y.field, s[y.line] + y.from, s[y.line] + y.to));
    return { text: l, ranges: m };
  }
  static parse(e) {
    let n = [], l = [], s = [], c;
    for (let d of e.split(/\r\n?|\n/)) {
      for (; c = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(d); ) {
        let m = c[1] ? +c[1] : null, y = c[2] || c[3] || "", b = -1, S = y.replace(/\\[{}]/g, (A) => A[1]);
        for (let A = 0; A < n.length; A++)
          (m != null ? n[A].seq == m : S && n[A].name == S) && (b = A);
        if (b < 0) {
          let A = 0;
          for (; A < n.length && (m == null || n[A].seq != null && n[A].seq < m); )
            A++;
          n.splice(A, 0, { seq: m, name: S }), b = A;
          for (let w of s)
            w.field >= b && w.field++;
        }
        s.push(new lU(b, l.length, c.index, c.index + S.length)), d = d.slice(0, c.index) + y + d.slice(c.index + c[0].length);
      }
      d = d.replace(/\\([{}])/g, (m, y, b) => {
        for (let S of s)
          S.line == l.length && S.from > b && (S.from--, S.to--);
        return y;
      }), l.push(d);
    }
    return new NA(l, s);
  }
}
let aU = /* @__PURE__ */ Ze.widget({ widget: /* @__PURE__ */ new class extends rr {
  toDOM() {
    let o = document.createElement("span");
    return o.className = "cm-snippetFieldPosition", o;
  }
  ignoreEvent() {
    return !1;
  }
}() }), oU = /* @__PURE__ */ Ze.mark({ class: "cm-snippetField" });
class Zm {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = Ze.set(e.map((l) => (l.from == l.to ? aU : oU).range(l.from, l.to)));
  }
  map(e) {
    let n = [];
    for (let l of this.ranges) {
      let s = l.map(e);
      if (!s)
        return null;
      n.push(s);
    }
    return new Zm(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((l) => l.field == this.active && l.from <= n.from && l.to >= n.to));
  }
}
const UO = /* @__PURE__ */ it.define({
  map(o, e) {
    return o && o.map(e);
  }
}), sU = /* @__PURE__ */ it.define(), SO = /* @__PURE__ */ Si.define({
  create() {
    return null;
  },
  update(o, e) {
    for (let n of e.effects) {
      if (n.is(UO))
        return n.value;
      if (n.is(sU) && o)
        return new Zm(o.ranges, n.value);
    }
    return o && e.docChanged && (o = o.map(e.changes)), o && e.selection && !o.selectionInsideField(e.selection) && (o = null), o;
  },
  provide: (o) => Me.decorations.from(o, (e) => e ? e.deco : Ze.none)
});
function UA(o, e) {
  return ve.create(o.filter((n) => n.field == e).map((n) => ve.range(n.from, n.to)));
}
function rU(o) {
  let e = NA.parse(o);
  return (n, l, s, c) => {
    let { text: d, ranges: m } = e.instantiate(n.state, s), { main: y } = n.state.selection, b = {
      changes: { from: s, to: c == y.from ? y.to : c, insert: kt.of(d) },
      scrollIntoView: !0,
      annotations: l ? [DA.of(l), Pn.userEvent.of("input.complete")] : void 0
    };
    if (m.length && (b.selection = UA(m, 0)), m.some((S) => S.field > 0)) {
      let S = new Zm(m, 0), A = b.effects = [UO.of(S)];
      n.state.field(SO, !1) === void 0 && A.push(it.appendConfig.of([SO, dU, pU, WM]));
    }
    n.dispatch(n.state.update(b));
  };
}
function FM(o) {
  return ({ state: e, dispatch: n }) => {
    let l = e.field(SO, !1);
    if (!l || o < 0 && l.active == 0)
      return !1;
    let s = l.active + o, c = o > 0 && !l.ranges.some((d) => d.field == s + o);
    return n(e.update({
      selection: UA(l.ranges, s),
      effects: UO.of(c ? null : new Zm(l.ranges, s)),
      scrollIntoView: !0
    })), !0;
  };
}
const uU = ({ state: o, dispatch: e }) => o.field(SO, !1) ? (e(o.update({ effects: UO.of(null) })), !0) : !1, cU = /* @__PURE__ */ FM(1), fU = /* @__PURE__ */ FM(-1), hU = [
  { key: "Tab", run: cU, shift: fU },
  { key: "Escape", run: uU }
], zR = /* @__PURE__ */ Be.define({
  combine(o) {
    return o.length ? o[0] : hU;
  }
}), dU = /* @__PURE__ */ nf.highest(/* @__PURE__ */ kO.compute([zR], (o) => o.facet(zR)));
function uu(o, e) {
  return Object.assign(Object.assign({}, e), { apply: rU(o) });
}
const pU = /* @__PURE__ */ Me.domEventHandlers({
  mousedown(o, e) {
    let n = e.state.field(SO, !1), l;
    if (!n || (l = e.posAtCoords({ x: o.clientX, y: o.clientY })) == null)
      return !1;
    let s = n.ranges.find((c) => c.from <= l && c.to >= l);
    return !s || s.field == n.active ? !1 : (e.dispatch({
      selection: UA(n.ranges, s.field),
      effects: UO.of(n.ranges.some((c) => c.field > s.field) ? new Zm(n.ranges, s.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), TO = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Wh = /* @__PURE__ */ it.define({
  map(o, e) {
    let n = e.mapPos(o, -1, Qi.TrackAfter);
    return n ?? void 0;
  }
}), BA = /* @__PURE__ */ new class extends Jh {
}();
BA.startSide = 1;
BA.endSide = -1;
const KM = /* @__PURE__ */ Si.define({
  create() {
    return Qt.empty;
  },
  update(o, e) {
    if (o = o.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      o = o.update({ filter: (l) => l >= n.from && l <= n.to });
    }
    for (let n of e.effects)
      n.is(Wh) && (o = o.update({ add: [BA.range(n.value, n.value + 1)] }));
    return o;
  }
});
function mU() {
  return [yU, KM];
}
const PT = "()[]{}<>";
function JM(o) {
  for (let e = 0; e < PT.length; e += 2)
    if (PT.charCodeAt(e) == o)
      return PT.charAt(e + 1);
  return eA(o < 128 ? o : o + 1);
}
function IM(o, e) {
  return o.languageDataAt("closeBrackets", e)[0] || TO;
}
const gU = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), yU = /* @__PURE__ */ Me.inputHandler.of((o, e, n, l) => {
  if ((gU ? o.composing : o.compositionStarted) || o.state.readOnly)
    return !1;
  let s = o.state.selection.main;
  if (l.length > 2 || l.length == 2 && Is(Gl(l, 0)) == 1 || e != s.from || n != s.to)
    return !1;
  let c = bU(o.state, l);
  return c ? (o.dispatch(c), !0) : !1;
}), OU = ({ state: o, dispatch: e }) => {
  if (o.readOnly)
    return !1;
  let l = IM(o, o.selection.main.head).brackets || TO.brackets, s = null, c = o.changeByRange((d) => {
    if (d.empty) {
      let m = SU(o.doc, d.head);
      for (let y of l)
        if (y == m && J1(o.doc, d.head) == JM(Gl(y, 0)))
          return {
            changes: { from: d.head - y.length, to: d.head + y.length },
            range: ve.cursor(d.head - y.length)
          };
    }
    return { range: s = d };
  });
  return s || e(o.update(c, { scrollIntoView: !0, userEvent: "delete.backward" })), !s;
}, vU = [
  { key: "Backspace", run: OU }
];
function bU(o, e) {
  let n = IM(o, o.selection.main.head), l = n.brackets || TO.brackets;
  for (let s of l) {
    let c = JM(Gl(s, 0));
    if (e == s)
      return c == s ? AU(o, s, l.indexOf(s + s + s) > -1, n) : TU(o, s, c, n.before || TO.before);
    if (e == c && ez(o, o.selection.main.from))
      return xU(o, s, c);
  }
  return null;
}
function ez(o, e) {
  let n = !1;
  return o.field(KM).between(0, o.doc.length, (l) => {
    l == e && (n = !0);
  }), n;
}
function J1(o, e) {
  let n = o.sliceString(e, e + 2);
  return n.slice(0, Is(Gl(n, 0)));
}
function SU(o, e) {
  let n = o.sliceString(e - 2, e);
  return Is(Gl(n, 0)) == n.length ? n : n.slice(1);
}
function TU(o, e, n, l) {
  let s = null, c = o.changeByRange((d) => {
    if (!d.empty)
      return {
        changes: [{ insert: e, from: d.from }, { insert: n, from: d.to }],
        effects: Wh.of(d.to + e.length),
        range: ve.range(d.anchor + e.length, d.head + e.length)
      };
    let m = J1(o.doc, d.head);
    return !m || /\s/.test(m) || l.indexOf(m) > -1 ? {
      changes: { insert: e + n, from: d.head },
      effects: Wh.of(d.head + e.length),
      range: ve.cursor(d.head + e.length)
    } : { range: s = d };
  });
  return s ? null : o.update(c, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function xU(o, e, n) {
  let l = null, s = o.changeByRange((c) => c.empty && J1(o.doc, c.head) == n ? {
    changes: { from: c.head, to: c.head + n.length, insert: n },
    range: ve.cursor(c.head + n.length)
  } : l = { range: c });
  return l ? null : o.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function AU(o, e, n, l) {
  let s = l.stringPrefixes || TO.stringPrefixes, c = null, d = o.changeByRange((m) => {
    if (!m.empty)
      return {
        changes: [{ insert: e, from: m.from }, { insert: e, from: m.to }],
        effects: Wh.of(m.to + e.length),
        range: ve.range(m.anchor + e.length, m.head + e.length)
      };
    let y = m.head, b = J1(o.doc, y), S;
    if (b == e) {
      if (QR(o, y))
        return {
          changes: { insert: e + e, from: y },
          effects: Wh.of(y + e.length),
          range: ve.cursor(y + e.length)
        };
      if (ez(o, y)) {
        let w = n && o.sliceDoc(y, y + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: y, to: y + w.length, insert: w },
          range: ve.cursor(y + w.length)
        };
      }
    } else {
      if (n && o.sliceDoc(y - 2 * e.length, y) == e + e && (S = NR(o, y - 2 * e.length, s)) > -1 && QR(o, S))
        return {
          changes: { insert: e + e + e + e, from: y },
          effects: Wh.of(y + e.length),
          range: ve.cursor(y + e.length)
        };
      if (o.charCategorizer(y)(b) != yn.Word && NR(o, y, s) > -1 && !wU(o, y, e, s))
        return {
          changes: { insert: e + e, from: y },
          effects: Wh.of(y + e.length),
          range: ve.cursor(y + e.length)
        };
    }
    return { range: c = m };
  });
  return c ? null : o.update(d, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function QR(o, e) {
  let n = bi(o).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function wU(o, e, n, l) {
  let s = bi(o).resolveInner(e, -1), c = l.reduce((d, m) => Math.max(d, m.length), 0);
  for (let d = 0; d < 5; d++) {
    let m = o.sliceDoc(s.from, Math.min(s.to, s.from + n.length + c)), y = m.indexOf(n);
    if (!y || y > -1 && l.indexOf(m.slice(0, y)) > -1) {
      let S = s.firstChild;
      for (; S && S.from == s.from && S.to - S.from > n.length + y; ) {
        if (o.sliceDoc(S.to - n.length, S.to) == n)
          return !1;
        S = S.firstChild;
      }
      return !0;
    }
    let b = s.to == e && s.parent;
    if (!b)
      break;
    s = b;
  }
  return !1;
}
function NR(o, e, n) {
  let l = o.charCategorizer(e);
  if (l(o.sliceDoc(e - 1, e)) != yn.Word)
    return e;
  for (let s of n) {
    let c = e - s.length;
    if (o.sliceDoc(c, e) == s && l(o.sliceDoc(c - 1, c)) != yn.Word)
      return c;
  }
  return -1;
}
function EU(o = {}) {
  return [
    iU,
    $l,
    vi.of(o),
    tU,
    CU,
    WM
  ];
}
const tz = [
  { key: "Ctrl-Space", run: MR },
  { mac: "Alt-`", run: MR },
  { key: "Escape", run: KN },
  { key: "ArrowDown", run: /* @__PURE__ */ Kb(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Kb(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Kb(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Kb(!1, "page") },
  { key: "Enter", run: FN }
], CU = /* @__PURE__ */ nf.highest(/* @__PURE__ */ kO.computeN([vi], (o) => o.facet(vi).defaultKeymap ? [tz] : []));
class UR {
  constructor(e, n, l) {
    this.from = e, this.to = n, this.diagnostic = l;
  }
}
class Zh {
  constructor(e, n, l) {
    this.diagnostics = e, this.panel = n, this.selected = l;
  }
  static init(e, n, l) {
    let s = l.facet(xO).markerFilter;
    s && (e = s(e, l));
    let c = e.slice().sort((S, A) => S.from - A.from || S.to - A.to), d = new yu(), m = [], y = 0;
    for (let S = 0; ; ) {
      let A = S == c.length ? null : c[S];
      if (!A && !m.length)
        break;
      let w, E;
      for (m.length ? (w = y, E = m.reduce((U, V) => Math.min(U, V.to), A && A.from > w ? A.from : 1e8)) : (w = A.from, E = A.to, m.push(A), S++); S < c.length; ) {
        let U = c[S];
        if (U.from == w && (U.to > U.from || U.to == w))
          m.push(U), S++, E = Math.min(U.to, E);
        else {
          E = Math.min(U.from, E);
          break;
        }
      }
      let z = LU(m);
      if (m.some((U) => U.from == U.to || U.from == U.to - 1 && l.doc.lineAt(U.from).to == U.from))
        d.add(w, w, Ze.widget({
          widget: new BU(z),
          diagnostics: m.slice()
        }));
      else {
        let U = m.reduce((V, G) => G.markClass ? V + " " + G.markClass : V, "");
        d.add(w, E, Ze.mark({
          class: "cm-lintRange cm-lintRange-" + z + U,
          diagnostics: m.slice(),
          inclusiveEnd: m.some((V) => V.to > E)
        }));
      }
      y = E;
      for (let U = 0; U < m.length; U++)
        m[U].to <= y && m.splice(U--, 1);
    }
    let b = d.finish();
    return new Zh(b, n, Vm(b));
  }
}
function Vm(o, e = null, n = 0) {
  let l = null;
  return o.between(n, 1e9, (s, c, { spec: d }) => {
    if (!(e && d.diagnostics.indexOf(e) < 0))
      if (!l)
        l = new UR(s, c, e || d.diagnostics[0]);
      else {
        if (d.diagnostics.indexOf(l.diagnostic) < 0)
          return !1;
        l = new UR(l.from, c, l.diagnostic);
      }
  }), l;
}
function RU(o, e) {
  let n = e.pos, l = e.end || n, s = o.state.facet(xO).hideOn(o, n, l);
  if (s != null)
    return s;
  let c = o.startState.doc.lineAt(e.pos);
  return !!(o.effects.some((d) => d.is(nz)) || o.changes.touchesRange(c.from, Math.max(c.to, l)));
}
function kU(o, e) {
  return o.field(ka, !1) ? e : e.concat(it.appendConfig.of(VU));
}
const nz = /* @__PURE__ */ it.define(), qA = /* @__PURE__ */ it.define(), iz = /* @__PURE__ */ it.define(), ka = /* @__PURE__ */ Si.define({
  create() {
    return new Zh(Ze.none, null, null);
  },
  update(o, e) {
    if (e.docChanged && o.diagnostics.size) {
      let n = o.diagnostics.map(e.changes), l = null, s = o.panel;
      if (o.selected) {
        let c = e.changes.mapPos(o.selected.from, 1);
        l = Vm(n, o.selected.diagnostic, c) || Vm(n, null, c);
      }
      !n.size && s && e.state.facet(xO).autoPanel && (s = null), o = new Zh(n, s, l);
    }
    for (let n of e.effects)
      if (n.is(nz)) {
        let l = e.state.facet(xO).autoPanel ? n.value.length ? AO.open : null : o.panel;
        o = Zh.init(n.value, l, e.state);
      } else n.is(qA) ? o = new Zh(o.diagnostics, n.value ? AO.open : null, o.selected) : n.is(iz) && (o = new Zh(o.diagnostics, o.panel, n.value));
    return o;
  },
  provide: (o) => [
    gO.from(o, (e) => e.panel),
    Me.decorations.from(o, (e) => e.diagnostics)
  ]
}), DU = /* @__PURE__ */ Ze.mark({ class: "cm-lintRange cm-lintRange-active" });
function MU(o, e, n) {
  let { diagnostics: l } = o.state.field(ka), s, c = -1, d = -1;
  l.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (y, b, { spec: S }) => {
    if (e >= y && e <= b && (y == b || (e > y || n > 0) && (e < b || n < 0)))
      return s = S.diagnostics, c = y, d = b, !1;
  });
  let m = o.state.facet(xO).tooltipFilter;
  return s && m && (s = m(s, o.state)), s ? {
    pos: c,
    end: d,
    above: o.state.doc.lineAt(c).to < d,
    create() {
      return { dom: zU(o, s) };
    }
  } : null;
}
function zU(o, e) {
  return tn("ul", { class: "cm-tooltip-lint" }, e.map((n) => az(o, n, !1)));
}
const QU = (o) => {
  let e = o.state.field(ka, !1);
  (!e || !e.panel) && o.dispatch({ effects: kU(o.state, [qA.of(!0)]) });
  let n = mO(o, AO.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, BR = (o) => {
  let e = o.state.field(ka, !1);
  return !e || !e.panel ? !1 : (o.dispatch({ effects: qA.of(!1) }), !0);
}, NU = (o) => {
  let e = o.state.field(ka, !1);
  if (!e)
    return !1;
  let n = o.state.selection.main, l = e.diagnostics.iter(n.to + 1);
  return !l.value && (l = e.diagnostics.iter(0), !l.value || l.from == n.from && l.to == n.to) ? !1 : (o.dispatch({ selection: { anchor: l.from, head: l.to }, scrollIntoView: !0 }), !0);
}, UU = [
  { key: "Mod-Shift-m", run: QU, preventDefault: !0 },
  { key: "F8", run: NU }
], xO = /* @__PURE__ */ Be.define({
  combine(o) {
    return Object.assign({ sources: o.map((e) => e.source).filter((e) => e != null) }, sr(o.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, n) => e ? n ? (l) => e(l) || n(l) : e : n
    }));
  }
});
function lz(o) {
  let e = [];
  if (o)
    e: for (let { name: n } of o) {
      for (let l = 0; l < n.length; l++) {
        let s = n[l];
        if (/[a-zA-Z]/.test(s) && !e.some((c) => c.toLowerCase() == s.toLowerCase())) {
          e.push(s);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function az(o, e, n) {
  var l;
  let s = n ? lz(e.actions) : [];
  return tn("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, tn("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(o) : e.message), (l = e.actions) === null || l === void 0 ? void 0 : l.map((c, d) => {
    let m = !1, y = (w) => {
      if (w.preventDefault(), m)
        return;
      m = !0;
      let E = Vm(o.state.field(ka).diagnostics, e);
      E && c.apply(o, E.from, E.to);
    }, { name: b } = c, S = s[d] ? b.indexOf(s[d]) : -1, A = S < 0 ? b : [
      b.slice(0, S),
      tn("u", b.slice(S, S + 1)),
      b.slice(S + 1)
    ];
    return tn("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: y,
      onmousedown: y,
      "aria-label": ` Action: ${b}${S < 0 ? "" : ` (access key "${s[d]})"`}.`
    }, A);
  }), e.source && tn("div", { class: "cm-diagnosticSource" }, e.source));
}
class BU extends rr {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return tn("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class qR {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = az(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class AO {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (s) => {
      if (s.keyCode == 27)
        BR(this.view), this.view.focus();
      else if (s.keyCode == 38 || s.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (s.keyCode == 40 || s.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (s.keyCode == 36)
        this.moveSelection(0);
      else if (s.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (s.keyCode == 13)
        this.view.focus();
      else if (s.keyCode >= 65 && s.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: c } = this.items[this.selectedIndex], d = lz(c.actions);
        for (let m = 0; m < d.length; m++)
          if (d[m].toUpperCase().charCodeAt(0) == s.keyCode) {
            let y = Vm(this.view.state.field(ka).diagnostics, c);
            y && c.actions[m].apply(e, y.from, y.to);
          }
      } else
        return;
      s.preventDefault();
    }, l = (s) => {
      for (let c = 0; c < this.items.length; c++)
        this.items[c].dom.contains(s.target) && this.moveSelection(c);
    };
    this.list = tn("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: l
    }), this.dom = tn("div", { class: "cm-panel-lint" }, this.list, tn("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => BR(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(ka).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(ka), l = 0, s = !1, c = null, d = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (m, y, { spec: b }) => {
      for (let S of b.diagnostics) {
        if (d.has(S))
          continue;
        d.add(S);
        let A = -1, w;
        for (let E = l; E < this.items.length; E++)
          if (this.items[E].diagnostic == S) {
            A = E;
            break;
          }
        A < 0 ? (w = new qR(this.view, S), this.items.splice(l, 0, w), s = !0) : (w = this.items[A], A > l && (this.items.splice(l, A - l), s = !0)), n && w.diagnostic == n.diagnostic ? w.dom.hasAttribute("aria-selected") || (w.dom.setAttribute("aria-selected", "true"), c = w) : w.dom.hasAttribute("aria-selected") && w.dom.removeAttribute("aria-selected"), l++;
      }
    }); l < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      s = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new qR(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), s = !0), c ? (this.list.setAttribute("aria-activedescendant", c.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: c.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: m, panel: y }) => {
        let b = y.height / this.list.offsetHeight;
        m.top < y.top ? this.list.scrollTop -= (y.top - m.top) / b : m.bottom > y.bottom && (this.list.scrollTop += (m.bottom - y.bottom) / b);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let l = e;
      e = l.nextSibling, l.remove();
    }
    for (let l of this.items)
      if (l.dom.parentNode == this.list) {
        for (; e != l.dom; )
          n();
        e = l.dom.nextSibling;
      } else
        this.list.insertBefore(l.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(ka), l = Vm(n.diagnostics, this.items[e].diagnostic);
    l && this.view.dispatch({
      selection: { anchor: l.from, head: l.to },
      scrollIntoView: !0,
      effects: iz.of(l)
    });
  }
  static open(e) {
    return new AO(e);
  }
}
function qU(o, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(o)}</svg>')`;
}
function Jb(o) {
  return qU(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${o}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const _U = /* @__PURE__ */ Me.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Jb("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Jb("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Jb("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Jb("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function HU(o) {
  return o == "error" ? 4 : o == "warning" ? 3 : o == "info" ? 2 : 1;
}
function LU(o) {
  let e = "hint", n = 1;
  for (let l of o) {
    let s = HU(l.severity);
    s > n && (n = s, e = l.severity);
  }
  return e;
}
const VU = [
  ka,
  /* @__PURE__ */ Me.decorations.compute([ka], (o) => {
    let { selected: e, panel: n } = o.field(ka);
    return !e || !n || e.from == e.to ? Ze.none : Ze.set([
      DU.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ w5(MU, { hideOn: RU }),
  _U
];
var _R = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: n = !1
  } = e, l = [];
  e.closeBracketsKeymap !== !1 && (l = l.concat(vU)), e.defaultKeymap !== !1 && (l = l.concat(nN)), e.searchKeymap !== !1 && (l = l.concat(RN)), e.historyKeymap !== !1 && (l = l.concat(f8)), e.foldKeymap !== !1 && (l = l.concat(w6)), e.completionKeymap !== !1 && (l = l.concat(tz)), e.lintKeymap !== !1 && (l = l.concat(UU));
  var s = [];
  return e.lineNumbers !== !1 && s.push(B5()), e.highlightActiveLineGutter !== !1 && s.push(H5()), e.highlightSpecialChars !== !1 && s.push(e5()), e.history !== !1 && s.push(n8()), e.foldGutter !== !1 && s.push(k6()), e.drawSelection !== !1 && s.push(j4()), e.dropCursor !== !1 && s.push(P4()), e.allowMultipleSelections !== !1 && s.push(At.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && s.push(m6()), e.syntaxHighlighting !== !1 && s.push(TA(Q6, {
    fallback: !0
  })), e.bracketMatching !== !1 && s.push(L6()), e.closeBrackets !== !1 && s.push(mU()), e.autocompletion !== !1 && s.push(EU()), e.rectangularSelection !== !1 && s.push(p5()), n !== !1 && s.push(y5()), e.highlightActiveLine !== !1 && s.push(o5()), e.highlightSelectionMatches !== !1 && s.push(uN()), e.tabSize && typeof e.tabSize == "number" && s.push(MO.of(" ".repeat(e.tabSize))), s.concat([kO.of(l.flat())]).filter(Boolean);
};
const XU = "#e5c07b", HR = "#e06c75", jU = "#56b6c2", GU = "#ffffff", f1 = "#abb2bf", Jx = "#7d8799", YU = "#61afef", $U = "#98c379", LR = "#d19a66", ZU = "#c678dd", PU = "#21252b", VR = "#2c313a", XR = "#282c34", WT = "#353a42", WU = "#3E4451", jR = "#528bff", FU = /* @__PURE__ */ Me.theme({
  "&": {
    color: f1,
    backgroundColor: XR
  },
  ".cm-content": {
    caretColor: jR
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: jR },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: WU },
  ".cm-panels": { backgroundColor: PU, color: f1 },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: XR,
    color: Jx,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: VR
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: WT
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: WT,
    borderBottomColor: WT
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: VR,
      color: f1
    }
  }
}, { dark: !0 }), KU = /* @__PURE__ */ Gm.define([
  {
    tag: C.keyword,
    color: ZU
  },
  {
    tag: [C.name, C.deleted, C.character, C.propertyName, C.macroName],
    color: HR
  },
  {
    tag: [/* @__PURE__ */ C.function(C.variableName), C.labelName],
    color: YU
  },
  {
    tag: [C.color, /* @__PURE__ */ C.constant(C.name), /* @__PURE__ */ C.standard(C.name)],
    color: LR
  },
  {
    tag: [/* @__PURE__ */ C.definition(C.name), C.separator],
    color: f1
  },
  {
    tag: [C.typeName, C.className, C.number, C.changed, C.annotation, C.modifier, C.self, C.namespace],
    color: XU
  },
  {
    tag: [C.operator, C.operatorKeyword, C.url, C.escape, C.regexp, C.link, /* @__PURE__ */ C.special(C.string)],
    color: jU
  },
  {
    tag: [C.meta, C.comment],
    color: Jx
  },
  {
    tag: C.strong,
    fontWeight: "bold"
  },
  {
    tag: C.emphasis,
    fontStyle: "italic"
  },
  {
    tag: C.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: C.link,
    color: Jx,
    textDecoration: "underline"
  },
  {
    tag: C.heading,
    fontWeight: "bold",
    color: HR
  },
  {
    tag: [C.atom, C.bool, /* @__PURE__ */ C.special(C.variableName)],
    color: LR
  },
  {
    tag: [C.processingInstruction, C.string, C.inserted],
    color: $U
  },
  {
    tag: C.invalid,
    color: GU
  }
]), JU = [FU, /* @__PURE__ */ TA(KU)];
var IU = Me.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), eB = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: n = !0,
    editable: l = !0,
    readOnly: s = !1,
    theme: c = "light",
    placeholder: d = "",
    basicSetup: m = !0
  } = e, y = [];
  switch (n && y.unshift(kO.of([iN])), m && (typeof m == "boolean" ? y.unshift(_R()) : y.unshift(_R(m))), d && y.unshift(c5(d)), c) {
    case "light":
      y.push(IU);
      break;
    case "dark":
      y.push(JU);
      break;
    case "none":
      break;
    default:
      y.push(c);
      break;
  }
  return l === !1 && y.push(Me.editable.of(!1)), s && y.push(At.readOnly.of(!0)), [...y];
}, tB = (o) => ({
  line: o.state.doc.lineAt(o.state.selection.main.from),
  lineCount: o.state.doc.lines,
  lineBreak: o.state.lineBreak,
  length: o.state.doc.length,
  readOnly: o.state.readOnly,
  tabSize: o.state.tabSize,
  selection: o.state.selection,
  selectionAsSingle: o.state.selection.asSingle().main,
  ranges: o.state.selection.ranges,
  selectionCode: o.state.sliceDoc(o.state.selection.main.from, o.state.selection.main.to),
  selections: o.state.selection.ranges.map((e) => o.state.sliceDoc(e.from, e.to)),
  selectedText: o.state.selection.ranges.some((e) => !e.empty)
}), GR = or.define(), nB = [];
function iB(o) {
  var {
    value: e,
    selection: n,
    onChange: l,
    onStatistics: s,
    onCreateEditor: c,
    onUpdate: d,
    extensions: m = nB,
    autoFocus: y,
    theme: b = "light",
    height: S = null,
    minHeight: A = null,
    maxHeight: w = null,
    width: E = null,
    minWidth: z = null,
    maxWidth: U = null,
    placeholder: V = "",
    editable: G = !0,
    readOnly: ie = !1,
    indentWithTab: me = !0,
    basicSetup: pe = !0,
    root: ne,
    initialState: ye
  } = o, [Oe, we] = Zn.useState(), [Re, Te] = Zn.useState(), [ze, fe] = Zn.useState(), Qe = Me.theme({
    "&": {
      height: S,
      minHeight: A,
      maxHeight: w,
      width: E,
      minWidth: z,
      maxWidth: U
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), Ve = Me.updateListener.of((Z) => {
    if (Z.docChanged && typeof l == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !Z.transactions.some((B) => B.annotation(GR))) {
      var ge = Z.state.doc, Se = ge.toString();
      l(Se, Z);
    }
    s && s(tB(Z));
  }), Xe = eB({
    theme: b,
    editable: G,
    readOnly: ie,
    placeholder: V,
    indentWithTab: me,
    basicSetup: pe
  }), F = [Ve, Qe, ...Xe];
  return d && typeof d == "function" && F.push(Me.updateListener.of(d)), F = F.concat(m), Zn.useLayoutEffect(() => {
    if (Oe && !ze) {
      var Z = {
        doc: e,
        selection: n,
        extensions: F
      }, ge = ye ? At.fromJSON(ye.json, Z, ye.fields) : At.create(Z);
      if (fe(ge), !Re) {
        var Se = new Me({
          state: ge,
          parent: Oe,
          root: ne
        });
        Te(Se), c && c(Se, ge);
      }
    }
    return () => {
      Re && (fe(void 0), Te(void 0));
    };
  }, [Oe, ze]), Zn.useEffect(() => {
    o.container && we(o.container);
  }, [o.container]), Zn.useEffect(() => () => {
    Re && (Re.destroy(), Te(void 0));
  }, [Re]), Zn.useEffect(() => {
    y && Re && Re.focus();
  }, [y, Re]), Zn.useEffect(() => {
    Re && Re.dispatch({
      effects: it.reconfigure.of(F)
    });
  }, [b, m, S, A, w, E, z, U, V, G, ie, me, pe, l, d]), Zn.useEffect(() => {
    if (e !== void 0) {
      var Z = Re ? Re.state.doc.toString() : "";
      Re && e !== Z && Re.dispatch({
        changes: {
          from: 0,
          to: Z.length,
          insert: e || ""
        },
        annotations: [GR.of(!0)]
      });
    }
  }, [e, Re]), {
    state: ze,
    setState: fe,
    view: Re,
    setView: Te,
    container: Oe,
    setContainer: we
  };
}
var lB = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], oz = /* @__PURE__ */ Zn.forwardRef((o, e) => {
  var {
    className: n,
    value: l = "",
    selection: s,
    extensions: c = [],
    onChange: d,
    onStatistics: m,
    onCreateEditor: y,
    onUpdate: b,
    autoFocus: S,
    theme: A = "light",
    height: w,
    minHeight: E,
    maxHeight: z,
    width: U,
    minWidth: V,
    maxWidth: G,
    basicSetup: ie,
    placeholder: me,
    indentWithTab: pe,
    editable: ne,
    readOnly: ye,
    root: Oe,
    initialState: we
  } = o, Re = _3(o, lB), Te = Zn.useRef(null), {
    state: ze,
    view: fe,
    container: Qe,
    setContainer: Ve
  } = iB({
    root: Oe,
    value: l,
    autoFocus: S,
    theme: A,
    height: w,
    minHeight: E,
    maxHeight: z,
    width: U,
    minWidth: V,
    maxWidth: G,
    basicSetup: ie,
    placeholder: me,
    indentWithTab: pe,
    editable: ne,
    readOnly: ye,
    selection: s,
    onChange: d,
    onStatistics: m,
    onCreateEditor: y,
    onUpdate: b,
    extensions: c,
    initialState: we
  });
  Zn.useImperativeHandle(e, () => ({
    editor: Te.current,
    state: ze,
    view: fe
  }), [Te, Qe, ze, fe]);
  var Xe = Zn.useCallback((Z) => {
    Te.current = Z, Ve(Z);
  }, [Ve]);
  if (typeof l != "string")
    throw new Error("value must be typeof string but got " + typeof l);
  var F = typeof A == "string" ? "cm-theme-" + A : "cm-theme";
  return /* @__PURE__ */ Ks.jsx("div", ix({
    ref: Xe,
    className: "" + F + (n ? " " + n : "")
  }, Re));
});
oz.displayName = "CodeMirror";
var YR = {};
class H1 {
  /**
  @internal
  */
  constructor(e, n, l, s, c, d, m, y, b, S = 0, A) {
    this.p = e, this.stack = n, this.state = l, this.reducePos = s, this.pos = c, this.score = d, this.buffer = m, this.bufferBase = y, this.curContext = b, this.lookAhead = S, this.parent = A;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, n, l = 0) {
    let s = e.parser.context;
    return new H1(e, [], n, l, l, 0, [], 0, s ? new $R(s, s.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var n;
    let l = e >> 19, s = e & 65535, { parser: c } = this.p, d = this.reducePos < this.pos - 25;
    d && this.setLookAhead(this.pos);
    let m = c.dynamicPrecedence(s);
    if (m && (this.score += m), l == 0) {
      this.pushState(c.getGoto(this.state, s, !0), this.reducePos), s < c.minRepeatTerm && this.storeNode(s, this.reducePos, this.reducePos, d ? 8 : 4, !0), this.reduceContext(s, this.reducePos);
      return;
    }
    let y = this.stack.length - (l - 1) * 3 - (e & 262144 ? 6 : 0), b = y ? this.stack[y - 2] : this.p.ranges[0].from, S = this.reducePos - b;
    S >= 2e3 && !(!((n = this.p.parser.nodeSet.types[s]) === null || n === void 0) && n.isAnonymous) && (b == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = S) : this.p.lastBigReductionSize < S && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = b, this.p.lastBigReductionSize = S));
    let A = y ? this.stack[y - 1] : 0, w = this.bufferBase + this.buffer.length - A;
    if (s < c.minRepeatTerm || e & 131072) {
      let E = c.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(s, b, E, w + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[y];
    else {
      let E = this.stack[y - 3];
      this.state = c.getGoto(E, s, !0);
    }
    for (; this.stack.length > y; )
      this.stack.pop();
    this.reduceContext(s, b);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, n, l, s = 4, c = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let d = this, m = this.buffer.length;
      if (m == 0 && d.parent && (m = d.bufferBase - d.parent.bufferBase, d = d.parent), m > 0 && d.buffer[m - 4] == 0 && d.buffer[m - 1] > -1) {
        if (n == l)
          return;
        if (d.buffer[m - 2] >= n) {
          d.buffer[m - 2] = l;
          return;
        }
      }
    }
    if (!c || this.pos == l)
      this.buffer.push(e, n, l, s);
    else {
      let d = this.buffer.length;
      if (d > 0 && this.buffer[d - 4] != 0) {
        let m = !1;
        for (let y = d; y > 0 && this.buffer[y - 2] > l; y -= 4)
          if (this.buffer[y - 1] >= 0) {
            m = !0;
            break;
          }
        if (m)
          for (; d > 0 && this.buffer[d - 2] > l; )
            this.buffer[d] = this.buffer[d - 4], this.buffer[d + 1] = this.buffer[d - 3], this.buffer[d + 2] = this.buffer[d - 2], this.buffer[d + 3] = this.buffer[d - 1], d -= 4, s > 4 && (s -= 4);
      }
      this.buffer[d] = e, this.buffer[d + 1] = n, this.buffer[d + 2] = l, this.buffer[d + 3] = s;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, n, l, s) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let c = e, { parser: d } = this.p;
      (s > this.pos || n <= d.maxNode) && (this.pos = s, d.stateFlag(
        c,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = s)), this.pushState(c, l), this.shiftContext(n, l), n <= d.maxNode && this.buffer.push(n, l, s, 4);
    } else
      this.pos = s, this.shiftContext(n, l), n <= this.p.parser.maxNode && this.buffer.push(n, l, s, 4);
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, n, l, s) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, l, s);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, n) {
    let l = this.p.reused.length - 1;
    (l < 0 || this.p.reused[l] != e) && (this.p.reused.push(e), l++);
    let s = this.pos;
    this.reducePos = this.pos = s + e.length, this.pushState(n, s), this.buffer.push(
      l,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let l = e.buffer.slice(n), s = e.bufferBase + n;
    for (; e && s == e.bufferBase; )
      e = e.parent;
    return new H1(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, l, s, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, n) {
    let l = e <= this.p.parser.maxNode;
    l && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, l ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let n = new aB(this); ; ) {
      let l = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, e);
      if (l == 0)
        return !1;
      if ((l & 65536) == 0)
        return !0;
      n.reduce(l);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let c = 0, d; c < n.length; c += 2)
        (d = n[c + 1]) != this.state && this.p.parser.hasAction(d, e) && s.push(n[c], d);
      if (this.stack.length < 120)
        for (let c = 0; s.length < 8 && c < n.length; c += 2) {
          let d = n[c + 1];
          s.some((m, y) => y & 1 && m == d) || s.push(n[c], d);
        }
      n = s;
    }
    let l = [];
    for (let s = 0; s < n.length && l.length < 4; s += 2) {
      let c = n[s + 1];
      if (c == this.state)
        continue;
      let d = this.split();
      d.pushState(c, this.pos), d.storeNode(0, d.pos, d.pos, 4, !0), d.shiftContext(n[s], this.pos), d.reducePos = this.pos, d.score -= 200, l.push(d);
    }
    return l;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((n & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, n)) {
      let l = n >> 19, s = n & 65535, c = this.stack.length - l * 3;
      if (c < 0 || e.getGoto(this.stack[c], s, !1) < 0) {
        let d = this.findForcedReduction();
        if (d == null)
          return !1;
        n = d;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, n = [], l = (s, c) => {
      if (!n.includes(s))
        return n.push(s), e.allActions(s, (d) => {
          if (!(d & 393216)) if (d & 65536) {
            let m = (d >> 19) - c;
            if (m > 1) {
              let y = d & 65535, b = this.stack.length - m * 3;
              if (b >= 0 && e.getGoto(this.stack[b], y, !1) >= 0)
                return m << 19 | 65536 | y;
            }
          } else {
            let m = l(d, c + 1);
            if (m != null)
              return m;
          }
        });
    };
    return l(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new $R(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class $R {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class aB {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, l = e >> 19;
    l == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (l - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = s;
  }
}
class L1 {
  constructor(e, n, l) {
    this.stack = e, this.pos = n, this.index = l, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new L1(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new L1(this.stack, this.pos, this.index);
  }
}
function Ib(o, e = Uint16Array) {
  if (typeof o != "string")
    return o;
  let n = null;
  for (let l = 0, s = 0; l < o.length; ) {
    let c = 0;
    for (; ; ) {
      let d = o.charCodeAt(l++), m = !1;
      if (d == 126) {
        c = 65535;
        break;
      }
      d >= 92 && d--, d >= 34 && d--;
      let y = d - 32;
      if (y >= 46 && (y -= 46, m = !0), c += y, m)
        break;
      c *= 46;
    }
    n ? n[s++] = c : n = new e(c);
  }
  return n;
}
class h1 {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const ZR = new h1();
class oB {
  /**
  @internal
  */
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = ZR, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, n) {
    let l = this.range, s = this.rangeIndex, c = this.pos + e;
    for (; c < l.from; ) {
      if (!s)
        return null;
      let d = this.ranges[--s];
      c -= l.from - d.to, l = d;
    }
    for (; n < 0 ? c > l.to : c >= l.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let d = this.ranges[++s];
      c += d.from - l.to, l = d;
    }
    return c;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.

  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let n = this.chunkOff + e, l, s;
    if (n >= 0 && n < this.chunk.length)
      l = this.pos + e, s = this.chunk.charCodeAt(n);
    else {
      let c = this.resolveOffset(e, 1);
      if (c == null)
        return -1;
      if (l = c, l >= this.chunk2Pos && l < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(l - this.chunk2Pos);
      else {
        let d = this.rangeIndex, m = this.range;
        for (; m.to <= l; )
          m = this.ranges[++d];
        this.chunk2 = this.input.chunk(this.chunk2Pos = l), l + this.chunk2.length > m.to && (this.chunk2 = this.chunk2.slice(0, m.to - l)), s = this.chunk2.charCodeAt(0);
      }
    }
    return l >= this.token.lookAhead && (this.token.lookAhead = l + 1), s;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, n = 0) {
    let l = n ? this.resolveOffset(n, -1) : this.pos;
    if (l == null || l < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = l;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, n) {
    this.token.value = e, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = ZR, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let l = "";
    for (let s of this.ranges) {
      if (s.from >= n)
        break;
      s.to > e && (l += this.input.read(Math.max(s.from, e), Math.min(s.to, n)));
    }
    return l;
  }
}
class Qm {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: l } = n.p;
    sB(this.data, e, n, this.id, l.data, l.tokenPrecTable);
  }
}
Qm.prototype.contextual = Qm.prototype.fallback = Qm.prototype.extend = !1;
Qm.prototype.fallback = Qm.prototype.extend = !1;
class I1 {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function sB(o, e, n, l, s, c) {
  let d = 0, m = 1 << l, { dialect: y } = n.p.parser;
  e: for (; (m & o[d]) != 0; ) {
    let b = o[d + 1];
    for (let E = d + 3; E < b; E += 2)
      if ((o[E + 1] & m) > 0) {
        let z = o[E];
        if (y.allows(z) && (e.token.value == -1 || e.token.value == z || rB(z, e.token.value, s, c))) {
          e.acceptToken(z);
          break;
        }
      }
    let S = e.next, A = 0, w = o[d + 2];
    if (e.next < 0 && w > A && o[b + w * 3 - 3] == 65535) {
      d = o[b + w * 3 - 1];
      continue e;
    }
    for (; A < w; ) {
      let E = A + w >> 1, z = b + E + (E << 1), U = o[z], V = o[z + 1] || 65536;
      if (S < U)
        w = E;
      else if (S >= V)
        A = E + 1;
      else {
        d = o[z + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function PR(o, e, n) {
  for (let l = e, s; (s = o[l]) != 65535; l++)
    if (s == n)
      return l - e;
  return -1;
}
function rB(o, e, n, l) {
  let s = PR(n, l, e);
  return s < 0 || PR(n, l, o) < s;
}
const Ca = typeof process < "u" && YR && /\bparse\b/.test(YR.LOG);
let FT = null;
function WR(o, e, n) {
  let l = o.cursor(ui.IncludeAnonymous);
  for (l.moveTo(e); ; )
    if (!(n < 0 ? l.childBefore(e) : l.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? l.to < e : l.from > e) && !l.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            l.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(o.length, Math.max(
            l.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (n < 0 ? l.prevSibling() : l.nextSibling())
          break;
        if (!l.parent())
          return n < 0 ? 0 : o.length;
      }
}
class uB {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? WR(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? WR(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let l = this.trees[n], s = this.index[n];
      if (s == l.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let c = l.children[s], d = this.start[n] + l.positions[s];
      if (d > e)
        return this.nextStart = d, null;
      if (c instanceof Wn) {
        if (d == e) {
          if (d < this.safeFrom)
            return null;
          let m = d + c.length;
          if (m <= this.safeTo) {
            let y = c.prop(bt.lookAhead);
            if (!y || m + y < this.fragment.to)
              return c;
          }
        }
        this.index[n]++, d + c.length >= Math.max(this.safeFrom, e) && (this.trees.push(c), this.start.push(d), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = d + c.length;
    }
  }
}
class cB {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((l) => new h1());
  }
  getActions(e) {
    let n = 0, l = null, { parser: s } = e.p, { tokenizers: c } = s, d = s.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), m = e.curContext ? e.curContext.hash : 0, y = 0;
    for (let b = 0; b < c.length; b++) {
      if ((1 << b & d) == 0)
        continue;
      let S = c[b], A = this.tokens[b];
      if (!(l && !S.fallback) && ((S.contextual || A.start != e.pos || A.mask != d || A.context != m) && (this.updateCachedToken(A, S, e), A.mask = d, A.context = m), A.lookAhead > A.end + 25 && (y = Math.max(A.lookAhead, y)), A.value != 0)) {
        let w = n;
        if (A.extended > -1 && (n = this.addActions(e, A.extended, A.end, n)), n = this.addActions(e, A.value, A.end, n), !S.extend && (l = A, n > w))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return y && e.setLookAhead(y), !l && e.pos == this.stream.end && (l = new h1(), l.value = e.p.parser.eofTerm, l.start = l.end = e.pos, n = this.addActions(e, l.value, l.end, n)), this.mainToken = l, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new h1(), { pos: l, p: s } = e;
    return n.start = l, n.end = Math.min(l + 1, s.stream.end), n.value = l == s.stream.end ? s.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, l) {
    let s = this.stream.clipPos(l.pos);
    if (n.token(this.stream.reset(s, e), l), e.value > -1) {
      let { parser: c } = l.p;
      for (let d = 0; d < c.specialized.length; d++)
        if (c.specialized[d] == e.value) {
          let m = c.specializers[d](this.stream.read(e.start, e.end), l);
          if (m >= 0 && l.p.parser.dialect.allows(m >> 1)) {
            (m & 1) == 0 ? e.value = m >> 1 : e.extended = m >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(s + 1);
  }
  putAction(e, n, l, s) {
    for (let c = 0; c < s; c += 3)
      if (this.actions[c] == e)
        return s;
    return this.actions[s++] = e, this.actions[s++] = n, this.actions[s++] = l, s;
  }
  addActions(e, n, l, s) {
    let { state: c } = e, { parser: d } = e.p, { data: m } = d;
    for (let y = 0; y < 2; y++)
      for (let b = d.stateSlot(
        c,
        y ? 2 : 1
        /* ParseState.Actions */
      ); ; b += 3) {
        if (m[b] == 65535)
          if (m[b + 1] == 1)
            b = pu(m, b + 2);
          else {
            s == 0 && m[b + 1] == 2 && (s = this.putAction(pu(m, b + 2), n, l, s));
            break;
          }
        m[b] == n && (s = this.putAction(pu(m, b + 1), n, l, s));
      }
    return s;
  }
}
class fB {
  constructor(e, n, l, s) {
    this.parser = e, this.input = n, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new oB(n, s), this.tokens = new cB(e, this.stream), this.topTerm = e.top[1];
    let { from: c } = s[0];
    this.stacks = [H1.start(this, e.top[0], c)], this.fragments = l.length && this.stream.end - c > e.bufferLength * 4 ? new uB(l, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, n = this.minStackPos, l = this.stacks = [], s, c;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [d] = e;
      for (; d.forceReduce() && d.stack.length && d.stack[d.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let d = 0; d < e.length; d++) {
      let m = e[d];
      for (; ; ) {
        if (this.tokens.mainToken = null, m.pos > n)
          l.push(m);
        else {
          if (this.advanceStack(m, l, e))
            continue;
          {
            s || (s = [], c = []), s.push(m);
            let y = this.tokens.getMainToken(m);
            c.push(y.value, y.end);
          }
        }
        break;
      }
    }
    if (!l.length) {
      let d = s && pB(s);
      if (d)
        return Ca && console.log("Finish with " + this.stackID(d)), this.stackToTree(d);
      if (this.parser.strict)
        throw Ca && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let d = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, c, l);
      if (d)
        return Ca && console.log("Force-finish " + this.stackID(d)), this.stackToTree(d.forceAll());
    }
    if (this.recovering) {
      let d = this.recovering == 1 ? 1 : this.recovering * 3;
      if (l.length > d)
        for (l.sort((m, y) => y.score - m.score); l.length > d; )
          l.pop();
      l.some((m) => m.reducePos > n) && this.recovering--;
    } else if (l.length > 1) {
      e: for (let d = 0; d < l.length - 1; d++) {
        let m = l[d];
        for (let y = d + 1; y < l.length; y++) {
          let b = l[y];
          if (m.sameState(b) || m.buffer.length > 500 && b.buffer.length > 500)
            if ((m.score - b.score || m.buffer.length - b.buffer.length) > 0)
              l.splice(y--, 1);
            else {
              l.splice(d--, 1);
              continue e;
            }
        }
      }
      l.length > 12 && l.splice(
        12,
        l.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = l[0].pos;
    for (let d = 1; d < l.length; d++)
      l[d].pos < this.minStackPos && (this.minStackPos = l[d].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, n, l) {
    let s = e.pos, { parser: c } = this, d = Ca ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let b = e.curContext && e.curContext.tracker.strict, S = b ? e.curContext.hash : 0;
      for (let A = this.fragments.nodeAt(s); A; ) {
        let w = this.parser.nodeSet.types[A.type.id] == A.type ? c.getGoto(e.state, A.type.id) : -1;
        if (w > -1 && A.length && (!b || (A.prop(bt.contextHash) || 0) == S))
          return e.useNode(A, w), Ca && console.log(d + this.stackID(e) + ` (via reuse of ${c.getName(A.type.id)})`), !0;
        if (!(A instanceof Wn) || A.children.length == 0 || A.positions[0] > 0)
          break;
        let E = A.children[0];
        if (E instanceof Wn && A.positions[0] == 0)
          A = E;
        else
          break;
      }
    }
    let m = c.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (m > 0)
      return e.reduce(m), Ca && console.log(d + this.stackID(e) + ` (via always-reduce ${c.getName(
        m & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let y = this.tokens.getActions(e);
    for (let b = 0; b < y.length; ) {
      let S = y[b++], A = y[b++], w = y[b++], E = b == y.length || !l, z = E ? e : e.split(), U = this.tokens.mainToken;
      if (z.apply(S, A, U ? U.start : z.pos, w), Ca && console.log(d + this.stackID(z) + ` (via ${(S & 65536) == 0 ? "shift" : `reduce of ${c.getName(
        S & 65535
        /* Action.ValueMask */
      )}`} for ${c.getName(A)} @ ${s}${z == e ? "" : ", split"})`), E)
        return !0;
      z.pos > s ? n.push(z) : l.push(z);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, n) {
    let l = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > l)
        return FR(e, n), !0;
    }
  }
  runRecovery(e, n, l) {
    let s = null, c = !1;
    for (let d = 0; d < e.length; d++) {
      let m = e[d], y = n[d << 1], b = n[(d << 1) + 1], S = Ca ? this.stackID(m) + " -> " : "";
      if (m.deadEnd && (c || (c = !0, m.restart(), Ca && console.log(S + this.stackID(m) + " (restarted)"), this.advanceFully(m, l))))
        continue;
      let A = m.split(), w = S;
      for (let E = 0; A.forceReduce() && E < 10 && (Ca && console.log(w + this.stackID(A) + " (via force-reduce)"), !this.advanceFully(A, l)); E++)
        Ca && (w = this.stackID(A) + " -> ");
      for (let E of m.recoverByInsert(y))
        Ca && console.log(S + this.stackID(E) + " (via recover-insert)"), this.advanceFully(E, l);
      this.stream.end > m.pos ? (b == m.pos && (b++, y = 0), m.recoverByDelete(y, b), Ca && console.log(S + this.stackID(m) + ` (via recover-delete ${this.parser.getName(y)})`), FR(m, l)) : (!s || s.score < m.score) && (s = m);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Wn.build({
      buffer: L1.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (FT || (FT = /* @__PURE__ */ new WeakMap())).get(e);
    return n || FT.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
}
function FR(o, e) {
  for (let n = 0; n < e.length; n++) {
    let l = e[n];
    if (l.pos == o.pos && l.sameState(o)) {
      e[n].score < o.score && (e[n] = o);
      return;
    }
  }
  e.push(o);
}
class hB {
  constructor(e, n, l) {
    this.source = e, this.flags = n, this.disabled = l;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const KT = (o) => o;
class dB {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || KT, this.reduce = e.reduce || KT, this.reuse = e.reuse || KT, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class V1 extends BD {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let m = 0; m < e.repeatNodeCount; m++)
      n.push("");
    let l = Object.keys(e.topRules).map((m) => e.topRules[m][1]), s = [];
    for (let m = 0; m < n.length; m++)
      s.push([]);
    function c(m, y, b) {
      s[m].push([y, y.deserialize(String(b))]);
    }
    if (e.nodeProps)
      for (let m of e.nodeProps) {
        let y = m[0];
        typeof y == "string" && (y = bt[y]);
        for (let b = 1; b < m.length; ) {
          let S = m[b++];
          if (S >= 0)
            c(S, y, m[b++]);
          else {
            let A = m[b + -S];
            for (let w = -S; w > 0; w--)
              c(m[b++], y, A);
            b++;
          }
        }
      }
    this.nodeSet = new gA(n.map((m, y) => Fl.define({
      name: y >= this.minRepeatTerm ? void 0 : m,
      id: y,
      props: s[y],
      top: l.indexOf(y) > -1,
      error: y == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(y) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = zD;
    let d = Ib(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let m = 0; m < this.specializerSpecs.length; m++)
      this.specialized[m] = this.specializerSpecs[m].term;
    this.specializers = this.specializerSpecs.map(KR), this.states = Ib(e.states, Uint32Array), this.data = Ib(e.stateData), this.goto = Ib(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((m) => typeof m == "number" ? new Qm(d, m) : m), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, l) {
    let s = new fB(this, e, n, l);
    for (let c of this.wrappers)
      s = c(s, e, n, l);
    return s;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, n, l = !1) {
    let s = this.goto;
    if (n >= s[0])
      return -1;
    for (let c = s[n + 1]; ; ) {
      let d = s[c++], m = d & 1, y = s[c++];
      if (m && l)
        return y;
      for (let b = c + (d >> 1); c < b; c++)
        if (s[c] == e)
          return y;
      if (m)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, n) {
    let l = this.data;
    for (let s = 0; s < 2; s++)
      for (let c = this.stateSlot(
        e,
        s ? 2 : 1
        /* ParseState.Actions */
      ), d; ; c += 3) {
        if ((d = l[c]) == 65535)
          if (l[c + 1] == 1)
            d = l[c = pu(l, c + 2)];
          else {
            if (l[c + 1] == 2)
              return pu(l, c + 2);
            break;
          }
        if (d == n || d == 0)
          return pu(l, c + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(e, n) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(e, n) {
    return !!this.allActions(e, (l) => l == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, n) {
    let l = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), s = l ? n(l) : void 0;
    for (let c = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); s == null; c += 3) {
      if (this.data[c] == 65535)
        if (this.data[c + 1] == 1)
          c = pu(this.data, c + 2);
        else
          break;
      s = n(pu(this.data, c + 1));
    }
    return s;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let n = [];
    for (let l = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; l += 3) {
      if (this.data[l] == 65535)
        if (this.data[l + 1] == 1)
          l = pu(this.data, l + 2);
        else
          break;
      if ((this.data[l + 2] & 1) == 0) {
        let s = this.data[l + 1];
        n.some((c, d) => d & 1 && c == s) || n.push(this.data[l], s);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let n = Object.assign(Object.create(V1.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let l = this.topRules[e.top];
      if (!l)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = l;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((l) => {
      let s = e.tokenizers.find((c) => c.from == l);
      return s ? s.to : l;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((l, s) => {
      let c = e.specializers.find((m) => m.from == l.external);
      if (!c)
        return l;
      let d = Object.assign(Object.assign({}, l), { external: c.to });
      return n.specializers[s] = KR(d), d;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let n = Object.keys(this.dialects), l = n.map(() => !1);
    if (e)
      for (let c of e.split(" ")) {
        let d = n.indexOf(c);
        d >= 0 && (l[d] = !0);
      }
    let s = null;
    for (let c = 0; c < n.length; c++)
      if (!l[c])
        for (let d = this.dialects[n[c]], m; (m = this.data[d++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[m] = 1;
    return new hB(e, l, s);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new V1(e);
  }
}
function pu(o, e) {
  return o[e] | o[e + 1] << 16;
}
function pB(o) {
  let e = null;
  for (let n of o) {
    let l = n.p.stoppedAt;
    (n.pos == n.p.stream.end || l != null && n.pos > l) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function KR(o) {
  if (o.external) {
    let e = o.extend ? 1 : 0;
    return (n, l) => o.external(n, l) << 1 | e;
  }
  return o.get;
}
const mB = 1, sz = 194, rz = 195, gB = 196, JR = 197, yB = 198, OB = 199, vB = 200, bB = 2, uz = 3, IR = 201, SB = 24, TB = 25, xB = 49, AB = 50, wB = 55, EB = 56, CB = 57, RB = 59, kB = 60, DB = 61, MB = 62, zB = 63, QB = 65, NB = 238, UB = 71, BB = 241, qB = 242, _B = 243, HB = 244, LB = 245, VB = 246, XB = 247, jB = 248, cz = 72, GB = 249, YB = 250, $B = 251, ZB = 252, PB = 253, WB = 254, FB = 255, KB = 256, JB = 73, IB = 77, eq = 263, tq = 112, nq = 130, iq = 151, lq = 152, aq = 155, id = 10, wO = 13, _A = 32, eS = 9, HA = 35, oq = 40, sq = 46, Ix = 123, ek = 125, fz = 39, hz = 34, tk = 92, rq = 111, uq = 120, cq = 78, fq = 117, hq = 85, dq = /* @__PURE__ */ new Set([
  TB,
  xB,
  AB,
  eq,
  QB,
  nq,
  EB,
  CB,
  NB,
  MB,
  zB,
  cz,
  JB,
  IB,
  kB,
  DB,
  iq,
  lq,
  aq,
  tq
]);
function JT(o) {
  return o == id || o == wO;
}
function IT(o) {
  return o >= 48 && o <= 57 || o >= 65 && o <= 70 || o >= 97 && o <= 102;
}
const pq = new I1((o, e) => {
  let n;
  if (o.next < 0)
    o.acceptToken(OB);
  else if (e.context.flags & d1)
    JT(o.next) && o.acceptToken(yB, 1);
  else if (((n = o.peek(-1)) < 0 || JT(n)) && e.canShift(JR)) {
    let l = 0;
    for (; o.next == _A || o.next == eS; )
      o.advance(), l++;
    (o.next == id || o.next == wO || o.next == HA) && o.acceptToken(JR, -l);
  } else JT(o.next) && o.acceptToken(gB, 1);
}, { contextual: !0 }), mq = new I1((o, e) => {
  let n = e.context;
  if (n.flags) return;
  let l = o.peek(-1);
  if (l == id || l == wO) {
    let s = 0, c = 0;
    for (; ; ) {
      if (o.next == _A) s++;
      else if (o.next == eS) s += 8 - s % 8;
      else break;
      o.advance(), c++;
    }
    s != n.indent && o.next != id && o.next != wO && o.next != HA && (s < n.indent ? o.acceptToken(rz, -c) : o.acceptToken(sz));
  }
}), d1 = 1, dz = 2, cu = 4, fu = 8, hu = 16, du = 32;
function p1(o, e, n) {
  this.parent = o, this.indent = e, this.flags = n, this.hash = (o ? o.hash + o.hash << 8 : 0) + e + (e << 4) + n + (n << 6);
}
const gq = new p1(null, 0, 0);
function yq(o) {
  let e = 0;
  for (let n = 0; n < o.length; n++)
    e += o.charCodeAt(n) == eS ? 8 - e % 8 : 1;
  return e;
}
const nk = new Map([
  [BB, 0],
  [qB, cu],
  [_B, fu],
  [HB, fu | cu],
  [LB, hu],
  [VB, hu | cu],
  [XB, hu | fu],
  [jB, hu | fu | cu],
  [GB, du],
  [YB, du | cu],
  [$B, du | fu],
  [ZB, du | fu | cu],
  [PB, du | hu],
  [WB, du | hu | cu],
  [FB, du | hu | fu],
  [KB, du | hu | fu | cu]
].map(([o, e]) => [o, e | dz])), Oq = new dB({
  start: gq,
  reduce(o, e, n, l) {
    return o.flags & d1 && dq.has(e) || (e == UB || e == cz) && o.flags & dz ? o.parent : o;
  },
  shift(o, e, n, l) {
    return e == sz ? new p1(o, yq(l.read(l.pos, n.pos)), 0) : e == rz ? o.parent : e == SB || e == wB || e == RB || e == uz ? new p1(o, 0, d1) : nk.has(e) ? new p1(o, 0, nk.get(e) | o.flags & d1) : o;
  },
  hash(o) {
    return o.hash;
  }
}), vq = new I1((o) => {
  for (let e = 0; e < 5; e++) {
    if (o.next != "print".charCodeAt(e)) return;
    o.advance();
  }
  if (!/\w/.test(String.fromCharCode(o.next)))
    for (let e = 0; ; e++) {
      let n = o.peek(e);
      if (!(n == _A || n == eS)) {
        n != oq && n != sq && n != id && n != wO && n != HA && o.acceptToken(mB);
        return;
      }
    }
}), bq = new I1((o, e) => {
  let { flags: n } = e.context, l = n & cu ? hz : fz, s = (n & fu) > 0, c = !(n & hu), d = (n & du) > 0, m = o.pos;
  for (; !(o.next < 0); )
    if (d && o.next == Ix)
      if (o.peek(1) == Ix)
        o.advance(2);
      else {
        if (o.pos == m) {
          o.acceptToken(uz, 1);
          return;
        }
        break;
      }
    else if (c && o.next == tk) {
      if (o.pos == m) {
        o.advance();
        let y = o.next;
        y >= 0 && (o.advance(), Sq(o, y)), o.acceptToken(bB);
        return;
      }
      break;
    } else if (o.next == tk && !c && o.peek(1) > -1)
      o.advance(2);
    else if (o.next == l && (!s || o.peek(1) == l && o.peek(2) == l)) {
      if (o.pos == m) {
        o.acceptToken(IR, s ? 3 : 1);
        return;
      }
      break;
    } else if (o.next == id) {
      if (s)
        o.advance();
      else if (o.pos == m) {
        o.acceptToken(IR);
        return;
      }
      break;
    } else
      o.advance();
  o.pos > m && o.acceptToken(vB);
});
function Sq(o, e) {
  if (e == rq)
    for (let n = 0; n < 2 && o.next >= 48 && o.next <= 55; n++) o.advance();
  else if (e == uq)
    for (let n = 0; n < 2 && IT(o.next); n++) o.advance();
  else if (e == fq)
    for (let n = 0; n < 4 && IT(o.next); n++) o.advance();
  else if (e == hq)
    for (let n = 0; n < 8 && IT(o.next); n++) o.advance();
  else if (e == cq && o.next == Ix) {
    for (o.advance(); o.next >= 0 && o.next != ek && o.next != fz && o.next != hz && o.next != id; ) o.advance();
    o.next == ek && o.advance();
  }
}
const Tq = qD({
  'async "*" "**" FormatConversion FormatSpec': C.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": C.controlKeyword,
  "in not and or is del": C.operatorKeyword,
  "from def class global nonlocal lambda": C.definitionKeyword,
  import: C.moduleKeyword,
  "with as print": C.keyword,
  Boolean: C.bool,
  None: C.null,
  VariableName: C.variableName,
  "CallExpression/VariableName": C.function(C.variableName),
  "FunctionDefinition/VariableName": C.function(C.definition(C.variableName)),
  "ClassDefinition/VariableName": C.definition(C.className),
  PropertyName: C.propertyName,
  "CallExpression/MemberExpression/PropertyName": C.function(C.propertyName),
  Comment: C.lineComment,
  Number: C.number,
  String: C.string,
  FormatString: C.special(C.string),
  Escape: C.escape,
  UpdateOp: C.updateOperator,
  "ArithOp!": C.arithmeticOperator,
  BitOp: C.bitwiseOperator,
  CompareOp: C.compareOperator,
  AssignOp: C.definitionOperator,
  Ellipsis: C.punctuation,
  At: C.meta,
  "( )": C.paren,
  "[ ]": C.squareBracket,
  "{ }": C.brace,
  ".": C.derefOperator,
  ", ;": C.separator
}), xq = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 }, Aq = V1.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: " print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: Oq,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [Tq],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [vq, mq, pq, bq, 0, 1, 2, 3, 4],
  topRules: { Script: [0, 5] },
  specialized: [{ term: 221, get: (o) => xq[o] || -1 }],
  tokenPrec: 7668
}), ik = /* @__PURE__ */ new $5(), pz = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function e1(o) {
  return (e, n, l) => {
    if (l)
      return !1;
    let s = e.node.getChild("VariableName");
    return s && n(s, o), !0;
  };
}
const wq = {
  FunctionDefinition: /* @__PURE__ */ e1("function"),
  ClassDefinition: /* @__PURE__ */ e1("class"),
  ForStatement(o, e, n) {
    if (n) {
      for (let l = o.node.firstChild; l; l = l.nextSibling)
        if (l.name == "VariableName")
          e(l, "variable");
        else if (l.name == "in")
          break;
    }
  },
  ImportStatement(o, e) {
    var n, l;
    let { node: s } = o, c = ((n = s.firstChild) === null || n === void 0 ? void 0 : n.name) == "from";
    for (let d = s.getChild("import"); d; d = d.nextSibling)
      d.name == "VariableName" && ((l = d.nextSibling) === null || l === void 0 ? void 0 : l.name) != "as" && e(d, c ? "variable" : "namespace");
  },
  AssignStatement(o, e) {
    for (let n = o.node.firstChild; n; n = n.nextSibling)
      if (n.name == "VariableName")
        e(n, "variable");
      else if (n.name == ":" || n.name == "AssignOp")
        break;
  },
  ParamList(o, e) {
    for (let n = null, l = o.node.firstChild; l; l = l.nextSibling)
      l.name == "VariableName" && (!n || !/\*|AssignOp/.test(n.name)) && e(l, "variable"), n = l;
  },
  CapturePattern: /* @__PURE__ */ e1("variable"),
  AsPattern: /* @__PURE__ */ e1("variable"),
  __proto__: null
};
function mz(o, e) {
  let n = ik.get(e);
  if (n)
    return n;
  let l = [], s = !0;
  function c(d, m) {
    let y = o.sliceString(d.from, d.to);
    l.push({ label: y, type: m });
  }
  return e.cursor(ui.IncludeAnonymous).iterate((d) => {
    if (d.name) {
      let m = wq[d.name];
      if (m && m(d, c, s) || !s && pz.has(d.name))
        return !1;
      s = !1;
    } else if (d.to - d.from > 8192) {
      for (let m of mz(o, d.node))
        l.push(m);
      return !1;
    }
  }), ik.set(e, l), l;
}
const lk = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, gz = ["String", "FormatString", "Comment", "PropertyName"];
function Eq(o) {
  let e = bi(o.state).resolveInner(o.pos, -1);
  if (gz.indexOf(e.name) > -1)
    return null;
  let n = e.name == "VariableName" || e.to - e.from < 20 && lk.test(o.state.sliceDoc(e.from, e.to));
  if (!n && !o.explicit)
    return null;
  let l = [];
  for (let s = e; s; s = s.parent)
    pz.has(s.name) && (l = l.concat(mz(o.state.doc, s)));
  return {
    options: l,
    from: n ? e.from : o.pos,
    validFor: lk
  };
}
const Cq = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((o) => ({ label: o, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((o) => ({ label: o, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((o) => ({ label: o, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((o) => ({ label: o, type: "function" }))), Rq = [
  /* @__PURE__ */ uu("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ uu(`if \${}:

`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ uu("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], kq = /* @__PURE__ */ QN(gz, /* @__PURE__ */ YM(/* @__PURE__ */ Cq.concat(Rq)));
function ex(o) {
  let { node: e, pos: n } = o, l = o.lineIndent(n, -1), s = null;
  for (; ; ) {
    let c = e.childBefore(n);
    if (c)
      if (c.name == "Comment")
        n = c.from;
      else if (c.name == "Body" || c.name == "MatchBody")
        o.baseIndentFor(c) + o.unit <= l && (s = c), e = c;
      else if (c.name == "MatchClause")
        e = c;
      else if (c.type.is("Statement"))
        e = c;
      else
        break;
    else break;
  }
  return s;
}
function tx(o, e) {
  let n = o.baseIndentFor(e), l = o.lineAt(o.pos, -1), s = l.from + l.text.length;
  return /^\s*($|#)/.test(l.text) && o.node.to < s + 100 && !/\S/.test(o.state.sliceDoc(s, o.node.to)) && o.lineIndent(o.pos, -1) <= n || /^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(o.textAfter) && o.lineIndent(o.pos, -1) > n ? null : n + o.unit;
}
const nx = /* @__PURE__ */ E1.define({
  name: "python",
  parser: /* @__PURE__ */ Aq.configure({
    props: [
      /* @__PURE__ */ VD.add({
        Body: (o) => {
          var e;
          let n = ex(o);
          return (e = tx(o, n || o.node)) !== null && e !== void 0 ? e : o.continue();
        },
        MatchBody: (o) => {
          var e;
          let n = ex(o);
          return (e = tx(o, n || o.node)) !== null && e !== void 0 ? e : o.continue();
        },
        IfStatement: (o) => /^\s*(else:|elif )/.test(o.textAfter) ? o.baseIndent : o.continue(),
        "ForStatement WhileStatement": (o) => /^\s*else:/.test(o.textAfter) ? o.baseIndent : o.continue(),
        TryStatement: (o) => /^\s*(except |finally:|else:)/.test(o.textAfter) ? o.baseIndent : o.continue(),
        MatchStatement: (o) => /^\s*case /.test(o.textAfter) ? o.baseIndent + o.unit : o.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ LT({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ LT({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ LT({ closing: "]" }),
        MemberExpression: (o) => o.baseIndent + o.unit,
        "String FormatString": () => null,
        Script: (o) => {
          var e;
          let n = ex(o);
          return (e = n && tx(o, n)) !== null && e !== void 0 ? e : o.continue();
        }
      }),
      /* @__PURE__ */ GD.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": y6,
        Body: (o, e) => ({ from: o.from + 1, to: o.to - (o.to == e.doc.length ? 0 : 1) }),
        "String FormatString": (o, e) => ({ from: e.doc.lineAt(o.from).to, to: o.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function Dq() {
  return new o6(nx, [
    nx.data.of({ autocomplete: Eq }),
    nx.data.of({ autocomplete: kq })
  ]);
}
const sl = ({ variant: o, settings: e, styles: n }) => {
  const l = Me.theme({
    // eslint-disable-next-line @typescript-eslint/naming-convention
    "&": {
      backgroundColor: e.background,
      color: e.foreground
    },
    ".cm-content": {
      caretColor: e.caret
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: e.caret
    },
    "&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: e.selection
    },
    ".cm-activeLine": {
      backgroundColor: e.lineHighlight
    },
    ".cm-gutters": {
      backgroundColor: e.gutterBackground,
      color: e.gutterForeground
    },
    ".cm-activeLineGutter": {
      backgroundColor: e.lineHighlight
    }
  }, {
    dark: o === "dark"
  }), s = Gm.define(n);
  return [l, TA(s)];
};
sl({
  variant: "dark",
  settings: {
    background: "#200020",
    foreground: "#D0D0FF",
    caret: "#7070FF",
    selection: "#80000080",
    gutterBackground: "#200020",
    gutterForeground: "#C080C0",
    lineHighlight: "#80000040"
  },
  styles: [
    {
      tag: C.comment,
      color: "#404080"
    },
    {
      tag: [C.string, C.regexp],
      color: "#999999"
    },
    {
      tag: C.number,
      color: "#7090B0"
    },
    {
      tag: [C.bool, C.null],
      color: "#8080A0"
    },
    {
      tag: [C.punctuation, C.derefOperator],
      color: "#805080"
    },
    {
      tag: C.keyword,
      color: "#60B0FF"
    },
    {
      tag: C.definitionKeyword,
      color: "#B0FFF0"
    },
    {
      tag: C.moduleKeyword,
      color: "#60B0FF"
    },
    {
      tag: C.operator,
      color: "#A0A0FF"
    },
    {
      tag: [C.variableName, C.self],
      color: "#008080"
    },
    {
      tag: C.operatorKeyword,
      color: "#A0A0FF"
    },
    {
      tag: C.controlKeyword,
      color: "#80A0FF"
    },
    {
      tag: C.className,
      color: "#70E080"
    },
    {
      tag: [C.function(C.propertyName), C.propertyName],
      color: "#50A0A0"
    },
    {
      tag: C.tagName,
      color: "#009090"
    },
    {
      tag: C.modifier,
      color: "#B0FFF0"
    },
    {
      tag: [C.squareBracket, C.attributeName],
      color: "#D0D0FF"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#fcfcfc",
    foreground: "#5c6166",
    caret: "#ffaa33",
    selection: "#036dd626",
    gutterBackground: "#fcfcfc",
    gutterForeground: "#8a919966",
    lineHighlight: "#8a91991a"
  },
  styles: [
    {
      tag: C.comment,
      color: "#787b8099"
    },
    {
      tag: C.string,
      color: "#86b300"
    },
    {
      tag: C.regexp,
      color: "#4cbf99"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#ffaa33"
    },
    {
      tag: C.variableName,
      color: "#5c6166"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#fa8d3e"
    },
    {
      tag: [C.keyword, C.special(C.brace)],
      color: "#fa8d3e"
    },
    {
      tag: C.operator,
      color: "#ed9366"
    },
    {
      tag: C.separator,
      color: "#5c6166b3"
    },
    {
      tag: C.punctuation,
      color: "#5c6166"
    },
    {
      tag: [C.definition(C.propertyName), C.function(C.variableName)],
      color: "#f2ae49"
    },
    {
      tag: [C.className, C.definition(C.typeName)],
      color: "#22a4e6"
    },
    {
      tag: [C.tagName, C.typeName, C.self, C.labelName],
      color: "#55b4d4"
    },
    {
      tag: C.angleBracket,
      color: "#55b4d480"
    },
    {
      tag: C.attributeName,
      color: "#f2ae49"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#15191EFA",
    foreground: "#EEF2F7",
    caret: "#C4C4C4",
    selection: "#90B2D557",
    gutterBackground: "#15191EFA",
    gutterForeground: "#aaaaaa95",
    lineHighlight: "#57575712"
  },
  styles: [
    {
      tag: C.comment,
      color: "#6E6E6E"
    },
    {
      tag: [C.string, C.regexp, C.special(C.brace)],
      color: "#5C81B3"
    },
    {
      tag: C.number,
      color: "#C1E1B8"
    },
    {
      tag: C.bool,
      color: "#53667D"
    },
    {
      tag: [C.definitionKeyword, C.modifier, C.function(C.propertyName)],
      color: "#A3D295",
      fontWeight: "bold"
    },
    {
      tag: [C.keyword, C.moduleKeyword, C.operatorKeyword, C.operator],
      color: "#697A8E",
      fontWeight: "bold"
    },
    {
      tag: [C.variableName, C.attributeName],
      color: "#708E67"
    },
    {
      tag: [
        C.function(C.variableName),
        C.definition(C.propertyName),
        C.derefOperator
      ],
      color: "#fff"
    },
    {
      tag: C.tagName,
      color: "#A3D295"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#2e241d",
    foreground: "#BAAE9E",
    caret: "#A7A7A7",
    selection: "#DDF0FF33",
    gutterBackground: "#28211C",
    gutterForeground: "#BAAE9E90",
    lineHighlight: "#FFFFFF08"
  },
  styles: [
    {
      tag: C.comment,
      color: "#666666"
    },
    {
      tag: [C.string, C.special(C.brace)],
      color: "#54BE0D"
    },
    {
      tag: C.regexp,
      color: "#E9C062"
    },
    {
      tag: C.number,
      color: "#CF6A4C"
    },
    {
      tag: [C.keyword, C.operator],
      color: "#5EA6EA"
    },
    {
      tag: C.variableName,
      color: "#7587A6"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#F9EE98"
    },
    {
      tag: [C.propertyName, C.function(C.variableName)],
      color: "#937121"
    },
    {
      tag: [C.typeName, C.angleBracket, C.tagName],
      color: "#9B859D"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#3b2627",
    foreground: "#E6E1C4",
    caret: "#E6E1C4",
    selection: "#16120E",
    gutterBackground: "#3b2627",
    gutterForeground: "#E6E1C490",
    lineHighlight: "#1F1611"
  },
  styles: [
    {
      tag: C.comment,
      color: "#6B4E32"
    },
    {
      tag: [C.keyword, C.operator, C.derefOperator],
      color: "#EF5D32"
    },
    {
      tag: C.className,
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: [
        C.typeName,
        C.propertyName,
        C.function(C.variableName),
        C.definition(C.variableName)
      ],
      color: "#EFAC32"
    },
    {
      tag: C.definition(C.typeName),
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: C.labelName,
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: [C.number, C.bool],
      color: "#6C99BB"
    },
    {
      tag: [C.variableName, C.self],
      color: "#7DAF9C"
    },
    {
      tag: [C.string, C.special(C.brace), C.regexp],
      color: "#D9D762"
    },
    {
      tag: [C.angleBracket, C.tagName, C.attributeName],
      color: "#EFCB43"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#000205",
    foreground: "#FFFFFF",
    caret: "#E60065",
    selection: "#E60C6559",
    gutterBackground: "#000205",
    gutterForeground: "#ffffff90",
    lineHighlight: "#4DD7FC1A"
  },
  styles: [
    {
      tag: C.comment,
      color: "#404040"
    },
    {
      tag: [C.string, C.special(C.brace), C.regexp],
      color: "#00D8FF"
    },
    {
      tag: C.number,
      color: "#E62286"
    },
    {
      tag: [C.variableName, C.attributeName, C.self],
      color: "#E62286",
      fontWeight: "bold"
    },
    {
      tag: C.function(C.variableName),
      color: "#fff",
      fontWeight: "bold"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#fff",
    foreground: "#000",
    caret: "#000",
    selection: "#BDD5FC",
    gutterBackground: "#fff",
    gutterForeground: "#00000070",
    lineHighlight: "#FFFBD1"
  },
  styles: [
    {
      tag: C.comment,
      color: "#BCC8BA"
    },
    {
      tag: [C.string, C.special(C.brace), C.regexp],
      color: "#5D90CD"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#46A609"
    },
    {
      tag: C.keyword,
      color: "#AF956F"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#C52727"
    },
    {
      tag: [C.angleBracket, C.tagName, C.attributeName],
      color: "#606060"
    },
    {
      tag: C.self,
      color: "#000"
    }
  ]
});
const Mq = sl({
  variant: "dark",
  settings: {
    background: "#00254b",
    foreground: "#FFFFFF",
    caret: "#FFFFFF",
    selection: "#B36539BF",
    gutterBackground: "#00254b",
    gutterForeground: "#FFFFFF70",
    lineHighlight: "#00000059"
  },
  styles: [
    {
      tag: C.comment,
      color: "#0088FF"
    },
    {
      tag: C.string,
      color: "#3AD900"
    },
    {
      tag: C.regexp,
      color: "#80FFC2"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#FF628C"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#FFEE80"
    },
    {
      tag: C.variableName,
      color: "#CCCCCC"
    },
    {
      tag: C.self,
      color: "#FF80E1"
    },
    {
      tag: [
        C.className,
        C.definition(C.propertyName),
        C.function(C.variableName),
        C.definition(C.typeName),
        C.labelName
      ],
      color: "#FFDD00"
    },
    {
      tag: [C.keyword, C.operator],
      color: "#FF9D00"
    },
    {
      tag: [C.propertyName, C.typeName],
      color: "#80FFBB"
    },
    {
      tag: C.special(C.brace),
      color: "#EDEF7D"
    },
    {
      tag: C.attributeName,
      color: "#9EFFFF"
    },
    {
      tag: C.derefOperator,
      color: "#fff"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#060521",
    foreground: "#E0E0E0",
    caret: "#FFFFFFA6",
    selection: "#122BBB",
    gutterBackground: "#060521",
    gutterForeground: "#E0E0E090",
    lineHighlight: "#FFFFFF0F"
  },
  styles: [
    {
      tag: C.comment,
      color: "#AEAEAE"
    },
    {
      tag: [C.string, C.special(C.brace), C.regexp],
      color: "#8DFF8E"
    },
    {
      tag: [
        C.className,
        C.definition(C.propertyName),
        C.function(C.variableName),
        C.function(C.definition(C.variableName)),
        C.definition(C.typeName)
      ],
      color: "#A3EBFF"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#62E9BD"
    },
    {
      tag: [C.keyword, C.operator],
      color: "#2BF1DC"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#F8FBB1"
    },
    {
      tag: [C.variableName, C.self],
      color: "#B683CA"
    },
    {
      tag: [C.angleBracket, C.tagName, C.typeName, C.propertyName],
      color: "#60A4F1"
    },
    {
      tag: C.derefOperator,
      color: "#E0E0E0"
    },
    {
      tag: C.attributeName,
      color: "#7BACCA"
    }
  ]
});
sl({
  variant: "dark",
  settings: {
    background: "#2d2f3f",
    foreground: "#f8f8f2",
    caret: "#f8f8f0",
    selection: "#44475a",
    gutterBackground: "#282a36",
    gutterForeground: "rgb(144, 145, 148)",
    lineHighlight: "#44475a"
  },
  styles: [
    {
      tag: C.comment,
      color: "#6272a4"
    },
    {
      tag: [C.string, C.special(C.brace)],
      color: "#f1fa8c"
    },
    {
      tag: [C.number, C.self, C.bool, C.null],
      color: "#bd93f9"
    },
    {
      tag: [C.keyword, C.operator],
      color: "#ff79c6"
    },
    {
      tag: [C.definitionKeyword, C.typeName],
      color: "#8be9fd"
    },
    {
      tag: C.definition(C.typeName),
      color: "#f8f8f2"
    },
    {
      tag: [
        C.className,
        C.definition(C.propertyName),
        C.function(C.variableName),
        C.attributeName
      ],
      color: "#50fa7b"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#000000",
    caret: "#000000",
    selection: "#80C7FF",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#00000070",
    lineHighlight: "#C1E2F8"
  },
  styles: [
    {
      tag: C.comment,
      color: "#AAAAAA"
    },
    {
      tag: [C.keyword, C.operator, C.typeName, C.tagName, C.propertyName],
      color: "#2F6F9F",
      fontWeight: "bold"
    },
    {
      tag: [C.attributeName, C.definition(C.propertyName)],
      color: "#4F9FD0"
    },
    {
      tag: [C.className, C.string, C.special(C.brace)],
      color: "#CF4F5F"
    },
    {
      tag: C.number,
      color: "#CF4F5F",
      fontWeight: "bold"
    },
    {
      tag: C.variableName,
      fontWeight: "bold"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#f2f1f8",
    foreground: "#0c006b",
    caret: "#5c49e9",
    selection: "#d5d1f2",
    gutterBackground: "#f2f1f8",
    gutterForeground: "#0c006b70",
    lineHighlight: "#e1def3"
  },
  styles: [
    {
      tag: C.comment,
      color: "#9995b7"
    },
    {
      tag: C.keyword,
      color: "#ff5792",
      fontWeight: "bold"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#ff5792"
    },
    {
      tag: [C.className, C.tagName, C.definition(C.typeName)],
      color: "#0094f0"
    },
    {
      tag: [C.number, C.bool, C.null, C.special(C.brace)],
      color: "#5842ff"
    },
    {
      tag: [C.definition(C.propertyName), C.function(C.variableName)],
      color: "#0095a8"
    },
    {
      tag: C.typeName,
      color: "#b3694d"
    },
    {
      tag: [C.propertyName, C.variableName],
      color: "#fa8900"
    },
    {
      tag: C.operator,
      color: "#ff5792"
    },
    {
      tag: C.self,
      color: "#e64100"
    },
    {
      tag: [C.string, C.regexp],
      color: "#00b368"
    },
    {
      tag: [C.paren, C.bracket],
      color: "#0431fa"
    },
    {
      tag: C.labelName,
      color: "#00bdd6"
    },
    {
      tag: C.attributeName,
      color: "#e64100"
    },
    {
      tag: C.angleBracket,
      color: "#9995b7"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#faf4ed",
    foreground: "#575279",
    caret: "#575279",
    selection: "#6e6a8614",
    gutterBackground: "#faf4ed",
    gutterForeground: "#57527970",
    lineHighlight: "#6e6a860d"
  },
  styles: [
    {
      tag: C.comment,
      color: "#9893a5"
    },
    {
      tag: [C.bool, C.null],
      color: "#286983"
    },
    {
      tag: C.number,
      color: "#d7827e"
    },
    {
      tag: C.className,
      color: "#d7827e"
    },
    {
      tag: [C.angleBracket, C.tagName, C.typeName],
      color: "#56949f"
    },
    {
      tag: C.attributeName,
      color: "#907aa9"
    },
    {
      tag: C.punctuation,
      color: "#797593"
    },
    {
      tag: [C.keyword, C.modifier],
      color: "#286983"
    },
    {
      tag: [C.string, C.regexp],
      color: "#ea9d34"
    },
    {
      tag: C.variableName,
      color: "#d7827e"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#000000",
    caret: "#000000",
    selection: "#FFFD0054",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#00000070",
    lineHighlight: "#00000008"
  },
  styles: [
    {
      tag: C.comment,
      color: "#CFCFCF"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#E66C29"
    },
    {
      tag: [
        C.className,
        C.definition(C.propertyName),
        C.function(C.variableName),
        C.labelName,
        C.definition(C.typeName)
      ],
      color: "#2EB43B"
    },
    {
      tag: C.keyword,
      color: "#D8B229"
    },
    {
      tag: C.operator,
      color: "#4EA44E",
      fontWeight: "bold"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#925A47"
    },
    {
      tag: C.string,
      color: "#704D3D"
    },
    {
      tag: C.typeName,
      color: "#2F8996"
    },
    {
      tag: [C.variableName, C.propertyName],
      color: "#77ACB0"
    },
    {
      tag: C.self,
      color: "#77ACB0",
      fontWeight: "bold"
    },
    {
      tag: C.regexp,
      color: "#E3965E"
    },
    {
      tag: [C.tagName, C.angleBracket],
      color: "#BAA827"
    },
    {
      tag: C.attributeName,
      color: "#B06520"
    },
    {
      tag: C.derefOperator,
      color: "#000"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#fef7e5",
    foreground: "#586E75",
    caret: "#000000",
    selection: "#073642",
    gutterBackground: "#fef7e5",
    gutterForeground: "#586E7580",
    lineHighlight: "#EEE8D5"
  },
  styles: [
    {
      tag: C.comment,
      color: "#93A1A1"
    },
    {
      tag: C.string,
      color: "#2AA198"
    },
    {
      tag: C.regexp,
      color: "#D30102"
    },
    {
      tag: C.number,
      color: "#D33682"
    },
    {
      tag: C.variableName,
      color: "#268BD2"
    },
    {
      tag: [C.keyword, C.operator, C.punctuation],
      color: "#859900"
    },
    {
      tag: [C.definitionKeyword, C.modifier],
      color: "#073642",
      fontWeight: "bold"
    },
    {
      tag: [C.className, C.self, C.definition(C.propertyName)],
      color: "#268BD2"
    },
    {
      tag: C.function(C.variableName),
      color: "#268BD2"
    },
    {
      tag: [C.bool, C.null],
      color: "#B58900"
    },
    {
      tag: C.tagName,
      color: "#268BD2",
      fontWeight: "bold"
    },
    {
      tag: C.angleBracket,
      color: "#93A1A1"
    },
    {
      tag: C.attributeName,
      color: "#93A1A1"
    },
    {
      tag: C.typeName,
      color: "#859900"
    }
  ]
});
sl({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#4D4D4C",
    caret: "#AEAFAD",
    selection: "#D6D6D6",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#4D4D4C80",
    lineHighlight: "#EFEFEF"
  },
  styles: [
    {
      tag: C.comment,
      color: "#8E908C"
    },
    {
      tag: [C.variableName, C.self, C.propertyName, C.attributeName, C.regexp],
      color: "#C82829"
    },
    {
      tag: [C.number, C.bool, C.null],
      color: "#F5871F"
    },
    {
      tag: [C.className, C.typeName, C.definition(C.typeName)],
      color: "#C99E00"
    },
    {
      tag: [C.string, C.special(C.brace)],
      color: "#718C00"
    },
    {
      tag: C.operator,
      color: "#3E999F"
    },
    {
      tag: [C.definition(C.propertyName), C.function(C.variableName)],
      color: "#4271AE"
    },
    {
      tag: C.keyword,
      color: "#8959A8"
    },
    {
      tag: C.derefOperator,
      color: "#4D4D4C"
    }
  ]
});
const zq = ({
  initialValue: o = 'print("Hello, World!")',
  onChange: e
}) => {
  const [n, l] = Zn.useState(o);
  Zn.useEffect(() => {
    l(o);
  }, [o]);
  const s = (c) => {
    l(c), e && e(c);
  };
  return /* @__PURE__ */ Ks.jsx("div", { className: "code-editor-container", children: /* @__PURE__ */ Ks.jsx(
    oz,
    {
      value: n,
      height: "100%",
      extensions: [
        Dq(),
        Me.theme({
          "&": {
            textAlign: "left"
          }
        })
      ],
      theme: Mq,
      onChange: s,
      basicSetup: {
        lineNumbers: !1,
        highlightActiveLine: !0,
        highlightActiveLineGutter: !1,
        foldGutter: !1,
        dropCursor: !0,
        allowMultipleSelections: !1,
        syntaxHighlighting: !0
      }
    }
  ) });
}, Qq = ({
  code: o,
  streamlitConfig: e = {
    "client.toolbarMode": "minimal",
    "server.runOnSave": !0
  },
  requirements: n = [],
  files: l = {}
}) => {
  const s = Zn.useRef(null);
  return Zn.useEffect(() => {
    var c;
    if (s.current) {
      const d = s.current, m = d.contentDocument || ((c = d.contentWindow) == null ? void 0 : c.document);
      if (m) {
        const y = `
          <!doctype html>
          <html>
            <head>
              <meta charset="UTF-8" />
              <meta http-equiv="X-UA-Compatible" content="IE=edge" />
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1, shrink-to-fit=no"
              />
              <title>Stlite App</title>
              <link
                rel="stylesheet"
                href="https://cdn.jsdelivr.net/npm/@stlite/browser@0.76.0/build/style.css"
              />
            </head>
            <body>
              <div id="root"></div>
              <script type="module">
                import { mount } from "https://cdn.jsdelivr.net/npm/@stlite/browser@0.76.0/build/stlite.js";

                // Create a simple initial app
                const initialCode = \`${o}\`;

                // Mount the stlite app with entrypoint configuration
                let app;
                try {
                  app = mount(
                    {
                      requirements: ${JSON.stringify(n)},
                      entrypoint: "app.py",
                      files: {
                        "app.py": initialCode,
                        ...${JSON.stringify(l)}
                      },
                      streamlitConfig: ${JSON.stringify(e)}
                    },
                    document.getElementById("root")
                  );

                  // Make the app available globally in the iframe
                  window.stliteApp = app;

                  // Listen for messages from the parent
                  window.addEventListener('message', (event) => {
                    if (event.data.type === 'UPDATE_CODE') {
                      try {
                        // Use the global app reference
                        window.stliteApp.writeFile('app.py', event.data.code);
                      } catch (error) {
                        console.error('Error updating code:', error);
                      }
                    }
                  });
                } catch (error) {
                  console.error('Error mounting stlite app:', error);
                  document.getElementById("root").innerHTML = '<div style="color: red; padding: 20px;">Error: ' + error.message + '</div>';
                }
              <\/script>
            </body>
          </html>
        `;
        m.open(), m.write(y), m.close();
      }
    }
  }, []), Zn.useEffect(() => {
    s.current && s.current.contentWindow && s.current.contentWindow.postMessage(
      { type: "UPDATE_CODE", code: o },
      "*"
    );
  }, [o]), /* @__PURE__ */ Ks.jsx("div", { className: "iframe-container", children: /* @__PURE__ */ Ks.jsx("iframe", { ref: s, title: "Stlite Preview" }) });
}, Nq = ({
  initialCode: o = 'print("Hello, World!")',
  requirements: e = [],
  streamlitConfig: n = {
    "client.toolbarMode": "minimal",
    "server.runOnSave": !0
  },
  files: l = {}
}) => {
  const [s, c] = Zn.useState(o), d = (m) => {
    c(m);
  };
  return /* @__PURE__ */ Ks.jsxs("div", { className: "playground-container", children: [
    /* @__PURE__ */ Ks.jsx("div", { className: "playground-editor", children: /* @__PURE__ */ Ks.jsx(
      zq,
      {
        initialValue: s,
        onChange: d
      }
    ) }),
    /* @__PURE__ */ Ks.jsx("div", { className: "playground-preview", children: /* @__PURE__ */ Ks.jsx(
      Qq,
      {
        code: s,
        requirements: e,
        streamlitConfig: n,
        files: l
      }
    ) })
  ] });
};
function Uq(o = {}, e) {
  const {
    initialCode: n = `import streamlit as st

st.title("Hello World")
st.write("This is a Streamlit app")`,
    requirements: l = ["numpy", "pandas"],
    streamlitConfig: s = {
      "client.toolbarMode": "minimal",
      "server.runOnSave": !0
    },
    files: c = {}
  } = o;
  N3.createRoot(e).render(
    E3.createElement(Nq, {
      initialCode: n,
      requirements: l,
      streamlitConfig: s,
      files: c
    })
  );
}
const _q = { mount: Uq };
export {
  _q as default,
  Uq as mount
};
